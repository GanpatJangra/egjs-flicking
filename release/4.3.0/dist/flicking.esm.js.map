{"version":3,"file":"flicking.esm.js","sources":["../src/const/error.ts","../src/const/external.ts","../src/utils.ts","../src/core/FlickingError.ts","../src/core/Viewport.ts","../src/const/axes.ts","../src/control/states/State.ts","../src/control/states/IdleState.ts","../src/control/states/HoldingState.ts","../src/control/states/DraggingState.ts","../src/control/states/AnimatingState.ts","../src/control/states/DisabledState.ts","../src/control/StateMachine.ts","../src/control/AxesController.ts","../src/control/Control.ts","../src/core/AnchorPoint.ts","../src/control/SnapControl.ts","../src/control/FreeControl.ts","../src/control/StrictControl.ts","../src/camera/Camera.ts","../src/camera/LinearCamera.ts","../src/camera/CircularCamera.ts","../src/camera/BoundCamera.ts","../src/renderer/Renderer.ts","../src/core/panel/Panel.ts","../src/core/panel/ElementPanel.ts","../src/renderer/VanillaRenderer.ts","../src/renderer/ExternalRenderer.ts","../src/Flicking.ts","../src/core/panel/ExternalPanel.ts","../src/cfc/withFlickingMethods.ts","../src/cfc/sync.ts","../src/cfc/getRenderingPanels.ts","../src/cfc/getDefaultCameraTransform.ts","../src/index.ts"],"sourcesContent":["/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n/* eslint-disable @typescript-eslint/restrict-template-expressions */\n\n/**\n * Error codes of {@link FlickingError}. Below are the conditions where each error code occurs.\n * @ko {@link FlickingError}의 에러 코드. 아래는 각각의 에러 코드가 발생하는 조건입니다.\n * @name ERROR_CODE\n * @constant\n * @type object\n * @property {number} WRONG_TYPE Parameter type is wrong<ko>패러미터의 타입이 잘못되었을 경우</ko>\n * @property {number} ELEMENT_NOT_FOUND Element is not found inside page with the given CSS selector<ko>주어진 CSS selector로 페이지 내에서 해당 엘리먼트를 찾지 못했을 경우</ko>\n * @property {number} VAL_MUST_NOT_NULL Expected non-null value, but given `null` or `undefined`<ko>값을 기대했으나, `null`이나 `undefined`를 받은 경우</ko>\n * @property {number} NOT_ATTACHED_TO_FLICKING When Flicking's component is not initialized (i.e. {@link Flicking#init} is not called)<ko>Flicking 내부 컴포넌트가 초기화되지 않은 경우 ({@link Flicking#init}이 호출되지 않은 경우)</ko>\n * @property {number} WRONG_OPTION One of the options is wrong<ko>옵션들 중 잘못된 값이 있을 때</ko>\n * @property {number} INDEX_OUT_OF_RANGE When the given index is out of possible range<ko>인덱스가 주어진 범위를 벗어난 경우</ko>\n * @property {number} POSITION_NOT_REACHABLE When {@link Control#moveToPosition}'s position parameter is out of possible range.<ko>{@link Control#moveToPosition}의 `position` 패러미터가 도달 가능한 범위를 벗어난 경우</ko>\n * @property {number} TRANSFORM_NOT_SUPPORTED CSS `transform` property is not available(<=IE8) <ko>CSS `transform` 속성을 사용할 수 없는 경우(<=IE8)</ko>\n * @property {number} STOP_CALLED_BY_USER When the event's `stop()` is called by user.<ko>사용자에 의해 이벤트의 `stop()`이 호출된 경우</ko>\n * @property {number} ANIMATION_INTERRUPTED When the animation is interrupted by user.<ko>사용자에 의해 애니메이션이 중단된 경우</ko>\n * @property {number} ANIMATION_ALREADY_PLAYING When the animation is already playing.<ko>현재 애니메이션이 이미 진행중인 경우</ko>\n * @property {number} NOT_ALLOWED_IN_FRAMEWORK When the non-allowed method is called from frameworks (React, Angular, Vue...)\n * <ko>프레임워크(React, Angular, Vue ...)에서 사용 불가능한 메소드를 호출했을 경우</ko>\n * @property {number} NOT_INITIALIZED When the {@link Flicking#init} is not called before but is needed<ko>{@link Flicking#init}의 호출이 필요하나, 아직 호출되지 않았을 경우</ko>\n * @property {number} NO_ACTIVE When there're no active panel that flicking has selected. This may be due to the absence of any panels<ko>현재 Flicking이 선택한 패널이 없을 경우. 일반적으로 패널이 하나도 없는 경우에 발생할 수 있습니다</ko>\n */\nexport const CODE = {\n  WRONG_TYPE: 0,\n  ELEMENT_NOT_FOUND: 1,\n  VAL_MUST_NOT_NULL: 2,\n  NOT_ATTACHED_TO_FLICKING: 3,\n  WRONG_OPTION: 4,\n  INDEX_OUT_OF_RANGE: 5,\n  POSITION_NOT_REACHABLE: 6,\n  TRANSFORM_NOT_SUPPORTED: 7,\n  STOP_CALLED_BY_USER: 8,\n  ANIMATION_INTERRUPTED: 9,\n  ANIMATION_ALREADY_PLAYING: 10,\n  NOT_ALLOWED_IN_FRAMEWORK: 11,\n  NOT_INITIALIZED: 12,\n  NO_ACTIVE: 13\n} as const;\n\nexport const MESSAGE = {\n  WRONG_TYPE: (wrongVal: any, correctTypes: string[]) => `${wrongVal}(${typeof wrongVal}) is not a ${correctTypes.map(type => `\"${type}\"`).join(\" or \")}.`,\n  ELEMENT_NOT_FOUND: (selector: string) => `Element with selector \"${selector}\" not found.`,\n  VAL_MUST_NOT_NULL: (val: any, name: string) => `${name} should be provided. Given: ${val}`,\n  NOT_ATTACHED_TO_FLICKING: (name: string) => `${name} is not attached to the Flicking instance. \"init()\" should be called first.`,\n  WRONG_OPTION: (optionName: string, val: any) => `Option \"${optionName}\" is not in correct format, given: ${val}`,\n  INDEX_OUT_OF_RANGE: (val: number, min: number, max: number) => `Index \"${val}\" is out of range: should be between ${min} and ${max}.`,\n  POSITION_NOT_REACHABLE: (position: number) => `Position \"${position}\" is not reachable.`,\n  TRANSFORM_NOT_SUPPORTED: \"Browser does not support CSS transform.\",\n  STOP_CALLED_BY_USER: \"Event stop() is called by user.\",\n  ANIMATION_INTERRUPTED: \"Animation is interrupted by user input.\",\n  ANIMATION_ALREADY_PLAYING: \"Animation is already playing.\",\n  NOT_ALLOWED_IN_FRAMEWORK: \"This behavior is not allowed in the frameworks like React, Vue, or Angular.\",\n  NOT_INITIALIZED: \"Flicking is not initialized yet, call init() first.\",\n  NO_ACTIVE: \"There's no active panel that Flicking has selected. This may be due to the absence of any panels.\"\n} as const;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nexport { CODE as ERROR_CODE } from \"./error\";\n\n/**\n * Event type object with event name strings of {@link Flicking}\n * @ko {@link Flicking}의 이벤트 이름 문자열들을 담은 객체\n * @type {object}\n * @property {\"holdStart\"} HOLD_START holdStart event<ko>holdStart 이벤트</ko>\n * @property {\"holdEnd\"} HOLD_END holdEnd event<ko>holdEnd 이벤트</ko>\n * @property {\"moveStart\"} MOVE_START moveStart event<ko>moveStart 이벤트</ko>\n * @property {\"move\"} MOVE move event<ko>move 이벤트</ko>\n * @property {\"moveEnd\"} MOVE_END moveEnd event<ko>moveEnd 이벤트</ko>\n * @property {\"willChange\"} WILL_CHANGE willChange event<ko>willChange 이벤트</ko>\n * @property {\"changed\"} CHANGED changed event<ko>changed 이벤트</ko>\n * @property {\"willRestore\"} WILL_RESTORE willRestore event<ko>willRestore 이벤트</ko>\n * @property {\"restored\"} RESTORED restored event<ko>restored 이벤트</ko>\n * @property {\"select\"} SELECT select event<ko>select 이벤트</ko>\n * @property {\"needPanel\"} NEED_PANEL needPanel event<ko>needPanel 이벤트</ko>\n * @property {\"panelChange\"} PANEL_CHANGE panelChange event<ko>panelChange 이벤트</ko>\n * @example\n * ```ts\n * import { EVENTS } from \"@egjs/flicking\";\n * EVENTS.MOVE_START; // \"moveStart\"\n * ```\n */\nexport const EVENTS = {\n  READY: \"ready\",\n  BEFORE_RESIZE: \"beforeResize\",\n  AFTER_RESIZE: \"afterResize\",\n  HOLD_START: \"holdStart\",\n  HOLD_END: \"holdEnd\",\n  MOVE_START: \"moveStart\",\n  MOVE: \"move\",\n  MOVE_END: \"moveEnd\",\n  WILL_CHANGE: \"willChange\",\n  CHANGED: \"changed\",\n  WILL_RESTORE: \"willRestore\",\n  RESTORED: \"restored\",\n  SELECT: \"select\",\n  NEED_PANEL: \"needPanel\",\n  VISIBLE_CHANGE: \"visibleChange\",\n  REACH_EDGE: \"reachEdge\",\n  PANEL_CHANGE: \"panelChange\"\n} as const;\n\n/**\n * An object with all possible predefined literal string for the {@link Flicking#align align} option\n * @ko {@link Flicking#align align} 옵션에 사용되는 미리 정의된 리터럴 상수들을 담고 있는 객체\n * @type {object}\n * @property {\"prev\"} PREV left/top align<ko>좌/상 정렬</ko>\n * @property {\"center\"} CENTER center align<ko>중앙 정렬</ko>\n * @property {\"next\"} NEXT right/bottom align<ko>우/하 정렬</ko>\n */\nexport const ALIGN = {\n  PREV: \"prev\",\n  CENTER: \"center\",\n  NEXT: \"next\"\n} as const;\n\n/**\n * An object of directions\n * @ko 방향을 나타내는 값들을 담고 있는 객체\n * @type {object}\n * @property {\"PREV\"} PREV \"left\" when {@link Flicking#horizontal horizontal} is true, and \"top\" when {@link Flicking#horizontal horizontal} is false\n * <ko>{@link Flicking#horizontal horizontal}가 `true`일 경우 왼쪽, {@link Flicking#horizontal horizontal}가 `false`일 경우 위쪽을 의미합니다</ko>\n * @property {\"NEXT\"} NEXT \"right\" when {@link Flicking#horizontal horizontal} is true, and \"bottom\" when {@link Flicking#horizontal horizontal} is false\n * <ko>{@link Flicking#horizontal horizontal}가 `true`일 경우 오른쪽, {@link Flicking#horizontal horizontal}가 `false`일 경우 아래쪽을 의미합니다</ko>\n * @property {null} NONE This value usually means it's the same position<ko>주로 제자리인 경우를 의미합니다</ko>\n */\nexport const DIRECTION = {\n  PREV: \"PREV\",\n  NEXT: \"NEXT\",\n  NONE: null\n} as const;\n\n/**\n * An object with all possible {@link Flicking#moveType moveType}s\n * @ko Flicking이 제공하는 {@link Flicking#moveType moveType}들을 담고 있는 객체\n * @type {object}\n * @property {\"snap\"} SNAP Flicking's {@link Flicking#moveType moveType} that enables {@link SnapControl} as a Flicking's {@link Flicking#control control}\n * <ko>Flicking의 {@link Flicking#control control}을 {@link SnapControl}로 설정하게 하는 {@link Flicking#moveType moveType}</ko>\n * @property {\"freeScroll\"} FREE_SCROLL Flicking's {@link Flicking#moveType moveType} that enables {@link FreeControl} as a Flicking's {@link Flicking#control control}\n * <ko>Flicking의 {@link Flicking#control control}을 {@link FreeControl}로 설정하게 하는 {@link Flicking#moveType moveType}</ko>\n * @property {\"strict\"} STRICT Flicking's {@link Flicking#moveType moveType} that enables {@link StrictControl} as a Flicking's {@link Flicking#control control}\n * <ko>Flicking의 {@link Flicking#control control}을 {@link StrictControl}로 설정하게 하는 {@link Flicking#moveType moveType}</ko>\n */\nexport const MOVE_TYPE = {\n  SNAP: \"snap\",\n  FREE_SCROLL: \"freeScroll\",\n  STRICT: \"strict\"\n} as const;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking, { FlickingOptions } from \"./Flicking\";\nimport FlickingError from \"./core/FlickingError\";\nimport * as ERROR from \"./const/error\";\nimport { ALIGN, DIRECTION } from \"./const/external\";\nimport { LiteralUnion, Merged, ValueOf } from \"./type/internal\";\nimport { ElementLike } from \"./type/external\";\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport const merge = <From extends object, To extends object>(target: From, ...sources: To[]): Merged<From, To> => {\n  sources.forEach(source => {\n    Object.keys(source).forEach(key => {\n      target[key] = source[key] as unknown;\n    });\n  });\n\n  return target as Merged<From, To>;\n};\n\nexport const getElement = (el: HTMLElement | string | null, parent?: HTMLElement): HTMLElement => {\n  let targetEl: HTMLElement | null = null;\n\n  if (isString(el)) {\n    const parentEl = parent ? parent : document;\n    const queryResult = parentEl.querySelector(el);\n    if (!queryResult) {\n      throw new FlickingError(ERROR.MESSAGE.ELEMENT_NOT_FOUND(el), ERROR.CODE.ELEMENT_NOT_FOUND);\n    }\n    targetEl = queryResult as HTMLElement;\n  } else if (el && el.nodeType === Node.ELEMENT_NODE) {\n    targetEl = el;\n  }\n\n  if (!targetEl) {\n    throw new FlickingError(ERROR.MESSAGE.WRONG_TYPE(el, [\"HTMLElement\", \"string\"]), ERROR.CODE.WRONG_TYPE);\n  }\n\n  return targetEl;\n};\n\nexport const checkExistence = (value: any, nameOnErrMsg: string) => {\n  if (value == null) {\n    throw new FlickingError(ERROR.MESSAGE.VAL_MUST_NOT_NULL(value, nameOnErrMsg), ERROR.CODE.VAL_MUST_NOT_NULL);\n  }\n};\n\nexport const clamp = (x: number, min: number, max: number) => Math.max(Math.min(x, max), min);\n\nexport const getFlickingAttached = (val: Flicking | null, nameToThrowOnError: string): Flicking => {\n  if (!val) {\n    throw new FlickingError(ERROR.MESSAGE.NOT_ATTACHED_TO_FLICKING(nameToThrowOnError), ERROR.CODE.NOT_ATTACHED_TO_FLICKING);\n  }\n\n  return val;\n};\n\nexport const toArray = <T>(iterable: ArrayLike<T>): T[] => [].slice.call(iterable) as T[];\n\nexport const parseAlign = (align: LiteralUnion<ValueOf<typeof ALIGN>> | number, size: number): number => {\n  let alignPoint: number | null;\n  if (isString(align)) {\n    switch (align) {\n      case ALIGN.PREV:\n        alignPoint = 0;\n        break;\n      case ALIGN.CENTER:\n        alignPoint = 0.5 * size;\n        break;\n      case ALIGN.NEXT:\n        alignPoint = size;\n        break;\n      default:\n        alignPoint = parseArithmeticSize(align, size);\n        if (alignPoint == null) {\n          throw new FlickingError(ERROR.MESSAGE.WRONG_OPTION(\"align\", align), ERROR.CODE.WRONG_OPTION);\n        }\n    }\n  } else {\n    alignPoint = align as number;\n  }\n\n  return alignPoint;\n};\n\nexport const parseBounce = (bounce: FlickingOptions[\"bounce\"], size: number): number[] => {\n  let parsedBounce: Array<number | null>;\n\n  if (Array.isArray(bounce)) {\n    parsedBounce = (bounce as string[]).map(val => parseArithmeticSize(val, size));\n  } else {\n    const parsedVal = parseArithmeticSize(bounce, size);\n\n    parsedBounce = [parsedVal, parsedVal];\n  }\n\n  return parsedBounce.map(val => {\n    if (val == null) {\n      throw new FlickingError(ERROR.MESSAGE.WRONG_OPTION(\"bounce\", bounce), ERROR.CODE.WRONG_OPTION);\n    }\n    return val;\n  });\n};\n\nexport const parseArithmeticSize = (cssValue: number | string, base: number): number | null => {\n  const parsed = parseArithmeticExpression(cssValue);\n\n  if (parsed == null) return null;\n\n  return parsed.percentage * base + parsed.absolute;\n};\n\nexport const parseArithmeticExpression = (cssValue: number | string): { percentage: number; absolute: number } | null => {\n  const cssRegex = /(?:(\\+|\\-)\\s*)?(\\d+(?:\\.\\d+)?(%|px)?)/g;\n\n  if (typeof cssValue === \"number\") {\n    return { percentage: 0, absolute: cssValue };\n  }\n\n  const parsed = {\n    percentage: 0,\n    absolute: 0\n  };\n  let idx = 0;\n  let matchResult = cssRegex.exec(cssValue);\n  while (matchResult != null) {\n    let sign = matchResult[1];\n    const value = matchResult[2];\n    const unit = matchResult[3];\n    const parsedValue = parseFloat(value);\n\n    if (idx <= 0) {\n      sign = sign || \"+\";\n    }\n\n    // Return default value for values not in good form\n    if (!sign) {\n      return null;\n    }\n\n    const signMultiplier = sign === \"+\" ? 1 : -1;\n\n    if (unit === \"%\") {\n      parsed.percentage += signMultiplier * (parsedValue / 100);\n    } else {\n      parsed.absolute += signMultiplier * parsedValue;\n    }\n\n    // Match next occurrence\n    ++idx;\n    matchResult = cssRegex.exec(cssValue);\n  }\n\n  // None-matched\n  if (idx === 0) {\n    return null;\n  }\n\n  return parsed;\n};\n\nexport const parseCSSSizeValue = (val: string | number): string => isString(val) ? val : `${val}px`;\n\nexport const getDirection = (start: number, end: number): ValueOf<typeof DIRECTION> => {\n  if (start === end) return DIRECTION.NONE;\n  return start < end ? DIRECTION.NEXT : DIRECTION.PREV;\n};\n\nexport const parseElement = (element: ElementLike | ElementLike[]): HTMLElement[] => {\n  if (!Array.isArray(element)) {\n    element = [element];\n  }\n\n  const elements: HTMLElement[] = [];\n  element.forEach(el => {\n    if (isString(el)) {\n      const tempDiv = document.createElement(\"div\");\n      tempDiv.innerHTML = el;\n\n      elements.push(...toArray(tempDiv.children) as HTMLElement[]);\n      while (tempDiv.firstChild) {\n        tempDiv.removeChild(tempDiv.firstChild);\n      }\n    } else if (el && el.nodeType === Node.ELEMENT_NODE) {\n      elements.push(el);\n    } else {\n      throw new FlickingError(ERROR.MESSAGE.WRONG_TYPE(el, [\"HTMLElement\", \"string\"]), ERROR.CODE.WRONG_TYPE);\n    }\n  });\n\n  return elements;\n};\n\nexport const getMinusCompensatedIndex = (idx: number, max: number) => idx < 0 ? clamp(idx + max, 0, max) : clamp(idx, 0, max);\n\nexport const includes = <T>(array: T[], target: any): target is T => {\n  for (const val of array) {\n    if (val === target) return true;\n  }\n  return false;\n};\n\nexport const isString = (val: any): val is string => typeof val === \"string\";\n\nexport const circulatePosition = (pos: number, min: number, max: number) => {\n  const size = max - min;\n\n  if (pos < min) {\n    const offset = (min - pos) % size;\n    pos = max - offset;\n  } else if (pos > max) {\n    const offset = (pos - max) % size;\n    pos = min + offset;\n  }\n\n  return pos;\n};\n\nexport const find = <T>(array: T[], checker: (val: T) => boolean): T | null => {\n  for (const val of array) {\n    if (checker(val)) {\n      return val;\n    }\n  }\n\n  return null;\n};\n\nexport const findRight = <T>(array: T[], checker: (val: T) => boolean): T | null => {\n  for (let idx = array.length - 1; idx >= 0; idx--) {\n    const val = array[idx];\n    if (checker(val)) {\n      return val;\n    }\n  }\n\n  return null;\n};\n\nexport const findIndex = <T>(array: T[], checker: (val: T) => boolean): number => {\n  for (let idx = 0; idx < array.length; idx++) {\n    if (checker(array[idx])) {\n      return idx;\n    }\n  }\n\n  return -1;\n};\n\nexport const getProgress = (pos: number, prev: number, next: number) => (pos - prev) / (next - prev);\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nexport const getStyle = (el: HTMLElement): CSSStyleDeclaration => window.getComputedStyle(el) || (el as any).currentStyle as CSSStyleDeclaration;\n\nexport const isBetween = (val: number, min: number, max: number) => val >= min && val <= max;\n\nexport const circulateIndex = (index: number, max: number): number => {\n  if (index >= max) {\n    return index % max;\n  } else if (index < 0) {\n    return getMinusCompensatedIndex((index + 1) % max - 1, max);\n  } else {\n    return index;\n  }\n};\n\nexport const setPrototypeOf = Object.setPrototypeOf || ((obj, proto) => {\n  obj.__proto__ = proto;\n  return obj;\n});\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport { setPrototypeOf } from \"../utils\";\n\n/**\n * Special type of known error that {@link Flicking} throws.\n * @ko Flicking 내부에서 알려진 오류 발생시 throw되는 에러\n * @property {number} code Error code<ko>에러 코드</ko>\n * @property {string} message Error message<ko>에러 메시지</ko>\n * @see {@link Constants.ERROR_CODE ERROR_CODE}\n * @example\n * ```ts\n * import Flicking, { FlickingError, ERROR_CODES } from \"@egjs/flicking\";\n * try {\n *   const flicking = new Flicking(\".flicking-viewport\")\n * } catch (e) {\n *   if (e instanceof FlickingError && e.code === ERROR_CODES.ELEMENT_NOT_FOUND) {\n *     console.error(\"Element not found\")\n *   }\n * }\n * ```\n */\nclass FlickingError extends Error {\n  public code: number;\n\n  /**\n   * @param message Error message<ko>에러 메시지</ko>\n   * @param code Error code<ko>에러 코드</ko>\n   */\n  public constructor(message: string, code: number) {\n    super(message);\n\n    setPrototypeOf(this, FlickingError.prototype);\n    this.name = \"FlickingError\";\n    this.code = code;\n  }\n}\n\nexport default FlickingError;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { getStyle, isString } from \"../utils\";\n\n/**\n * A component that manages viewport size\n * @ko 뷰포트 크기 정보를 담당하는 컴포넌트\n */\nclass Viewport {\n  private _el: HTMLElement;\n  private _width: number;\n  private _height: number;\n  private _isBorderBoxSizing: boolean;\n  private _padding: {\n    left: number;\n    right: number;\n    top: number;\n    bottom: number;\n  };\n\n  /**\n   * A viewport(root) element\n   * @ko 뷰포트(root) 엘리먼트\n   * @type {HTMLElement}\n   * @readonly\n   */\n  public get element() { return this._el; }\n\n  /**\n   * Viewport width, without paddings\n   * @ko 뷰포트 너비\n   * @type {number}\n   * @readonly\n   */\n  public get width() { return this._width - this._padding.left - this._padding.right; }\n  /**\n   * Viewport height, without paddings\n   * @ko 뷰포트 높이\n   * @type {number}\n   * @readonly\n   */\n  public get height() { return this._height - this._padding.top - this._padding.bottom; }\n  /**\n   * Viewport paddings\n   * @ko 뷰포트 CSS padding 값\n   * @type {object}\n   * @property {number} left CSS `padding-left`\n   * @property {number} right CSS `padding-right`\n   * @property {number} top CSS `padding-top`\n   * @property {number} bottom CSS `padding-bottom`\n   * @readonly\n   */\n  public get padding() { return this._padding; }\n\n  /**\n   * @param el A viewport element<ko>뷰포트 엘리먼트</ko>\n   */\n  public constructor(el: HTMLElement) {\n    this._el = el;\n    this._width = 0;\n    this._height = 0;\n    this._padding = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    this._isBorderBoxSizing = false;\n  }\n\n  /**\n   * Change viewport's size.\n   * This will change the actual size of `.flicking-viewport` element by changing its CSS width/height property\n   * @ko 뷰포트 크기를 변경합니다.\n   * `.flicking-viewport` 엘리먼트에 해당 크기의 CSS width/height를 적용합니다\n   * @param {object} [size] New viewport size<ko>새 뷰포트 크기</ko>\n   * @param {number|string} [size.width] CSS string or number(in px)<ko>CSS 문자열 또는 숫자(px)</ko>\n   * @param {number|string} [size.height] CSS string or number(in px)<ko>CSS 문자열 또는 숫자(px)</ko>\n   */\n  public setSize({\n    width,\n    height\n  }: Partial<{\n    width: number | string;\n    height: number | string;\n  }>) {\n    const el = this._el;\n    const padding = this._padding;\n    const isBorderBoxSizing = this._isBorderBoxSizing;\n\n    if (width != null) {\n      if (isString(width)) {\n        el.style.width = width;\n      } else {\n        const newWidth = isBorderBoxSizing\n          ? width + padding.left + padding.right\n          : width;\n        el.style.width = `${newWidth}px`;\n      }\n    }\n    if (height != null) {\n      if (isString(height)) {\n        el.style.height = height;\n      } else {\n        const newHeight = isBorderBoxSizing\n          ? height + padding.top + padding.bottom\n          : height;\n        el.style.height = `${newHeight}px`;\n      }\n    }\n    this.resize();\n  }\n\n  /**\n   * Update width/height to the current viewport element's size\n   * @ko 현재 뷰포트 엘리먼트의 크기로 너비/높이를 업데이트합니다\n   */\n  public resize() {\n    const el = this._el;\n    const elStyle = getStyle(el);\n\n    this._width = el.clientWidth;\n    this._height = el.clientHeight;\n    this._padding = {\n      left: parseFloat(elStyle.paddingLeft),\n      right: parseFloat(elStyle.paddingRight),\n      top: parseFloat(elStyle.paddingTop),\n      bottom: parseFloat(elStyle.paddingBottom)\n    };\n    this._isBorderBoxSizing = elStyle.boxSizing === \"border-box\";\n  }\n}\n\nexport default Viewport;\n","/**\n * All possible @egjs/axes event keys\n * @internal\n */\nexport const EVENT = {\n  HOLD: \"hold\",\n  CHANGE: \"change\",\n  RELEASE: \"release\",\n  ANIMATION_END: \"animationEnd\",\n  FINISH: \"finish\"\n} as const;\n\n/**\n * An Axis key that Flicking uses\n * @internal\n */\nexport const POSITION_KEY = \"flick\";\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { OnAnimationEnd, OnChange, OnFinish, OnHold, OnRelease } from \"@egjs/axes\";\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport Flicking from \"../../Flicking\";\nimport Panel from \"../../core/panel/Panel\";\nimport { EVENTS } from \"../../const/external\";\nimport * as AXES from \"../../const/axes\";\nimport { circulatePosition, getDirection } from \"../../utils\";\n\nexport enum STATE_TYPE {\n  IDLE,\n  HOLDING,\n  DRAGGING,\n  ANIMATING,\n  DISABLED\n}\n\n/**\n * A component that shows the current status of the user input or the animation\n * @ko 현재 사용자 입력 또는 애니메이션 상태를 나타내는 컴포넌트\n * @internal\n */\nabstract class State {\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {boolean}\n   * @readonly\n   */\n  public abstract readonly holding: boolean;\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {boolean}\n   * @readonly\n   */\n  public abstract readonly animating: boolean;\n\n  protected _delta: number = 0;\n  protected _targetPanel: Panel | null = null;\n\n  /**\n   * A sum of delta values of change events from the last hold event of Axes\n   * @ko 이전 hold이벤트부터 change에 의해 발생한 이동 delta값의 합산\n   * @type {number}\n   * @readonly\n   */\n  public get delta() { return this._delta; }\n\n  /**\n   * A panel to set as {@link Control#activePanel} after the animation is finished\n   * @ko 애니메이션 종료시 {@link Control#activePanel}로 설정할 패널\n   * @type {number}\n   * @readonly\n   */\n  public get targetPanel() { return this._targetPanel; }\n\n  public set targetPanel(val: Panel | null) { this._targetPanel = val; }\n\n  /**\n   * An callback which is called when state has changed to this state\n   * @ko 현재 상태로 돌입했을때 호출되는 콜백 함수\n   * @param {State} prevState An previous state<ko>이전 상태값</ko>\n   * @return {void}\n   */\n  public onEnter(prevState: State): void {\n    this._delta = prevState._delta;\n    this._targetPanel = prevState._targetPanel;\n  }\n\n  /**\n   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} event\n   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} 이벤트 핸들러\n   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>\n   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>\n   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} event of Axes\n   * <ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} 이벤트</ko>\n   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>\n   * @return {void}\n   */\n  public onHold(ctx: {\n    flicking: Flicking;\n    axesEvent: OnHold;\n    transitTo: (nextState: STATE_TYPE) => State;\n  }): void {\n    // DO NOTHING\n  }\n\n  /**\n   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} event\n   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} 이벤트 핸들러\n   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>\n   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>\n   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} event of Axes\n   * <ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} 이벤트</ko>\n   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>\n   * @return {void}\n   */\n  public onChange(ctx: {\n    flicking: Flicking;\n    axesEvent: OnChange;\n    transitTo: (nextState: STATE_TYPE) => State;\n  }): void {\n    // DO NOTHING\n  }\n\n  /**\n   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event\n   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트 핸들러\n   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>\n   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>\n   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of Axes\n   * <ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>\n   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>\n   * @return {void}\n   */\n  public onRelease(ctx: {\n    flicking: Flicking;\n    axesEvent: OnRelease;\n    transitTo: (nextState: STATE_TYPE) => State;\n  }): void {\n    // DO NOTHING\n  }\n\n  /**\n   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} event\n   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} 이벤트 핸들러\n   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>\n   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>\n   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} event of Axes\n   * <ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} 이벤트</ko>\n   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>\n   * @return {void}\n   */\n  public onAnimationEnd(ctx: {\n    flicking: Flicking;\n    axesEvent: OnAnimationEnd;\n    transitTo: (nextState: STATE_TYPE) => State;\n  }): void {\n    // DO NOTHING\n  }\n\n  /**\n   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} event\n   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} 이벤트 핸들러\n   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>\n   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>\n   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} event of Axes<ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} 이벤트</ko>\n   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>\n   * @return {void}\n   */\n  public onFinish(ctx: {\n    flicking: Flicking;\n    axesEvent: OnFinish;\n    transitTo: (nextState: STATE_TYPE) => State;\n  }): void {\n    // DO NOTHING\n  }\n\n  protected _moveToChangedPosition(ctx: Parameters<State[\"onChange\"]>[0]): void {\n    const { flicking, axesEvent, transitTo } = ctx;\n    const delta = axesEvent.delta[AXES.POSITION_KEY];\n\n    if (!delta) {\n      return;\n    }\n\n    this._delta += delta;\n\n    const camera = flicking.camera;\n    const prevPosition = camera.position;\n    const position = axesEvent.pos[AXES.POSITION_KEY];\n    const newPosition = flicking.circularEnabled\n      ? circulatePosition(position, camera.range.min, camera.range.max)\n      : position;\n\n    camera.lookAt(newPosition);\n\n    const moveEvent = new ComponentEvent(EVENTS.MOVE, {\n      isTrusted: axesEvent.isTrusted,\n      holding: this.holding,\n      direction: getDirection(0, axesEvent.delta[AXES.POSITION_KEY]),\n      axesEvent\n    });\n\n    flicking.trigger(moveEvent);\n\n    if (moveEvent.isCanceled()) {\n      // Return to previous position\n      camera.lookAt(prevPosition);\n      transitTo(STATE_TYPE.DISABLED);\n    }\n  }\n}\n\nexport default State;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport { EVENTS } from \"../../const/external\";\nimport { getDirection } from \"../../utils\";\n\nimport State, { STATE_TYPE } from \"./State\";\n\n/**\n * A default state when there's no user input and no animation's playing\n * @ko 사용자의 입력이 없고, 애니메이션이 동작하고있지 않은 기본 상태\n * @internal\n */\nclass IdleState extends State {\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {false}\n   * @readonly\n   */\n  public readonly holding = false;\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {false}\n   * @readonly\n   */\n  public readonly animating = false;\n\n  public onEnter() {\n    this._delta = 0;\n    this._targetPanel = null;\n  }\n\n  public onHold(ctx: Parameters<State[\"onHold\"]>[0]): void {\n    // Shouldn't do any action until any panels on flicking area\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    if (flicking.renderer.panelCount <= 0) {\n      transitTo(STATE_TYPE.DISABLED);\n      return;\n    }\n\n    const holdStartEvent = new ComponentEvent(EVENTS.HOLD_START, {\n      axesEvent\n    });\n\n    flicking.trigger(holdStartEvent);\n\n    if (holdStartEvent.isCanceled()) {\n      transitTo(STATE_TYPE.DISABLED);\n    } else {\n      transitTo(STATE_TYPE.HOLDING);\n    }\n  }\n\n  // By methods call\n  public onChange(ctx: Parameters<State[\"onChange\"]>[0]): void {\n    const { flicking, axesEvent, transitTo } = ctx;\n    const controller = flicking.control.controller;\n    const animatingContext = controller.animatingContext;\n\n    const moveStartEvent = new ComponentEvent(EVENTS.MOVE_START, {\n      isTrusted: axesEvent.isTrusted,\n      holding: this.holding,\n      direction: getDirection(animatingContext.start, animatingContext.end),\n      axesEvent\n    });\n    flicking.trigger(moveStartEvent);\n\n    if (moveStartEvent.isCanceled()) {\n      transitTo(STATE_TYPE.DISABLED);\n    } else {\n      // Trigger AnimatingState's onChange, to trigger \"move\" event immediately\n      transitTo(STATE_TYPE.ANIMATING).onChange(ctx);\n    }\n  }\n}\n\nexport default IdleState;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { OnRelease } from \"@egjs/axes\";\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport Panel from \"../../core/panel/Panel\";\nimport { EVENTS } from \"../../const/external\";\nimport { getDirection } from \"../../utils\";\n\nimport State, { STATE_TYPE } from \"./State\";\n\n/**\n * A state that activates when user's holding the Flicking area, but not moved a single pixel yet\n * @ko 사용자의 입력이 시작되었으나, 아직 움직이지는 않은 상태\n * @internal\n */\nclass HoldingState extends State {\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {true}\n   * @readonly\n   */\n  public readonly holding = true;\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {false}\n   * @readonly\n   */\n  public readonly animating = false;\n\n  private _releaseEvent: OnRelease | null = null;\n\n  public onChange(ctx: Parameters<State[\"onChange\"]>[0]): void {\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    const inputEvent = axesEvent.inputEvent as { offsetX: number; offsetY: number };\n\n    const offset = flicking.horizontal\n      ? inputEvent.offsetX\n      : inputEvent.offsetY;\n\n    const moveStartEvent = new ComponentEvent(EVENTS.MOVE_START, {\n      isTrusted: axesEvent.isTrusted,\n      holding: this.holding,\n      direction: getDirection(0, -offset),\n      axesEvent\n    });\n    flicking.trigger(moveStartEvent);\n\n    if (moveStartEvent.isCanceled()) {\n      transitTo(STATE_TYPE.DISABLED);\n    } else {\n      // Trigger DraggingState's onChange, to trigger \"move\" event immediately\n      transitTo(STATE_TYPE.DRAGGING).onChange(ctx);\n    }\n  }\n\n  public onRelease(ctx: Parameters<State[\"onRelease\"]>[0]): void {\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    flicking.trigger(new ComponentEvent(EVENTS.HOLD_END, { axesEvent }));\n\n    if (axesEvent.delta.flick !== 0) {\n      // Sometimes \"release\" event on axes triggered before \"change\" event\n      // Especially if user flicked panel fast in really short amount of time\n      // if delta is not zero, that means above case happened.\n\n      // Event flow should be HOLD_START -> MOVE_START -> MOVE -> HOLD_END\n      // At least one move event should be included between holdStart and holdEnd\n      axesEvent.setTo({ flick: flicking.camera.position }, 0);\n      transitTo(STATE_TYPE.IDLE);\n      return;\n    }\n\n    // Can't handle select event here,\n    // As \"finish\" axes event happens\n    this._releaseEvent = axesEvent;\n  }\n\n  public onFinish(ctx: Parameters<State[\"onFinish\"]>[0]): void {\n    const { flicking, transitTo } = ctx;\n\n    // Should transite to IDLE state before select event\n    // As user expects hold is already finished\n    transitTo(STATE_TYPE.IDLE);\n\n    if (!this._releaseEvent) {\n      return;\n    }\n\n    // Handle release event here\n    // To prevent finish event called twice\n    const releaseEvent = this._releaseEvent;\n\n    // Static click\n    /* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access */\n    const srcEvent = releaseEvent.inputEvent.srcEvent;\n\n    let clickedElement: HTMLElement;\n    if (srcEvent.type === \"touchend\") {\n      const touchEvent = srcEvent as TouchEvent;\n      const touch = touchEvent.changedTouches[0];\n      clickedElement = document.elementFromPoint(touch.clientX, touch.clientY) as HTMLElement;\n    } else {\n      clickedElement = srcEvent.target;\n    }\n    /* eslint-enable */\n\n    const panels = flicking.renderer.panels;\n    let clickedPanel: Panel | null = null;\n\n    for (const panel of panels) {\n      if (panel.contains(clickedElement)) {\n        clickedPanel = panel;\n        break;\n      }\n    }\n\n    if (clickedPanel) {\n      const cameraPosition = flicking.camera.position;\n      const clickedPanelPosition = clickedPanel.position;\n\n      flicking.trigger(new ComponentEvent(EVENTS.SELECT, {\n        index: clickedPanel.index,\n        panel: clickedPanel,\n        // Direction to the clicked panel\n        direction: getDirection(cameraPosition, clickedPanelPosition)\n      }));\n    }\n  }\n}\n\nexport default HoldingState;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport { EVENTS } from \"../../const/external\";\nimport * as AXES from \"../../const/axes\";\n\nimport State, { STATE_TYPE } from \"./State\";\n\n/**\n * A state that activates when user's dragging the Flicking area\n * @ko 사용자가 드래깅중인 상태\n * @internal\n */\nclass DraggingState extends State {\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {true}\n   * @readonly\n   */\n  public readonly holding = true;\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {true}\n   * @readonly\n   */\n  public readonly animating = true;\n\n  public onChange(ctx: Parameters<State[\"onChange\"]>[0]): void {\n    this._moveToChangedPosition(ctx);\n  }\n\n  public onRelease(ctx: Parameters<State[\"onRelease\"]>[0]): void {\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    // Update last position to cope with Axes's animating behavior\n    // Axes uses start position when animation start\n    flicking.trigger(new ComponentEvent(EVENTS.HOLD_END, {\n      axesEvent\n    }));\n\n    if (flicking.renderer.panelCount <= 0) {\n      // There're no panels\n      transitTo(STATE_TYPE.IDLE);\n      return;\n    }\n\n    transitTo(STATE_TYPE.ANIMATING);\n\n    const control = flicking.control;\n    const position = axesEvent.destPos[AXES.POSITION_KEY];\n    const duration = Math.max(axesEvent.duration, flicking.duration);\n\n    void control.moveToPosition(position, duration, axesEvent);\n  }\n}\n\nexport default DraggingState;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport { EVENTS } from \"../../const/external\";\nimport { getDirection } from \"../../utils\";\n\nimport State, { STATE_TYPE } from \"./State\";\n\n/**\n * A state that activates when Flicking's animating by user input or method call\n * @ko 사용자 입력이나 메소드 호출에 의해 Flicking의 애니메이션이 동작중인 상태\n * @internal\n */\nclass AnimatingState extends State {\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {false}\n   * @readonly\n   */\n  public readonly holding = false;\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {true}\n   * @readonly\n   */\n  public readonly animating = true;\n\n  public onHold(ctx: Parameters<State[\"onHold\"]>[0]): void {\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    this._delta = 0;\n    flicking.control.updateInput();\n\n    const holdStartEvent = new ComponentEvent(EVENTS.HOLD_START, { axesEvent });\n    flicking.trigger(holdStartEvent);\n\n    if (holdStartEvent.isCanceled()) {\n      transitTo(STATE_TYPE.DISABLED);\n    } else {\n      transitTo(STATE_TYPE.DRAGGING);\n    }\n  }\n\n  public onChange(ctx: Parameters<State[\"onChange\"]>[0]): void {\n    this._moveToChangedPosition(ctx);\n  }\n\n  public onFinish(ctx: Parameters<State[\"onFinish\"]>[0]) {\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    const control = flicking.control;\n    const controller = control.controller;\n    const animatingContext = controller.animatingContext;\n\n    transitTo(STATE_TYPE.IDLE);\n\n    flicking.trigger(new ComponentEvent(EVENTS.MOVE_END, {\n      isTrusted: axesEvent.isTrusted,\n      direction: getDirection(animatingContext.start, animatingContext.end),\n      axesEvent\n    }));\n\n    control.setActive(this._targetPanel!, control.activePanel, axesEvent.isTrusted);\n  }\n}\n\nexport default AnimatingState;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport State, { STATE_TYPE } from \"./State\";\n\n/**\n * A state that activates when Flicking is stopped by event's `stop` method\n * @ko 이벤트의 `stop`호출에 의해 Flicking이 정지된 상태\n * @internal\n */\nclass DisabledState extends State {\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {false}\n   * @readonly\n   */\n  public readonly holding = false;\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {true}\n   * @readonly\n   */\n  public readonly animating = true;\n\n  public onAnimationEnd(ctx: Parameters<State[\"onAnimationEnd\"]>[0]): void {\n    const { transitTo } = ctx;\n\n    transitTo(STATE_TYPE.IDLE);\n  }\n\n  public onChange(ctx: Parameters<State[\"onChange\"]>[0]): void {\n    const { axesEvent, transitTo } = ctx;\n\n    // Can stop Axes's change event\n    axesEvent.stop();\n\n    transitTo(STATE_TYPE.IDLE);\n  }\n\n  public onRelease(ctx: Parameters<State[\"onRelease\"]>[0]): void {\n    const { axesEvent, transitTo } = ctx;\n\n    // This is needed when stopped hold start event\n    if (axesEvent.delta.flick === 0) {\n      transitTo(STATE_TYPE.IDLE);\n    }\n  }\n}\n\nexport default DisabledState;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { AxesEvents } from \"@egjs/axes\";\n\nimport Flicking from \"../Flicking\";\nimport * as AXES from \"../const/axes\";\n\nimport IdleState from \"./states/IdleState\";\nimport HoldingState from \"./states/HoldingState\";\nimport DraggingState from \"./states/DraggingState\";\nimport AnimatingState from \"./states/AnimatingState\";\nimport DisabledState from \"./states/DisabledState\";\nimport State, { STATE_TYPE } from \"./states/State\";\n\n/**\n * @internal\n */\nclass StateMachine {\n  private _state: State;\n\n  public get state(): State { return this._state; }\n\n  public constructor() {\n    this._state = new IdleState();\n  }\n\n  public fire(eventType: keyof AxesEvents, externalCtx: {\n    flicking: Flicking;\n    axesEvent: any;\n  }) {\n    const currentState = this._state;\n    const ctx = { ...externalCtx, transitTo: this.transitTo };\n\n    switch (eventType) {\n      case AXES.EVENT.HOLD:\n        currentState.onHold(ctx);\n        break;\n      case AXES.EVENT.CHANGE:\n        currentState.onChange(ctx);\n        break;\n      case AXES.EVENT.RELEASE:\n        currentState.onRelease(ctx);\n        break;\n      case AXES.EVENT.ANIMATION_END:\n        currentState.onAnimationEnd(ctx);\n        break;\n      case AXES.EVENT.FINISH:\n        currentState.onFinish(ctx);\n        break;\n    }\n  }\n\n  public transitTo = (nextStateType: STATE_TYPE): State => {\n    let nextState: State;\n\n    switch (nextStateType) {\n      case STATE_TYPE.IDLE:\n        nextState = new IdleState();\n        break;\n      case STATE_TYPE.HOLDING:\n        nextState = new HoldingState();\n        break;\n      case STATE_TYPE.DRAGGING:\n        nextState = new DraggingState();\n        break;\n      case STATE_TYPE.ANIMATING:\n        nextState = new AnimatingState();\n        break;\n      case STATE_TYPE.DISABLED:\n        nextState = new DisabledState();\n        break;\n    }\n\n    nextState.onEnter(this._state);\n\n    this._state = nextState;\n\n    return this._state;\n  };\n}\n\nexport default StateMachine;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Axes, { PanInput, AxesEvents, OnRelease } from \"@egjs/axes\";\n\nimport Flicking from \"../Flicking\";\nimport FlickingError from \"../core/FlickingError\";\nimport * as AXES from \"../const/axes\";\nimport * as ERROR from \"../const/error\";\nimport { circulatePosition, getFlickingAttached, parseBounce } from \"../utils\";\nimport { ControlParams } from \"../type/external\";\n\nimport StateMachine from \"./StateMachine\";\n\n/**\n * A controller that handles the {@link https://naver.github.io/egjs-axes/ @egjs/axes} events\n * @ko {@link https://naver.github.io/egjs-axes/ @egjs/axes}의 이벤트를 처리하는 컨트롤러 컴포넌트\n * @internal\n */\nclass AxesController {\n  private _flicking: Flicking | null;\n  private _axes: Axes | null;\n  private _panInput: PanInput | null;\n  private _stateMachine: StateMachine;\n\n  private _animatingContext: { start: number; end: number; offset: number };\n  private _dragged: boolean;\n\n  /**\n   * An {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} instance\n   * @ko {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes}의 인스턴스\n   * @type {Axes}\n   * @see https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html\n   * @readonly\n   */\n  public get axes() { return this._axes; }\n  /**\n   * @internal\n   */\n  public get stateMachine() { return this._stateMachine; }\n  /**\n   * A activated {@link State} that shows the current status of the user input or the animation\n   * @ko 현재 활성화된 {@link State} 인스턴스로 사용자 입력 또는 애니메이션 상태를 나타냅니다\n   * @type {State}\n   */\n  public get state() { return this._stateMachine.state; }\n  /**\n   * A context of the current animation playing\n   * @ko 현재 재생중인 애니메이션 정보\n   * @type {object}\n   * @property {number} start A start position of the animation<ko>애니메이션 시작 지점</ko>\n   * @property {number} end A end position of the animation<ko>애니메이션 끝 지점</ko>\n   * @property {number} offset camera offset<ko>카메라 오프셋</ko>\n   * @readonly\n   */\n  public get animatingContext() { return this._animatingContext; }\n  /**\n   * A current control parameters of the Axes instance\n   * @ko 활성화된 현재 Axes 패러미터들\n   * @type {ControlParams}\n   */\n  public get controlParams(): ControlParams {\n    const axes = this._axes;\n\n    if (!axes) {\n      return {\n        range: { min: 0, max: 0 },\n        position: 0,\n        circular: false\n      };\n    }\n\n    const axis = axes.axis[AXES.POSITION_KEY];\n\n    return {\n      range: { min: axis.range![0], max: axis.range![1] },\n      circular: (axis.circular as boolean[])[0],\n      position: this.position\n    };\n  }\n\n  /**\n   * A Boolean indicating whether the user input is enabled\n   * @ko 현재 사용자 입력이 활성화되었는지를 나타내는 값\n   * @type {boolean}\n   * @readonly\n   */\n  public get enabled() { return this._panInput?.isEnable() ?? false; }\n  /**\n   * Current position value in {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} instance\n   * @ko {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} 인스턴스 내부의 현재 좌표 값\n   * @type {number}\n   * @readonly\n   */\n  public get position() { return this._axes?.get([AXES.POSITION_KEY])[AXES.POSITION_KEY] ?? 0; }\n  /**\n   * Current range value in {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} instance\n   * @ko {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} 인스턴스 내부의 현재 이동 범위 값\n   * @type {number[]}\n   * @readonly\n   */\n  public get range() { return this._axes?.axis[AXES.POSITION_KEY].range ?? [0, 0]; }\n  /**\n   * Actual bounce size(px)\n   * @ko 적용된 bounce 크기(px 단위)\n   * @type {number[]}\n   * @readonly\n   */\n  public get bounce() { return this._axes?.axis[AXES.POSITION_KEY].bounce as number[] | undefined; }\n\n  /** */\n  public constructor() {\n    this._resetInternalValues();\n    this._stateMachine = new StateMachine();\n  }\n\n  /**\n   * Initialize AxesController\n   * @ko AxesController를 초기화합니다\n   * @param {Flicking} flicking An instance of Flicking\n   * @chainable\n   * @return {this}\n   */\n  public init(flicking: Flicking): this {\n    this._flicking = flicking;\n\n    this._axes = new Axes({\n      [AXES.POSITION_KEY]: {\n        range: [0, 0],\n        circular: false,\n        bounce: [0, 0]\n      }\n    }, {\n      deceleration: flicking.deceleration,\n      interruptable: flicking.interruptable,\n      easing: flicking.easing\n    });\n    this._panInput = new PanInput(flicking.viewport.element, {\n      inputType: flicking.inputType,\n      iOSEdgeSwipeThreshold: flicking.iOSEdgeSwipeThreshold,\n      scale: flicking.horizontal ? [-1, 0] : [0, -1],\n      releaseOnScroll: true\n    });\n\n    const axes = this._axes;\n\n    axes.connect(flicking.horizontal ? [AXES.POSITION_KEY, \"\"] : [\"\", AXES.POSITION_KEY], this._panInput);\n\n    for (const key in AXES.EVENT) {\n      const eventType = AXES.EVENT[key] as keyof AxesEvents;\n\n      axes.on(eventType, (e: AxesEvents[typeof eventType]) => {\n        this._stateMachine.fire(eventType, {\n          flicking,\n          axesEvent: e\n        });\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Destroy AxesController and return to initial state\n   * @ko AxesController를 초기 상태로 되돌립니다\n   * @return {void}\n   */\n  public destroy(): void {\n    if (this._axes) {\n      this.removePreventClickHandler();\n      this._axes.destroy();\n    }\n\n    this._panInput?.destroy();\n\n    this._resetInternalValues();\n  }\n\n  /**\n   * Enable input from the user (mouse/touch)\n   * @ko 사용자의 입력(마우스/터치)를 활성화합니다\n   * @chainable\n   * @return {this}\n   */\n  public enable(): this {\n    this._panInput?.enable();\n\n    return this;\n  }\n\n  /**\n   * Disable input from the user (mouse/touch)\n   * @ko 사용자의 입력(마우스/터치)를 막습니다\n   * @chainable\n   * @return {this}\n   */\n  public disable(): this {\n    this._panInput?.disable();\n\n    return this;\n  }\n\n  /**\n   * Update {@link https://naver.github.io/egjs-axes/ @egjs/axes}'s state\n   * @ko {@link https://naver.github.io/egjs-axes/ @egjs/axes}의 상태를 갱신합니다\n   * @chainable\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link AxesController#init init} is not called before\n   * <ko>{@link AxesController#init init}이 이전에 호출되지 않은 경우</ko>\n   * @return {this}\n   */\n  public update(controlParams: ControlParams): this {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const camera = flicking.camera;\n    const axes = this._axes!;\n    const axis = axes.axis[AXES.POSITION_KEY];\n\n    axis.circular = [controlParams.circular, controlParams.circular];\n    axis.range = [controlParams.range.min, controlParams.range.max];\n    axis.bounce = parseBounce(flicking.bounce, camera.size);\n\n    axes.axm.set({ [AXES.POSITION_KEY]: controlParams.position });\n\n    return this;\n  }\n\n  /**\n   * Attach a handler to the camera element to prevent click events during animation\n   * @ko 카메라 엘리먼트에 애니메이션 도중에 클릭 이벤트를 방지하는 핸들러를 부착합니다\n   * @return {this}\n   */\n  public addPreventClickHandler(): this {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const axes = this._axes!;\n    const cameraEl = flicking.camera.element;\n\n    axes.on(AXES.EVENT.HOLD, this._onAxesHold);\n    axes.on(AXES.EVENT.CHANGE, this._onAxesChange);\n    cameraEl.addEventListener(\"click\", this._preventClickWhenDragged, true);\n\n    return this;\n  }\n\n  /**\n   * Detach a handler to the camera element to prevent click events during animation\n   * @ko 카메라 엘리먼트에 애니메이션 도중에 클릭 이벤트를 방지하는 핸들러를 탈착합니다\n   * @return {this}\n   */\n  public removePreventClickHandler(): this {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const axes = this._axes!;\n    const cameraEl = flicking.camera.element;\n\n    axes.off(AXES.EVENT.HOLD, this._onAxesHold);\n    axes.off(AXES.EVENT.CHANGE, this._onAxesChange);\n    cameraEl.removeEventListener(\"click\", this._preventClickWhenDragged, true);\n\n    return this;\n  }\n\n  /**\n   * Run Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#setTo setTo} using the given position\n   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#setTo setTo} 메소드를 주어진 좌표를 이용하여 수행합니다\n   * @param {number} position A position to move<ko>이동할 좌표</ko>\n   * @param {number} duration Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {number} [axesEvent] If provided, it'll use its {@link https://naver#github#io/egjs-axes/release/latest/doc/eg#Axes#html#setTo setTo} method instead<ko>이 값이 주어졌을 경우, 해당 이벤트의 {@link https://naver#github#io/egjs-axes/release/latest/doc/eg#Axes#html#setTo setTo} 메소드를 대신해서 사용합니다.</ko>\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>\n   */\n  public animateTo(position: number, duration: number, axesEvent?: OnRelease): Promise<void> {\n    const axes = this._axes;\n\n    if (!axes) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.NOT_ATTACHED_TO_FLICKING(\"Control\"), ERROR.CODE.NOT_ATTACHED_TO_FLICKING));\n    }\n\n    const startPos = axes.get([AXES.POSITION_KEY])[AXES.POSITION_KEY];\n\n    if (startPos === position) {\n      const flicking = getFlickingAttached(this._flicking, \"Control\");\n\n      flicking.camera.lookAt(position);\n      return Promise.resolve();\n    }\n\n    this._animatingContext = {\n      start: startPos,\n      end: position,\n      offset: 0\n    };\n\n    const animate = () => {\n      const resetContext = () => {\n        this._animatingContext = { start: 0, end: 0, offset: 0 };\n      };\n\n      axes.once(AXES.EVENT.FINISH, resetContext);\n\n      if (axesEvent) {\n        axesEvent.setTo({ [AXES.POSITION_KEY]: position }, duration);\n      } else {\n        axes.setTo({ [AXES.POSITION_KEY]: position }, duration);\n      }\n    };\n\n    if (duration === 0) {\n      const flicking = getFlickingAttached(this._flicking, \"Control\");\n      const camera = flicking.camera;\n\n      animate();\n\n      const newPos = flicking.circularEnabled\n        ? circulatePosition(position, camera.range.min, camera.range.max)\n        : position;\n\n      axes.axm.set({ [AXES.POSITION_KEY]: newPos });\n\n      return Promise.resolve();\n    } else {\n      return new Promise((resolve, reject) => {\n        const animationFinishHandler = () => {\n          axes.off(AXES.EVENT.HOLD, interruptionHandler);\n          resolve();\n        };\n\n        const interruptionHandler = () => {\n          axes.off(AXES.EVENT.FINISH, animationFinishHandler);\n          reject(new FlickingError(ERROR.MESSAGE.ANIMATION_INTERRUPTED, ERROR.CODE.ANIMATION_INTERRUPTED));\n        };\n\n        axes.once(AXES.EVENT.FINISH, animationFinishHandler);\n        axes.once(AXES.EVENT.HOLD, interruptionHandler);\n\n        animate();\n      });\n    }\n  }\n\n  private _resetInternalValues() {\n    this._flicking = null;\n    this._axes = null;\n    this._panInput = null;\n    this._animatingContext = { start: 0, end: 0, offset: 0 };\n    this._dragged = false;\n  }\n\n  private _onAxesHold = () => {\n    this._dragged = false;\n  };\n\n  private _onAxesChange = () => {\n    this._dragged = true;\n  };\n\n  private _preventClickWhenDragged = (e: MouseEvent) => {\n    if (this._dragged) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n\n    this._dragged = false;\n  };\n}\n\nexport default AxesController;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { OnRelease } from \"@egjs/axes\";\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport Flicking from \"../Flicking\";\nimport FlickingError from \"../core/FlickingError\";\nimport Panel from \"../core/panel/Panel\";\nimport AxesController from \"../control/AxesController\";\nimport { DIRECTION, EVENTS } from \"../const/external\";\nimport * as ERROR from \"../const/error\";\nimport { getDirection, getFlickingAttached } from \"../utils\";\nimport { ValueOf } from \"../type/internal\";\n\n/**\n * A component that manages inputs and animation of Flicking\n * @ko Flicking의 입력 장치 & 애니메이션을 담당하는 컴포넌트\n */\nabstract class Control {\n  // Internal States\n  protected _flicking: Flicking | null;\n  protected _controller: AxesController;\n  protected _activePanel: Panel | null;\n\n  /**\n   * A controller that handles the {@link https://naver.github.io/egjs-axes/ @egjs/axes} events\n   * @ko {@link https://naver.github.io/egjs-axes/ @egjs/axes}의 이벤트를 처리하는 컨트롤러 컴포넌트\n   * @type {AxesController}\n   * @readonly\n   */\n  public get controller() { return this._controller; }\n  /**\n   * Index number of the {@link Flicking#currentPanel currentPanel}\n   * @ko {@link Flicking#currentPanel currentPanel}의 인덱스 번호\n   * @type {number}\n   * @default 0\n   * @readonly\n   */\n  public get activeIndex() { return this._activePanel?.index ?? -1; }\n  /**\n   * An active panel\n   * @ko 현재 선택된 패널\n   * @type {Panel | null}\n   * @readonly\n   */\n  public get activePanel() { return this._activePanel; }\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {boolean}\n   * @readonly\n   */\n  public get animating() { return this._controller.state.animating; }\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {boolean}\n   * @readonly\n   */\n  public get holding() { return this._controller.state.holding; }\n\n  /** */\n  public constructor() {\n    this._flicking = null;\n    this._controller = new AxesController();\n    this._activePanel = null;\n  }\n\n  /**\n   * Move {@link Camera} to the given position\n   * @ko {@link Camera}를 주어진 좌표로 이동합니다\n   * @method\n   * @abstract\n   * @memberof Control\n   * @instance\n   * @name moveToPosition\n   * @param {number} position The target position to move<ko>이동할 좌표</ko>\n   * @param {number} duration Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}\n   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>\n   */\n  public abstract moveToPosition(position: number, duration: number, axesEvent?: OnRelease): Promise<void>;\n\n  /**\n   * Initialize Control\n   * @ko Control을 초기화합니다\n   * @param {Flicking} flicking An instance of {@link Flicking}<ko>Flicking의 인스턴스</ko>\n   * @chainable\n   * @return {this}\n   */\n  public init(flicking: Flicking): this {\n    this._flicking = flicking;\n    this._controller.init(flicking);\n\n    return this;\n  }\n\n  /**\n   * Destroy Control and return to initial state\n   * @ko Control을 초기 상태로 되돌립니다\n   * @return {void}\n   */\n  public destroy(): void {\n    this._controller.destroy();\n\n    this._flicking = null;\n    this._activePanel = null;\n  }\n\n  /**\n   * Enable input from the user (mouse/touch)\n   * @ko 사용자의 입력(마우스/터치)를 활성화합니다\n   * @chainable\n   * @return {this}\n   */\n  public enable(): this {\n    this._controller.enable();\n\n    return this;\n  }\n\n  /**\n   * Disable input from the user (mouse/touch)\n   * @ko 사용자의 입력(마우스/터치)를 막습니다\n   * @chainable\n   * @return {this}\n   */\n  public disable(): this {\n    this._controller.disable();\n\n    return this;\n  }\n\n  /**\n   * Update position after resizing\n   * @ko resize 이후에 position을 업데이트합니다\n   * @param {number} progressInPanel Previous camera's progress in active panel before resize<ko>Resize 이전 현재 선택된 패널 내에서의 카메라 progress 값</ko>\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @chainable\n   * @return {Promise<void>}\n   */\n  public updatePosition(_progressInPanel: number): void { // eslint-disable-line @typescript-eslint/no-unused-vars\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const camera = flicking.camera;\n    const activePanel = this._activePanel;\n\n    if (activePanel) {\n      camera.lookAt(camera.clampToReachablePosition(activePanel.position));\n    }\n  }\n\n  /**\n   * Update {@link Control#controller controller}'s state\n   * @ko {@link Control#controller controller}의 내부 상태를 갱신합니다\n   * @chainable\n   * @return {this}\n   */\n  public updateInput(): this {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const camera = flicking.camera;\n\n    this._controller.update(camera.controlParams);\n\n    return this;\n  }\n\n  /**\n   * Reset {@link Control#activePanel activePanel} to `null`\n   * @ko {@link Control#activePanel activePanel}을 `null`로 초기화합니다\n   * @chainable\n   * @return {this}\n   */\n  public resetActive(): this {\n    this._activePanel = null;\n\n    return this;\n  }\n\n  /**\n   * Move {@link Camera} to the given panel\n   * @ko {@link Camera}를 해당 패널 위로 이동합니다\n   * @param {Panel} panel The target panel to move<ko>이동할 패널</ko>\n   * @param {object} options An options object<ko>옵션 오브젝트</ko>\n   * @param {number} duration Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}\n   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>\n   * @param {DIRECTION} [direction=DIRECTION.NONE] Direction to move, only available in the {@link Flicking#circular circular} mode<ko>이동할 방향. {@link Flicking#circular circular} 옵션 활성화시에만 사용 가능합니다</ko>\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target panel<ko>해당 패널 도달시에 resolve되는 Promise</ko>\n   */\n  public async moveToPanel(panel: Panel, {\n    duration,\n    direction = DIRECTION.NONE,\n    axesEvent\n  }: {\n    duration: number;\n    direction?: ValueOf<typeof DIRECTION>;\n    axesEvent?: OnRelease;\n  }) {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const camera = flicking.camera;\n\n    let position = panel.position;\n    const nearestAnchor = camera.findNearestAnchor(position);\n\n    if (panel.removed || !nearestAnchor) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.POSITION_NOT_REACHABLE(panel.position), ERROR.CODE.POSITION_NOT_REACHABLE));\n    }\n    if (!camera.canReach(panel)) {\n      // Override position & panel if that panel is not reachable\n      position = nearestAnchor.position;\n      panel = nearestAnchor.panel;\n    } else if (flicking.circularEnabled) {\n      // Circular mode is enabled, find nearest distance to panel\n      const camPos = this._controller.position; // Actual position of the Axes\n      const camRangeDiff = camera.rangeDiff;\n      const possiblePositions = [position, position + camRangeDiff, position - camRangeDiff]\n        .filter(pos => {\n          if (direction === DIRECTION.NONE) return true;\n\n          return direction === DIRECTION.PREV\n            ? pos <= camPos\n            : pos >= camPos;\n        });\n\n      position = possiblePositions.reduce((nearestPosition, pos) => {\n        if (Math.abs(camPos - pos) < Math.abs(camPos - nearestPosition)) {\n          return pos;\n        } else {\n          return nearestPosition;\n        }\n      }, Infinity);\n    }\n\n    this._triggerIndexChangeEvent(panel, panel.position, axesEvent);\n\n    return this._animateToPosition({ position, duration, newActivePanel: panel, axesEvent });\n  }\n\n  /**\n   * @internal\n   */\n  public setActive(newActivePanel: Panel, prevActivePanel: Panel | null, isTrusted: boolean) {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n\n    this._activePanel = newActivePanel;\n\n    flicking.camera.updateAdaptiveHeight();\n\n    if (newActivePanel !== prevActivePanel) {\n      flicking.trigger(new ComponentEvent(EVENTS.CHANGED, {\n        index: newActivePanel.index,\n        panel: newActivePanel,\n        prevIndex: prevActivePanel?.index ?? -1,\n        prevPanel: prevActivePanel,\n        isTrusted,\n        direction: prevActivePanel ? getDirection(prevActivePanel.position, newActivePanel.position) : DIRECTION.NONE\n      }));\n    } else {\n      flicking.trigger(new ComponentEvent(EVENTS.RESTORED, {\n        isTrusted\n      }));\n    }\n  }\n\n  protected _triggerIndexChangeEvent(panel: Panel, position: number, axesEvent?: OnRelease): void {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const triggeringEvent = panel !== this._activePanel ? EVENTS.WILL_CHANGE : EVENTS.WILL_RESTORE;\n    const camera = flicking.camera;\n    const activePanel = this._activePanel;\n\n    const event = new ComponentEvent(triggeringEvent, {\n      index: panel.index,\n      panel,\n      isTrusted: axesEvent?.isTrusted || false,\n      direction: getDirection(activePanel?.position ?? camera.position, position)\n    });\n    flicking.trigger(event);\n\n    if (event.isCanceled()) {\n      throw new FlickingError(ERROR.MESSAGE.STOP_CALLED_BY_USER, ERROR.CODE.STOP_CALLED_BY_USER);\n    }\n  }\n\n  protected async _animateToPosition({\n    position,\n    duration,\n    newActivePanel,\n    axesEvent\n  }: {\n    position: number;\n    duration: number;\n    newActivePanel: Panel;\n    axesEvent?: OnRelease;\n  }) {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const animate = () => this._controller.animateTo(position, duration, axesEvent);\n    const state = this._controller.state;\n\n    state.targetPanel = newActivePanel;\n\n    if (duration <= 0) {\n      return animate();\n    } else {\n      return animate().then(async () => {\n        await flicking.renderer.render();\n      }).catch(err => {\n        if (axesEvent && err instanceof FlickingError && err.code === ERROR.CODE.ANIMATION_INTERRUPTED) return;\n        throw err;\n      });\n    }\n  }\n}\n\nexport default Control;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Panel from \"./panel/Panel\";\n\n/**\n * A data component that has actual position where the camera should be stopped at\n * @ko 카메라가 정지해야하는 실제 위치를 담고 있는 데이터 컴포넌트\n */\nclass AnchorPoint {\n  private _index: number;\n  private _pos: number;\n  private _panel: Panel;\n\n  /**\n   * Index of AnchorPoint\n   * @ko AnchorPoint의 인덱스\n   * @type {number}\n   * @readonly\n   */\n  public get index() { return this._index; }\n  /**\n   * Position of AnchorPoint\n   * @ko AnchorPoint의 좌표\n   * @type {number}\n   * @readonly\n   */\n  public get position() { return this._pos; }\n  /**\n   * A {@link Panel} instance AnchorPoint is referencing to\n   * @ko AnchorPoint가 참조하고 있는 {@link Panel}\n   * @type {Panel}\n   * @readonly\n   */\n  public get panel() { return this._panel; }\n\n  /**\n   * @param {object} options An options object<ko>옵션 객체</ko>\n   * @param {number} [options.index] Index of AnchorPoint<ko>AnchorPoint의 인덱스</ko>\n   * @param {number} [options.position] Position of AnchorPoint<ko>AnchorPoint의 좌표</ko>\n   * @param {Panel} [options.panel] A {@link Panel} instance AnchorPoint is referencing to<ko>AnchorPoint가 참조하고 있는 {@link Panel}</ko>\n   */\n  public constructor({\n    index,\n    position,\n    panel\n  }: {\n    index: number;\n    position: number;\n    panel: Panel;\n  }) {\n    this._index = index;\n    this._pos = position;\n    this._panel = panel;\n  }\n}\n\nexport default AnchorPoint;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { OnRelease } from \"@egjs/axes\";\n\nimport FlickingError from \"../core/FlickingError\";\nimport AnchorPoint from \"../core/AnchorPoint\";\nimport { circulateIndex, clamp, getFlickingAttached } from \"../utils\";\nimport * as AXES from \"../const/axes\";\nimport * as ERROR from \"../const/error\";\n\nimport Control from \"./Control\";\n\n/**\n * An options for the {@link SnapControl}\n * @ko {@link SnapControl} 생성시 사용되는 옵션\n * @interface\n * @property {number} count Maximum number of panels can go after release<ko>입력 중단 이후 통과하여 이동할 수 있는 패널의 최대 갯수</ko>\n */\nexport interface SnapControlOptions {\n  count: number;\n}\n\n/**\n * A {@link Control} that uses a release momentum to choose destination panel\n * @ko 입력을 중단한 시점의 가속도에 영향받아 도달할 패널을 계산하는 이동 방식을 사용하는 {@link Control}\n */\nclass SnapControl extends Control {\n  private _count: SnapControlOptions[\"count\"];\n\n  /**\n   * Maximum number of panels can go after release\n   * @ko 입력 중단 이후 통과하여 이동할 수 있는 패널의 최대 갯수\n   * @type {number}\n   * @default Infinity\n   */\n  public get count() { return this._count; }\n\n  public set count(val: SnapControlOptions[\"count\"]) { this._count = val; }\n\n  /** */\n  public constructor({\n    count = Infinity\n  }: Partial<SnapControlOptions> = {}) {\n    super();\n\n    this._count = count;\n  }\n\n  /**\n   * Move {@link Camera} to the given position\n   * @ko {@link Camera}를 주어진 좌표로 이동합니다\n   * @param {number} position The target position to move<ko>이동할 좌표</ko>\n   * @param {number} duration Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}\n   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>\n   */\n  public async moveToPosition(position: number, duration: number, axesEvent?: OnRelease) {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const camera = flicking.camera;\n    const activeAnchor = camera.findActiveAnchor();\n    const anchorAtCamera = camera.findNearestAnchor(camera.position);\n    const state = flicking.control.controller.state;\n\n    if (!activeAnchor || !anchorAtCamera) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.POSITION_NOT_REACHABLE(position), ERROR.CODE.POSITION_NOT_REACHABLE));\n    }\n\n    const snapThreshold = this._calcSnapThreshold(position, activeAnchor);\n\n    const posDelta = flicking.animating\n      ? state.delta\n      : position - camera.position;\n    const absPosDelta = Math.abs(posDelta);\n    const snapDelta = axesEvent && axesEvent.delta[AXES.POSITION_KEY] !== 0\n      ? Math.abs(axesEvent.delta[AXES.POSITION_KEY])\n      : absPosDelta;\n    let targetAnchor: AnchorPoint;\n\n    if (snapDelta >= snapThreshold && snapDelta > 0) {\n      // Move to anchor at position\n      targetAnchor = this._findSnappedAnchor(position, anchorAtCamera);\n    } else if (absPosDelta >= flicking.threshold && absPosDelta > 0) {\n      // Move to the adjacent panel\n      targetAnchor = this._findAdjacentAnchor(posDelta, anchorAtCamera);\n    } else {\n      // Restore to active panel\n      targetAnchor = anchorAtCamera;\n    }\n\n    this._triggerIndexChangeEvent(targetAnchor.panel, position, axesEvent);\n\n    return this._animateToPosition({\n      position: camera.clampToReachablePosition(targetAnchor.position),\n      duration,\n      newActivePanel: targetAnchor.panel,\n      axesEvent\n    });\n  }\n\n  private _findSnappedAnchor(position: number, anchorAtCamera: AnchorPoint): AnchorPoint {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const camera = flicking.camera;\n    const count = this._count;\n\n    const currentPos = camera.position;\n\n    const clampedPosition = camera.clampToReachablePosition(position);\n    const anchorAtPosition = camera.findAnchorIncludePosition(clampedPosition);\n\n    if (!anchorAtCamera || !anchorAtPosition) {\n      throw new FlickingError(ERROR.MESSAGE.POSITION_NOT_REACHABLE(position), ERROR.CODE.POSITION_NOT_REACHABLE);\n    }\n\n    if (!isFinite(count)) {\n      return anchorAtPosition;\n    }\n\n    const panelCount = flicking.panelCount;\n    const anchors = camera.anchorPoints;\n\n    let loopCount = Math.sign(position - currentPos) * Math.floor(Math.abs(position - currentPos) / camera.rangeDiff);\n    if ((position > currentPos && anchorAtPosition.index < anchorAtCamera.index)\n      || (anchorAtPosition.position > anchorAtCamera.position && anchorAtPosition.index === anchorAtCamera.index)) {\n      loopCount += 1;\n    } else if ((position < currentPos && anchorAtPosition.index > anchorAtCamera.index)\n      || (anchorAtPosition.position < anchorAtCamera.position && anchorAtPosition.index === anchorAtCamera.index)) {\n      loopCount -= 1;\n    }\n\n    const circularIndexOffset = loopCount * panelCount;\n    const anchorAtPositionIndex = anchorAtPosition.index + circularIndexOffset;\n\n    if (Math.abs(anchorAtPositionIndex - anchorAtCamera.index) <= count) {\n      const anchor = anchors[anchorAtPosition.index];\n\n      return new AnchorPoint({\n        index: anchor.index,\n        position: anchor.position + loopCount * camera.rangeDiff,\n        panel: anchor.panel\n      });\n    }\n\n    if (flicking.circularEnabled) {\n      const targetAnchor = anchors[circulateIndex(anchorAtCamera.index + Math.sign(position - currentPos) * count, panelCount)];\n      let loop = Math.floor(count / panelCount);\n\n      if (position > currentPos && targetAnchor.index < anchorAtCamera.index) {\n        loop += 1;\n      } else if (position < currentPos && targetAnchor.index > anchorAtCamera.index) {\n        loop -= 1;\n      }\n\n      return new AnchorPoint({\n        index: targetAnchor.index,\n        position: targetAnchor.position + loop * camera.rangeDiff,\n        panel: targetAnchor.panel\n      });\n    } else {\n      return anchors[clamp(anchorAtCamera.index + Math.sign(position - currentPos) * count, 0, anchors.length - 1)];\n    }\n  }\n\n  private _findAdjacentAnchor(posDelta: number, anchorAtCamera: AnchorPoint): AnchorPoint {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const camera = flicking.camera;\n    const adjacentAnchor = (posDelta > 0 ? camera.getNextAnchor(anchorAtCamera) : camera.getPrevAnchor(anchorAtCamera)) ?? anchorAtCamera;\n\n    return adjacentAnchor;\n  }\n\n  private _calcSnapThreshold(position: number, activeAnchor: AnchorPoint): number {\n    const isNextDirection = position > activeAnchor.position;\n    const panel = activeAnchor.panel;\n    const panelSize = panel.size;\n    const alignPos = panel.alignPosition;\n\n    // Minimum distance needed to decide prev/next panel as nearest\n    /*\n     * |  Prev  |     Next     |\n     * |<------>|<------------>|\n     * [        |<-Anchor      ]\n     */\n    return isNextDirection\n      ? panelSize - alignPos + panel.margin.next\n      : alignPos + panel.margin.prev;\n  }\n}\n\nexport default SnapControl;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { OnRelease } from \"@egjs/axes\";\n\nimport FlickingError from \"../core/FlickingError\";\nimport * as ERROR from \"../const/error\";\nimport { getFlickingAttached } from \"../utils\";\n\nimport Control from \"./Control\";\n\n/**\n * An options for the {@link FreeControl}\n * @ko {@link FreeControl} 생성시 사용되는 옵션\n * @interface\n * @property {boolean} stopAtEdge Make scroll animation to stop at the start/end of the scroll area, not going out the bounce area\n * <ko>스크롤 애니메이션을 스크롤 영역의 시작과 끝부분에서 멈추도록 하여, 바운스 영역을 넘어가지 않도록 합니다</ko>\n */\nexport interface FreeControlOptions {\n  stopAtEdge: boolean;\n}\n\n/**\n * A {@link Control} that can be scrolled freely without alignment\n * @ko 패널이 정해진 지점에 정렬되지 않고, 자유롭게 스크롤할 수 있는 이동 방식을 사용하는 {@link Control}\n */\nclass FreeControl extends Control {\n  private _stopAtEdge: FreeControlOptions[\"stopAtEdge\"];\n\n  /**\n   * Make scroll animation to stop at the start/end of the scroll area, not going out the bounce area\n   * @ko 스크롤 애니메이션을 스크롤 영역의 시작과 끝부분에서 멈추도록 하여, 바운스 영역을 넘어가지 않도록 합니다\n   * @type {boolean}\n   * @default true\n   */\n  public get stopAtEdge() { return this._stopAtEdge; }\n\n  public set stopAtEdge(val: FreeControlOptions[\"stopAtEdge\"]) { this._stopAtEdge = val; }\n\n  /** */\n  public constructor({\n    stopAtEdge = true\n  }: Partial<FreeControlOptions> = {}) {\n    super();\n\n    this._stopAtEdge = stopAtEdge;\n  }\n\n  /**\n   * Update position after resizing\n   * @ko resize 이후에 position을 업데이트합니다\n   * @param {number} progressInPanel Previous camera's progress in active panel before resize<ko>Resize 이전 현재 선택된 패널 내에서의 카메라 progress 값</ko>\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @chainable\n   * @return {Promise<void>}\n   */\n  public updatePosition(progressInPanel: number): void {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const camera = flicking.camera;\n    const activePanel = this._activePanel;\n\n    if (activePanel) {\n      const panelRange = activePanel.range;\n      const newPosition = panelRange.min + (panelRange.max - panelRange.min) * progressInPanel;\n\n      camera.lookAt(camera.clampToReachablePosition(newPosition));\n    }\n  }\n\n  /**\n   * Move {@link Camera} to the given position\n   * @ko {@link Camera}를 주어진 좌표로 이동합니다\n   * @param {number} position The target position to move<ko>이동할 좌표</ko>\n   * @param {number} duration Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}\n   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>\n   */\n  public async moveToPosition(position: number, duration: number, axesEvent?: OnRelease) {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n\n    const camera = flicking.camera;\n    const targetPos = camera.clampToReachablePosition(position);\n\n    const anchorAtPosition = camera.findAnchorIncludePosition(targetPos);\n\n    if (!anchorAtPosition) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.POSITION_NOT_REACHABLE(position), ERROR.CODE.POSITION_NOT_REACHABLE));\n    }\n\n    const targetPanel = anchorAtPosition.panel;\n\n    // Trigger only change event\n    if (targetPanel !== this._activePanel) {\n      this._triggerIndexChangeEvent(targetPanel, position, axesEvent);\n    }\n\n    return this._animateToPosition({ position: this._stopAtEdge ? targetPos : position, duration, newActivePanel: targetPanel, axesEvent });\n  }\n}\n\nexport default FreeControl;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { OnRelease } from \"@egjs/axes\";\n\nimport Panel from \"../core/panel/Panel\";\nimport FlickingError from \"../core/FlickingError\";\nimport { clamp, getFlickingAttached, getMinusCompensatedIndex, isBetween } from \"../utils\";\nimport * as ERROR from \"../const/error\";\n\nimport Control from \"./Control\";\n/**\n * An options for the {@link StrictControl}\n * @ko {@link StrictControl} 생성시 사용되는 옵션\n * @interface\n * @property {number} count Maximum number of panels that can be moved at a time<ko>최대로 움직일 수 있는 패널의 개수</ko>\n */\nexport interface StrictControlOptions {\n  count: number;\n}\n\n/**\n * A {@link Control} that allow you to select the maximum number of panels to move at a time\n * @ko 한번에 최대로 이동할 패널의 개수를 선택 가능한 {@link Control}\n */\nclass StrictControl extends Control {\n  private _count: number;\n  private _indexRange: { min: number; max: number };\n\n  /**\n   * Maximum number of panels that can be moved at a time\n   * @ko 최대로 움직일 수 있는 패널의 개수\n   * @type {number}\n   * @default 1\n   */\n  public get count() { return this._count; }\n\n  public set count(val: StrictControlOptions[\"count\"]) { this._count = val; }\n\n  /** */\n  public constructor({\n    count = 1\n  }: Partial<StrictControlOptions> = {}) {\n    super();\n\n    this._count = count;\n    this._resetIndexRange();\n  }\n\n  /**\n   * Destroy Control and return to initial state\n   * @ko Control을 초기 상태로 되돌립니다\n   * @return {void}\n   */\n  public destroy() {\n    super.destroy();\n\n    this._resetIndexRange();\n  }\n\n  /**\n   * Update {@link Control#controller controller}'s state\n   * @ko {@link Control#controller controller}의 내부 상태를 갱신합니다\n   * @chainable\n   * @return {this}\n   */\n  public updateInput(): this {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const camera = flicking.camera;\n    const renderer = flicking.renderer;\n    const controller = this._controller;\n    const controlParams = camera.controlParams;\n    const count = this._count;\n\n    const activePanel = controller.state.animating\n      ? camera.findNearestAnchor(camera.position)?.panel\n      : this._activePanel;\n\n    if (!activePanel) {\n      controller.update(controlParams);\n      this._resetIndexRange();\n      return this;\n    }\n\n    const cameraRange = controlParams.range;\n    const currentPos = activePanel.position;\n    const currentIndex = activePanel.index;\n    const panelCount = renderer.panelCount;\n\n    let prevPanelIndex = currentIndex - count;\n    let nextPanelIndex = currentIndex + count;\n\n    if (prevPanelIndex < 0) {\n      prevPanelIndex = flicking.circularEnabled\n        ? getMinusCompensatedIndex((prevPanelIndex + 1) % panelCount - 1, panelCount)\n        : clamp(prevPanelIndex, 0, panelCount - 1);\n    }\n    if (nextPanelIndex >= panelCount) {\n      nextPanelIndex = flicking.circularEnabled\n        ? nextPanelIndex % panelCount\n        : clamp(nextPanelIndex, 0, panelCount - 1);\n    }\n\n    const prevPanel = renderer.panels[prevPanelIndex];\n    const nextPanel = renderer.panels[nextPanelIndex];\n\n    let prevPos = Math.max(prevPanel.position, cameraRange.min);\n    let nextPos = Math.min(nextPanel.position, cameraRange.max);\n\n    if (prevPos > currentPos) {\n      prevPos -= camera.rangeDiff;\n    }\n    if (nextPos < currentPos) {\n      nextPos += camera.rangeDiff;\n    }\n\n    controlParams.range = {\n      min: prevPos,\n      max: nextPos\n    };\n\n    if (controlParams.circular) {\n      if (controlParams.position < prevPos) {\n        controlParams.position += camera.rangeDiff;\n      }\n\n      if (controlParams.position > nextPos) {\n        controlParams.position -= camera.rangeDiff;\n      }\n    }\n\n    controlParams.circular = false;\n    controller.update(controlParams);\n\n    this._indexRange = {\n      min: prevPanel.index,\n      max: nextPanel.index\n    };\n\n    return this;\n  }\n\n  /**\n   * Move {@link Camera} to the given position\n   * @ko {@link Camera}를 주어진 좌표로 이동합니다\n   * @param {number} position The target position to move<ko>이동할 좌표</ko>\n   * @param {number} duration Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}\n   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>\n   */\n  public async moveToPosition(position: number, duration: number, axesEvent?: OnRelease) {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const camera = flicking.camera;\n    const activePanel = this._activePanel;\n    const axesRange = this._controller.range;\n    const indexRange = this._indexRange;\n    const cameraRange = camera.range;\n\n    const clampedPosition = clamp(camera.clampToReachablePosition(position), axesRange[0], axesRange[1]);\n    const anchorAtPosition = camera.findAnchorIncludePosition(clampedPosition);\n\n    if (!anchorAtPosition || !activePanel) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.POSITION_NOT_REACHABLE(position), ERROR.CODE.POSITION_NOT_REACHABLE));\n    }\n\n    const prevPos = activePanel.position;\n\n    const isOverThreshold = Math.abs(position - prevPos) >= flicking.threshold;\n    const adjacentAnchor = (position > prevPos)\n      ? camera.getNextAnchor(anchorAtPosition)\n      : camera.getPrevAnchor(anchorAtPosition);\n\n    let targetPos: number;\n    let targetPanel: Panel;\n\n    const anchors = camera.anchorPoints;\n    const firstAnchor = anchors[0];\n    const lastAnchor = anchors[anchors.length - 1];\n\n    const shouldBounceToFirst = position <= cameraRange.min && isBetween(firstAnchor.panel.index, indexRange.min, indexRange.max);\n    const shouldBounceToLast = position >= cameraRange.max && isBetween(lastAnchor.panel.index, indexRange.min, indexRange.max);\n\n    if (shouldBounceToFirst || shouldBounceToLast) {\n      // In bounce area\n      const targetAnchor = position < cameraRange.min ? firstAnchor : lastAnchor;\n\n      targetPanel = targetAnchor.panel;\n      targetPos = targetAnchor.position;\n    } else if (isOverThreshold && anchorAtPosition.position !== activePanel.position) {\n      // Move to anchor at position\n      targetPanel = anchorAtPosition.panel;\n      targetPos = anchorAtPosition.position;\n    } else if (isOverThreshold && adjacentAnchor && isBetween(adjacentAnchor.index, indexRange.min, indexRange.max)) {\n      // Move to adjacent anchor\n      targetPanel = adjacentAnchor.panel;\n      targetPos = adjacentAnchor.position;\n    } else {\n      // Restore to active panel\n      targetPos = camera.clampToReachablePosition(activePanel.position);\n      targetPanel = activePanel;\n    }\n\n    this._triggerIndexChangeEvent(targetPanel, position, axesEvent);\n\n    return this._animateToPosition({\n      position: targetPos,\n      duration,\n      newActivePanel: targetPanel,\n      axesEvent\n    });\n  }\n\n  public setActive = (newActivePanel: Panel, prevActivePanel: Panel | null, isTrusted: boolean) => {\n    super.setActive(newActivePanel, prevActivePanel, isTrusted);\n    this.updateInput();\n  };\n\n  private _resetIndexRange() {\n    this._indexRange = { min: 0, max: 0 };\n  }\n}\n\nexport default StrictControl;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport Flicking, { FlickingOptions } from \"../Flicking\";\nimport FlickingError from \"../core/FlickingError\";\nimport Panel from \"../core/panel/Panel\";\nimport AnchorPoint from \"../core/AnchorPoint\";\nimport * as ERROR from \"../const/error\";\nimport { ALIGN, DIRECTION, EVENTS } from \"../const/external\";\nimport { checkExistence, clamp, find, getFlickingAttached, getProgress, includes, parseAlign } from \"../utils\";\n\nexport interface CameraOptions {\n  align: FlickingOptions[\"align\"];\n}\n\n/**\n * A component that manages actual movement inside the viewport\n * @ko 뷰포트 내에서의 실제 움직임을 담당하는 컴포넌트\n */\nabstract class Camera {\n  // Options\n  protected _align: FlickingOptions[\"align\"];\n\n  // Internal states\n  protected _flicking: Flicking | null;\n  protected _el: HTMLElement;\n  protected _transform: string;\n  protected _position: number;\n  protected _alignPos: number;\n  protected _offset: number;\n  protected _range: { min: number; max: number };\n  protected _visiblePanels: Panel[];\n  protected _anchors: AnchorPoint[];\n  protected _needPanelTriggered: { prev: boolean; next: boolean };\n\n  // Internal states getter\n  /**\n   * The camera(`.flicking-camera`) element\n   * @ko 카메라(`.flicking-camera`) 엘리먼트\n   * @type {HTMLElement}\n   * @readonly\n   */\n  public get element() { return this._el; }\n  /**\n   * Current position of the camera\n   * @ko Camera의 현재 좌표\n   * @type {number}\n   * @readonly\n   */\n  public get position() { return this._position; }\n  /**\n   * Align position inside the viewport where {@link Panel}'s {@link Panel#alignPosition alignPosition} should be located at\n   * @ko 패널의 정렬 기준 위치. 뷰포트 내에서 {@link Panel}의 {@link Panel#alignPosition alignPosition}이 위치해야 하는 곳입니다\n   * @type {number}\n   * @readonly\n   */\n  public get alignPosition() { return this._alignPos; }\n  /**\n   * Position offset, used for the {@link Flicking#renderOnlyVisible renderOnlyVisible} option\n   * @ko Camera의 좌표 오프셋. {@link Flicking#renderOnlyVisible renderOnlyVisible} 옵션을 위해 사용됩니다.\n   * @type {number}\n   * @default 0\n   * @readonly\n   */\n  public get offset() { return this._offset; }\n  /**\n   * A range that Camera's {@link Camera#position position} can reach\n   * @ko Camera의 {@link Camera#position position}이 도달 가능한 범위\n   * @type {object}\n   * @property {number} min A minimum position<ko>최소 위치</ko>\n   * @property {number} min A maximum position<ko>최대 위치</ko>\n   * @readonly\n   */\n  public get range() { return this._range; }\n  /**\n   * A difference between Camera's minimum and maximum position that can reach\n   * @ko Camera가 도달 가능한 최소/최대 좌표의 차이\n   * @type {number}\n   * @readonly\n   */\n  public get rangeDiff() { return this._range.max - this._range.min; }\n  /**\n   * An array of visible panels from the current position\n   * @ko 현재 보이는 패널들의 배열\n   * @type {Panel[]}\n   * @readonly\n   */\n  public get visiblePanels() { return this._visiblePanels; }\n  /**\n   * A range of the visible area from the current position\n   * @ko 현재 위치에서 보이는 범위\n   * @type {object}\n   * @property {number} min A minimum position<ko>최소 위치</ko>\n   * @property {number} min A maximum position<ko>최대 위치</ko>\n   * @readonly\n   */\n  public get visibleRange() { return { min: this._position - this._alignPos, max: this._position - this._alignPos + this.size }; }\n  /**\n   * An array of {@link AnchorPoint}s that Camera can be stopped at\n   * @ko 카메라가 도달 가능한 {@link AnchorPoint}의 목록\n   * @type {AnchorPoint[]}\n   * @readonly\n   */\n  public get anchorPoints() { return this._anchors; }\n  /**\n   * A current parameters of the Camera for updating {@link AxesController}\n   * @ko {@link AxesController}를 업데이트하기 위한 현재 Camera 패러미터들\n   * @type {ControlParams}\n   * @readonly\n   */\n  public get controlParams() { return { range: this._range, position: this._position, circular: false }; }\n  /**\n   * A Boolean value indicating whether Camera's over the minimum or maximum position reachable\n   * @ko 현재 카메라가 도달 가능한 범위의 최소 혹은 최대점을 넘어섰는지를 나타냅니다\n   * @type {boolean}\n   * @readonly\n   */\n  public get atEdge() { return this._position <= this._range.min || this._position >= this._range.max; }\n  /**\n   * Return the size of the viewport\n   * @ko 뷰포트 크기를 반환합니다\n   * @type {number}\n   * @readonly\n   */\n  public get size() {\n    const flicking = this._flicking;\n    return flicking\n      ? flicking.horizontal\n        ? flicking.viewport.width\n        : flicking.viewport.height\n      : 0;\n  }\n\n  /**\n   * Return the camera's position progress from the first panel to last panel\n   * Range is from 0 to last panel's index\n   * @ko 첫번째 패널로부터 마지막 패널까지의 카메라 위치의 진행도를 반환합니다\n   * 범위는 0부터 마지막 패널의 인덱스까지입니다\n   * @type {number}\n   * @readonly\n   */\n  public get progress() {\n    const flicking = this._flicking;\n    const position = this._position + this._offset;\n    const nearestAnchor = this.findNearestAnchor(this._position);\n\n    if (!flicking || !nearestAnchor) {\n      return NaN;\n    }\n\n    const nearestPanel = nearestAnchor.panel;\n    const panelPos = nearestPanel.position + nearestPanel.offset;\n    const bounceSize = flicking.control.controller.bounce!;\n\n    const { min: prevRange, max: nextRange } = this.range;\n    const rangeDiff = this.rangeDiff;\n\n    if (position === panelPos) {\n      return nearestPanel.index;\n    }\n\n    if (position < panelPos) {\n      const prevPanel = nearestPanel.prev();\n      let prevPosition = prevPanel\n        ? prevPanel.position + prevPanel.offset\n        : prevRange - bounceSize[0];\n\n      // Looped\n      if (prevPosition > panelPos) {\n        prevPosition -= rangeDiff;\n      }\n\n      return nearestPanel.index - 1 + getProgress(position, prevPosition, panelPos);\n    } else {\n      const nextPanel = nearestPanel.next();\n      let nextPosition = nextPanel\n        ? nextPanel.position + nextPanel.offset\n        : nextRange + bounceSize[1];\n\n      // Looped\n      if (nextPosition < panelPos) {\n        nextPosition += rangeDiff;\n      }\n\n      return nearestPanel.index + getProgress(position, panelPos, nextPosition);\n    }\n  }\n\n  // Options Getter\n  /**\n   * A value indicating where the {@link Camera#alignPosition alignPosition} should be located at inside the viewport element\n   * @ko {@link Camera#alignPosition alignPosition}이 뷰포트 엘리먼트 내의 어디에 위치해야 하는지를 나타내는 값\n   * @type {ALIGN | string | number}\n   */\n  public get align() { return this._align; }\n\n  // Options Setter\n  public set align(val: FlickingOptions[\"align\"]) {\n    this._align = val;\n  }\n\n  /** */\n  public constructor({\n    align = ALIGN.CENTER\n  }: Partial<CameraOptions> = {}) {\n    this._flicking = null;\n    this._resetInternalValues();\n\n    // Options\n    this._align = align;\n  }\n\n  /**\n   * Update {@link Camera#range range} of Camera\n   * @ko Camera의 {@link Camera#range range}를 업데이트합니다\n   * @method\n   * @abstract\n   * @memberof Camera\n   * @instance\n   * @name updateRange\n   * @chainable\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @return {this}\n   */\n  public abstract updateRange(): this;\n\n  /**\n   * Initialize Camera\n   * @ko Camera를 초기화합니다\n   * @param {Flicking} flicking An instance of {@link Flicking}<ko>Flicking의 인스턴스</ko>\n   * @chainable\n   * @throws {FlickingError}\n   * {@link ERROR_CODE VAL_MUST_NOT_NULL} If the camera element(`.flicking-camera`) does not exist inside viewport element\n   * <ko>{@link ERROR_CODE VAL_MUST_NOT_NULL} 뷰포트 엘리먼트 내부에 카메라 엘리먼트(`.flicking-camera`)가 존재하지 않을 경우</ko>\n   * @return {this}\n   */\n  public init(flicking: Flicking): this {\n    this._flicking = flicking;\n\n    const viewportEl = flicking.viewport.element;\n\n    checkExistence(viewportEl.firstElementChild, \"First element child of the viewport element\");\n    this._el = viewportEl.firstElementChild as HTMLElement;\n    this._checkTranslateSupport();\n\n    return this;\n  }\n\n  /**\n   * Destroy Camera and return to initial state\n   * @ko Camera를 초기 상태로 되돌립니다\n   * @return {void}\n   */\n  public destroy(): this {\n    this._flicking = null;\n    this._resetInternalValues();\n    return this;\n  }\n\n  /**\n   * Move to the given position and apply CSS transform\n   * @ko 해당 좌표로 이동하고, CSS transform을 적용합니다\n   * @param {number} pos A new position<ko>움직일 위치</ko>\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @return {this}\n   */\n  public lookAt(pos: number): void {\n    const prevPos = this._position;\n\n    this._position = pos;\n    this._refreshVisiblePanels();\n    this._checkNeedPanel();\n    this._checkReachEnd(prevPos, pos);\n    this._applyTransform();\n  }\n\n  /**\n   * Return a previous {@link AnchorPoint} of given {@link AnchorPoint}\n   * If it does not exist, return `null` instead\n   * @ko 주어진 {@link AnchorPoint}의 이전 {@link AnchorPoint}를 반환합니다\n   * 존재하지 않을 경우 `null`을 반환합니다\n   * @param {AnchorPoint} anchor A reference {@link AnchorPoint}<ko>기준 {@link AnchorPoint}</ko>\n   * @return {AnchorPoint | null} The previous {@link AnchorPoint}<ko>이전 {@link AnchorPoint}</ko>\n   */\n  public getPrevAnchor(anchor: AnchorPoint): AnchorPoint | null {\n    return this._anchors[anchor.index - 1] || null;\n  }\n\n  /**\n   * Return a next {@link AnchorPoint} of given {@link AnchorPoint}\n   * If it does not exist, return `null` instead\n   * @ko 주어진 {@link AnchorPoint}의 다음 {@link AnchorPoint}를 반환합니다\n   * 존재하지 않을 경우 `null`을 반환합니다\n   * @param {AnchorPoint} anchor A reference {@link AnchorPoint}<ko>기준 {@link AnchorPoint}</ko>\n   * @return {AnchorPoint | null} The next {@link AnchorPoint}<ko>다음 {@link AnchorPoint}</ko>\n   */\n  public getNextAnchor(anchor: AnchorPoint): AnchorPoint | null {\n    return this._anchors[anchor.index + 1] || null;\n  }\n\n  /**\n   * Return the camera's position progress in the panel below\n   * Value is from 0 to 1 when the camera's inside panel\n   * Value can be lower than 0 or bigger than 1 when it's in the margin area\n   * @ko 현재 카메라 아래 패널에서의 위치 진행도를 반환합니다\n   * 반환값은 카메라가 패널 내부에 있을 경우 0부터 1까지의 값을 갖습니다\n   * 패널의 margin 영역에 있을 경우 0보다 작거나 1보다 큰 값을 반환할 수 있습니다\n   */\n  public getProgressInPanel(panel: Panel) {\n    const panelRange = panel.range;\n\n    return (this._position - panelRange.min) / (panelRange.max - panelRange.min);\n  }\n\n  /**\n   * Return {@link AnchorPoint} that includes given position\n   * If there's no {@link AnchorPoint} that includes the given position, return `null` instead\n   * @ko 주어진 좌표를 포함하는 {@link AnchorPoint}를 반환합니다\n   * 주어진 좌표를 포함하는 {@link AnchorPoint}가 없을 경우 `null`을 반환합니다\n   * @param {number} position A position to check<ko>확인할 좌표</ko>\n   * @return {AnchorPoint | null} The {@link AnchorPoint} that includes the given position<ko>해당 좌표를 포함하는 {@link AnchorPoint}</ko>\n   */\n  public findAnchorIncludePosition(position: number): AnchorPoint | null {\n    const anchors = this._anchors;\n    const anchorsIncludingPosition = anchors.filter(anchor => anchor.panel.includePosition(position, true));\n\n    return anchorsIncludingPosition.reduce((nearest: AnchorPoint | null, anchor) => {\n      if (!nearest) return anchor;\n\n      return Math.abs(nearest.position - position) < Math.abs(anchor.position - position)\n        ? nearest\n        : anchor;\n    }, null);\n  }\n\n  /**\n   * Return {@link AnchorPoint} nearest to given position\n   * If there're no {@link AnchorPoint}s, return `null` instead\n   * @ko 해당 좌표에서 가장 가까운 {@link AnchorPoint}를 반환합니다\n   * {@link AnchorPoint}가 하나도 없을 경우 `null`을 반환합니다\n   * @param {number} position A position to check<ko>확인할 좌표</ko>\n   * @return {AnchorPoint | null} The {@link AnchorPoint} nearest to the given position<ko>해당 좌표에 가장 인접한 {@link AnchorPoint}</ko>\n   */\n  public findNearestAnchor(position: number): AnchorPoint | null {\n    const anchors = this._anchors;\n\n    if (anchors.length <= 0) return null;\n\n    let prevDist = Infinity;\n    for (let anchorIdx = 0; anchorIdx < anchors.length; anchorIdx++) {\n      const anchor = anchors[anchorIdx];\n      const dist = Math.abs(anchor.position - position);\n\n      if (dist > prevDist) {\n        // Return previous anchor\n        return anchors[anchorIdx - 1];\n      }\n\n      prevDist = dist;\n    }\n\n    // Return last anchor\n    return anchors[anchors.length - 1];\n  }\n\n  /**\n   * Return {@link AnchorPoint} that matches {@link Flicking#currentPanel}\n   * @ko 현재 {@link Flicking#currentPanel}에 해당하는 {@link AnchorPoint}를 반환합니다\n   * @return {AnchorPoint | null}\n   */\n  public findActiveAnchor(): AnchorPoint | null {\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const activeIndex = flicking.control.activeIndex;\n\n    return find(this._anchors, anchor => anchor.panel.index === activeIndex);\n  }\n\n  /**\n   * Clamp the given position between camera's range\n   * @ko 주어진 좌표를 Camera가 도달 가능한 범위 사이의 값으로 만듭니다\n   * @param {number} position A position to clamp<ko>범위를 제한할 좌표</ko>\n   * @return {number} A clamped position<ko>범위 제한된 좌표</ko>\n   */\n  public clampToReachablePosition(position: number): number {\n    const range = this._range;\n    return clamp(position, range.min, range.max);\n  }\n\n  /**\n   * Check whether the given panel is inside of the Camera's range\n   * @ko 해당 {@link Panel}이 Camera가 도달 가능한 범위 내에 있는지를 반환합니다\n   * @param panel An instance of {@link Panel} to check<ko>확인할 {@link Panel}의 인스턴스</ko>\n   * @return {boolean} Whether the panel's inside Camera's range<ko>도달 가능한 범위 내에 해당 패널이 존재하는지 여부</ko>\n   */\n  public canReach(panel: Panel): boolean {\n    const range = this._range;\n\n    if (panel.removed) return false;\n\n    const panelPos = panel.position;\n\n    return panelPos >= range.min && panelPos <= range.max;\n  }\n\n  /**\n   * Check whether the given panel element is visible at the current position\n   * @ko 현재 좌표에서 해당 패널 엘리먼트를 볼 수 있는지 여부를 반환합니다\n   * @param panel An instance of {@link Panel} to check<ko>확인할 {@link Panel}의 인스턴스</ko>\n   * @return Whether the panel element is visible at the current position<ko>현재 위치에서 해당 패널 엘리먼트가 보이는지 여부</ko>\n   */\n  public canSee(panel: Panel): boolean {\n    const visibleRange = this.visibleRange;\n    // Should not include margin, as we don't declare what the margin is visible as what the panel is visible.\n    return panel.includeRange(visibleRange.min, visibleRange.max, false);\n  }\n\n  /**\n   * Update Camera's {@link Camera#alignPosition alignPosition}\n   * @ko Camera의 {@link Camera#alignPosition alignPosition}을 업데이트합니다\n   * @chainable\n   * @return {this}\n   */\n  public updateAlignPos(): this {\n    const align = this._align;\n\n    const alignVal = typeof align === \"object\"\n      ? (align as { camera: string | number }).camera\n      : align;\n\n    this._alignPos = parseAlign(alignVal, this.size);\n\n    return this;\n  }\n\n  /**\n   * Update Camera's {@link Camera#anchorPoints anchorPoints}\n   * @ko Camera의 {@link Camera#anchorPoints anchorPoints}를 업데이트합니다\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @chainable\n   * @return {this}\n   */\n  public updateAnchors(): this {\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const panels = flicking.renderer.panels;\n\n    this._anchors = panels.map((panel, index) => new AnchorPoint({\n      index,\n      position: panel.position,\n      panel\n    }));\n\n    return this;\n  }\n\n  /**\n   * Update Viewport's height to active panel's height\n   * @ko 현재 선택된 패널의 높이와 동일하도록 뷰포트의 높이를 업데이트합니다\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @chainable\n   * @return {this}\n   */\n  public updateAdaptiveHeight() {\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const activePanel = flicking.control.activePanel;\n\n    if (!flicking.horizontal || !flicking.adaptive || !activePanel) return;\n\n    flicking.viewport.setSize({\n      height: activePanel.height\n    });\n  }\n\n  public updateOffset() {\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const unRenderedPanels = flicking.panels.filter(panel => !panel.rendered);\n    const position = this._position;\n\n    this._offset = unRenderedPanels\n      .filter(panel => panel.position + panel.offset < position)\n      .reduce((offset, panel) => offset + panel.sizeIncludingMargin, 0);\n\n    this._applyTransform();\n  }\n\n  /**\n   * Reset the history of {@link Flicking#event:needPanel needPanel} events so it can be triggered again\n   * @ko 발생한 {@link Flicking#event:needPanel needPanel} 이벤트들을 초기화하여 다시 발생할 수 있도록 합니다\n   * @chainable\n   * @return {this}\n   */\n  public resetNeedPanelHistory(): this {\n    this._needPanelTriggered = { prev: false, next: false };\n    return this;\n  }\n\n  protected _resetInternalValues() {\n    this._position = 0;\n    this._alignPos = 0;\n    this._offset = 0;\n    this._range = { min: 0, max: 0 };\n    this._visiblePanels = [];\n    this._anchors = [];\n    this._needPanelTriggered = { prev: false, next: false };\n  }\n\n  protected _refreshVisiblePanels() {\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const panels = flicking.renderer.panels;\n\n    const newVisiblePanels = panels.filter(panel => this.canSee(panel));\n    const prevVisiblePanels = this._visiblePanels;\n    this._visiblePanels = newVisiblePanels;\n\n    const added: Panel[] = newVisiblePanels.filter(panel => !includes(prevVisiblePanels, panel));\n    const removed: Panel[] = prevVisiblePanels.filter(panel => !includes(newVisiblePanels, panel));\n\n    if (added.length > 0 || removed.length > 0) {\n      void flicking.renderer.render().then(() => {\n        flicking.trigger(new ComponentEvent(EVENTS.VISIBLE_CHANGE, {\n          added,\n          removed,\n          visiblePanels: newVisiblePanels\n        }));\n      });\n    }\n  }\n\n  protected _checkNeedPanel(): void {\n    const needPanelTriggered = this._needPanelTriggered;\n\n    if (needPanelTriggered.prev && needPanelTriggered.next) return;\n\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const panels = flicking.renderer.panels;\n\n    if (panels.length <= 0) {\n      if (!needPanelTriggered.prev) {\n        flicking.trigger(new ComponentEvent(EVENTS.NEED_PANEL, { direction: DIRECTION.PREV }));\n        needPanelTriggered.prev = true;\n      }\n      if (!needPanelTriggered.next) {\n        flicking.trigger(new ComponentEvent(EVENTS.NEED_PANEL, { direction: DIRECTION.NEXT }));\n        needPanelTriggered.next = true;\n      }\n\n      return;\n    }\n\n    const cameraPosition = this._position;\n    const cameraSize = this.size;\n    const cameraRange = this._range;\n    const needPanelThreshold = flicking.needPanelThreshold;\n\n    const cameraPrev = cameraPosition - this._alignPos;\n    const cameraNext = cameraPrev + cameraSize;\n\n    const firstPanel = panels[0];\n    const lastPanel = panels[panels.length - 1];\n\n    if (!needPanelTriggered.prev) {\n      const firstPanelPrev = firstPanel.range.min;\n\n      if (cameraPrev <= (firstPanelPrev + needPanelThreshold) || cameraPosition <= (cameraRange.min + needPanelThreshold)) {\n        flicking.trigger(new ComponentEvent(EVENTS.NEED_PANEL, { direction: DIRECTION.PREV }));\n        needPanelTriggered.prev = true;\n      }\n    }\n\n    if (!needPanelTriggered.next) {\n      const lastPanelNext = lastPanel.range.max;\n\n      if (cameraNext >= (lastPanelNext - needPanelThreshold) || cameraPosition >= (cameraRange.max - needPanelThreshold)) {\n        flicking.trigger(new ComponentEvent(EVENTS.NEED_PANEL, { direction: DIRECTION.NEXT }));\n        needPanelTriggered.next = true;\n      }\n    }\n  }\n\n  protected _checkReachEnd(prevPos: number, newPos: number): void {\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const range = this._range;\n\n    const wasBetweenRange = prevPos > range.min && prevPos < range.max;\n    const isBetweenRange = newPos > range.min && newPos < range.max;\n\n    if (!wasBetweenRange || isBetweenRange) return;\n\n    const direction = newPos <= range.min ? DIRECTION.PREV : DIRECTION.NEXT;\n\n    flicking.trigger(new ComponentEvent(EVENTS.REACH_EDGE, {\n      direction\n    }));\n  }\n\n  protected _applyTransform(): void {\n    const el = this._el;\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n\n    const actualPosition = this._position - this._alignPos - this._offset;\n\n    el.style[this._transform] = flicking.horizontal\n      ? `translate(${-actualPosition}px)`\n      : `translate(0, ${-actualPosition}px)`;\n  }\n\n  protected _checkTranslateSupport = () => {\n    const transforms = [\"webkitTransform\", \"msTransform\", \"MozTransform\", \"OTransform\", \"transform\"];\n\n    const supportedStyle = document.documentElement.style;\n    let transformName = \"\";\n    for (const prefixedTransform of transforms) {\n      if (prefixedTransform in supportedStyle) {\n        transformName = prefixedTransform;\n      }\n    }\n\n    if (!transformName) {\n      throw new FlickingError(ERROR.MESSAGE.TRANSFORM_NOT_SUPPORTED, ERROR.CODE.TRANSFORM_NOT_SUPPORTED);\n    }\n\n    this._transform = transformName;\n  };\n}\n\nexport default Camera;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { getFlickingAttached } from \"../utils\";\n\nimport Camera from \"./Camera\";\n\n/**\n * A {@link Camera} that can move from the position of the first panel to the position of the last panel\n * @ko 첫번째 패널의 좌표로부터 마지막 패널의 좌표로까지 이동할 수 있는 종류의 {@link Camera}\n */\nclass LinearCamera extends Camera {\n  /**\n   * Update {@link Camera#range range} of Camera\n   * @ko Camera의 {@link Camera#range range}를 업데이트합니다\n   * @chainable\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @return {this}\n   */\n  public updateRange() {\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const renderer = flicking.renderer;\n\n    const firstPanel = renderer.getPanel(0);\n    const lastPanel = renderer.getPanel(renderer.panelCount - 1);\n\n    this._range = { min: firstPanel?.position ?? 0, max: lastPanel?.position ?? 0 };\n    return this;\n  }\n}\n\nexport default LinearCamera;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Panel from \"../core/panel/Panel\";\nimport AnchorPoint from \"../core/AnchorPoint\";\nimport { DIRECTION } from \"../const/external\";\nimport { circulatePosition, getFlickingAttached } from \"../utils\";\nimport { ValueOf } from \"../type/internal\";\n\nimport Camera from \"./Camera\";\n\n/**\n * A data of the position that changes order of the panel elements\n * @ko 패널 엘리먼트 순서가 변경되는 좌표의 데이터\n * @interface\n * @property {Panel} panel Toggling panel<ko>순서를 변경할 패널</ko>\n * @property {DIRECTION} direction Toggling position<ko>순서를 변경할 방향</ko>\n * @property {boolean} toggled Whether the panel has toggled its position to `direction`<ko>`direction` 방향으로 패널 위치를 변경했는지 여부를 나타내는 값</ko>\n */\nexport interface TogglePoint {\n  panel: Panel;\n  direction: ValueOf<typeof DIRECTION>;\n  toggled: boolean;\n}\n\n/**\n * A {@link Camera} that connects the last panel and the first panel, enabling continuous loop\n * @ko 첫번째 패널과 마지막 패널이 이어진 상태로, 무한히 회전할 수 있는 종류의 {@link Camera}\n */\nclass CircularCamera extends Camera {\n  private _circularOffset: number = 0;\n  private _circularEnabled: boolean = false;\n\n  public get offset() { return this._offset - this._circularOffset; }\n  public get controlParams() { return { range: this._range, position: this._position, circular: this._circularEnabled }; }\n\n  public getPrevAnchor(anchor: AnchorPoint): AnchorPoint | null {\n    if (!this._circularEnabled || anchor.index !== 0) return super.getPrevAnchor(anchor);\n\n    const anchors = this._anchors;\n    const rangeDiff = this.rangeDiff;\n    const lastAnchor = anchors[anchors.length - 1];\n\n    return new AnchorPoint({\n      index: lastAnchor.index,\n      position: lastAnchor.position - rangeDiff,\n      panel: lastAnchor.panel\n    });\n  }\n\n  public getNextAnchor(anchor: AnchorPoint): AnchorPoint | null {\n    const anchors = this._anchors;\n\n    if (!this._circularEnabled || anchor.index !== anchors.length - 1) return super.getNextAnchor(anchor);\n\n    const rangeDiff = this.rangeDiff;\n    const firstAnchor = anchors[0];\n\n    return new AnchorPoint({\n      index: firstAnchor.index,\n      position: firstAnchor.position + rangeDiff,\n      panel: firstAnchor.panel\n    });\n  }\n\n  public findAnchorIncludePosition(position: number): AnchorPoint | null {\n    if (!this._circularEnabled) return super.findAnchorIncludePosition(position);\n\n    const range = this._range;\n    const positionInRange = circulatePosition(position, range.min, range.max);\n    const anchorInRange = super.findAnchorIncludePosition(positionInRange);\n\n    if (!anchorInRange) return null;\n\n    const rangeDiff = this.rangeDiff;\n\n    if (position < range.min) {\n      const loopCount = -Math.floor((range.min - position) / rangeDiff) - 1;\n\n      return new AnchorPoint({\n        index: anchorInRange.index,\n        position: anchorInRange.position + rangeDiff * loopCount,\n        panel: anchorInRange.panel\n      });\n    } else if (position > range.max) {\n      const loopCount = Math.floor((position - range.max) / rangeDiff) + 1;\n\n      return new AnchorPoint({\n        index: anchorInRange.index,\n        position: anchorInRange.position + rangeDiff * loopCount,\n        panel: anchorInRange.panel\n      });\n    }\n\n    return anchorInRange;\n  }\n\n  public clampToReachablePosition(position: number): number {\n    // Basically all position is reachable for circular camera\n    return this._circularEnabled\n      ? position\n      : super.clampToReachablePosition(position);\n  }\n\n  public canReach(panel: Panel): boolean {\n    if (panel.removed) return false;\n\n    return this._circularEnabled\n      // Always reachable on circular mode\n      ? true\n      : super.canReach(panel);\n  }\n\n  public canSee(panel: Panel): boolean {\n    const range = this._range;\n    const rangeDiff = this.rangeDiff;\n    const visibleRange = this.visibleRange;\n    const visibleInCurrentRange = super.canSee(panel);\n\n    if (!this._circularEnabled) {\n      return visibleInCurrentRange;\n    }\n\n    // Check looped visible area for circular case\n    if (visibleRange.min < range.min) {\n      return visibleInCurrentRange || panel.includeRange(visibleRange.min + rangeDiff, visibleRange.max + rangeDiff, false);\n    } else if (visibleRange.max > range.max) {\n      return visibleInCurrentRange || panel.includeRange(visibleRange.min - rangeDiff, visibleRange.max - rangeDiff, false);\n    }\n\n    return visibleInCurrentRange;\n  }\n\n  /**\n   * Update {@link Camera#range range} of Camera\n   * @ko Camera의 {@link Camera#range range}를 업데이트합니다\n   * @chainable\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @return {this}\n   */\n  public updateRange() {\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const renderer = flicking.renderer;\n\n    const panels = renderer.panels;\n    if (panels.length <= 0) {\n      this._resetInternalValues();\n      return this;\n    }\n\n    const firstPanel = panels[0]!;\n    const lastPanel = panels[panels.length - 1]!;\n    const firstPanelPrev = firstPanel.range.min - firstPanel.margin.prev;\n    const lastPanelNext = lastPanel.range.max + lastPanel.margin.next;\n\n    const visibleSize = this.size;\n    const panelSizeSum = lastPanelNext - firstPanelPrev;\n\n    const canSetCircularMode = panels\n      .every(panel => panelSizeSum - panel.size >= visibleSize);\n    this._circularEnabled = canSetCircularMode;\n\n    if (canSetCircularMode) {\n      this._range = { min: firstPanelPrev, max: lastPanelNext };\n\n      panels.forEach(panel => panel.updateCircularToggleDirection());\n    } else {\n      this._range = { min: firstPanel.position, max: lastPanel.position };\n    }\n\n    this._updateCircularOffset();\n\n    return this;\n  }\n\n  public lookAt(pos: number) {\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const prevPos = this._position;\n\n    if (pos === prevPos) return super.lookAt(pos);\n\n    const panels = flicking.renderer.panels;\n    const toggled = panels.map(panel => panel.toggle(prevPos, pos));\n\n    this._position = pos;\n\n    if (toggled.some(isToggled => isToggled)) {\n      this._updateCircularOffset();\n      void flicking.renderer.render();\n    }\n\n    return super.lookAt(pos);\n  }\n\n  protected _applyTransform(): void {\n    const el = this._el;\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n\n    const actualPosition = this._position - this._alignPos - this._offset + this._circularOffset;\n\n    el.style[this._transform] = flicking.horizontal\n      ? `translate(${-actualPosition}px)`\n      : `translate(0, ${-actualPosition}px)`;\n  }\n\n  protected _resetInternalValues() {\n    super._resetInternalValues();\n    this._circularOffset = 0;\n    this._circularEnabled = false;\n  }\n\n  private _calcPanelAreaSum(panels: Panel[]) {\n    return panels.reduce((sum: number, panel: Panel) => sum + panel.sizeIncludingMargin, 0);\n  }\n\n  private _updateCircularOffset() {\n    if (!this._circularEnabled) {\n      this._circularOffset = 0;\n      return;\n    }\n\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const toggledPrev: Panel[] = [];\n    const toggledNext: Panel[] = [];\n\n    flicking.panels\n      .filter(panel => panel.toggled)\n      .forEach(panel => {\n        if (panel.toggleDirection === DIRECTION.PREV) {\n          toggledPrev.push(panel);\n        } else {\n          toggledNext.push(panel);\n        }\n      });\n\n    this._circularOffset = this._calcPanelAreaSum(toggledPrev) - this._calcPanelAreaSum(toggledNext);\n  }\n}\n\nexport default CircularCamera;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Panel from \"../core/panel/Panel\";\nimport AnchorPoint from \"../core/AnchorPoint\";\nimport { getFlickingAttached, parseAlign } from \"../utils\";\n\nimport Camera from \"./Camera\";\n\n/**\n * A {@link Camera} that set range not to go out of the first/last panel, so it won't show empty spaces before/after the first/last panel\n * @ko 첫번째와 마지막 패널 밖으로 넘어가지 못하도록 범위를 설정하여, 첫번째/마지막 패널 전/후의 빈 공간을 보이지 않도록 하는 종류의 {@link Camera}\n */\nclass BoundCamera extends Camera {\n  /**\n   * Update {@link Camera#range range} of Camera\n   * @ko Camera의 {@link Camera#range range}를 업데이트합니다\n   * @chainable\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @return {this}\n   */\n  public updateRange() {\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const renderer = flicking.renderer;\n    const alignPos = this._alignPos;\n\n    const firstPanel = renderer.getPanel(0);\n    const lastPanel = renderer.getPanel(renderer.panelCount - 1);\n\n    if (!firstPanel || !lastPanel) {\n      this._range = { min: 0, max: 0 };\n      return this;\n    }\n\n    const viewportSize = this.size;\n    const firstPanelPrev = firstPanel.range.min;\n    const lastPanelNext = lastPanel.range.max;\n    const panelAreaSize = lastPanelNext - firstPanelPrev;\n    const isBiggerThanViewport = viewportSize < panelAreaSize;\n\n    const firstPos = firstPanelPrev + alignPos;\n    const lastPos = lastPanelNext - viewportSize + alignPos;\n\n    if (isBiggerThanViewport) {\n      this._range = { min: firstPos, max: lastPos };\n    } else {\n      const align = this._align;\n      const alignVal = typeof align === \"object\"\n        ? (align as { camera: string | number }).camera\n        : align;\n\n      const pos = firstPos + parseAlign(alignVal, lastPos - firstPos);\n\n      this._range = { min: pos, max: pos };\n    }\n\n    return this;\n  }\n\n  public updateAnchors(): this {\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const panels = flicking.renderer.panels;\n\n    if (panels.length <= 0) {\n      this._anchors = [];\n      return this;\n    }\n\n    const range = this._range;\n    const reachablePanels = panels.filter(panel => this.canReach(panel));\n\n    if (reachablePanels.length > 0) {\n      const shouldPrependBoundAnchor = reachablePanels[0].position !== range.min;\n      const shouldAppendBoundAnchor = reachablePanels[reachablePanels.length - 1].position !== range.max;\n      const indexOffset = shouldPrependBoundAnchor ? 1 : 0;\n\n      const newAnchors = reachablePanels.map((panel, idx) => new AnchorPoint({\n        index: idx + indexOffset,\n        position: panel.position,\n        panel\n      }));\n\n      if (shouldPrependBoundAnchor) {\n        newAnchors.splice(0, 0, new AnchorPoint({\n          index: 0,\n          position: range.min,\n          panel: panels[reachablePanels[0].index - 1]\n        }));\n      }\n\n      if (shouldAppendBoundAnchor) {\n        newAnchors.push(new AnchorPoint({\n          index: newAnchors.length,\n          position: range.max,\n          panel: panels[reachablePanels[reachablePanels.length - 1].index + 1]\n        }));\n      }\n\n      this._anchors = newAnchors;\n    } else if (range.min !== range.max) {\n      // There're more than 2 panels\n      const nearestPanelAtMin = this._findNearestPanel(range.min, panels);\n      const panelAtMin = nearestPanelAtMin.index === panels.length - 1\n        ? nearestPanelAtMin.prev()!\n        : nearestPanelAtMin;\n      const panelAtMax = panelAtMin.next()!;\n\n      this._anchors = [\n        new AnchorPoint({\n          index: 0,\n          position: range.min,\n          panel: panelAtMin\n        }),\n        new AnchorPoint({\n          index: 1,\n          position: range.max,\n          panel: panelAtMax\n        })\n      ];\n    } else {\n      this._anchors = [new AnchorPoint({\n        index: 0,\n        position: range.min,\n        panel: this._findNearestPanel(range.min, panels)\n      })];\n    }\n\n    return this;\n  }\n\n  public findAnchorIncludePosition(position: number): AnchorPoint | null {\n    const range = this._range;\n    const anchors = this._anchors;\n\n    if (anchors.length <= 0) return null;\n\n    if (position <= range.min) {\n      return anchors[0];\n    } else if (position >= range.max) {\n      return anchors[anchors.length - 1];\n    } else {\n      return super.findAnchorIncludePosition(position);\n    }\n  }\n\n  private _findNearestPanel(pos: number, panels: Panel[]): Panel {\n    let prevDist = Infinity;\n    for (let panelIdx = 0; panelIdx < panels.length; panelIdx++) {\n      const panel = panels[panelIdx];\n      const dist = Math.abs(panel.position - pos);\n\n      if (dist > prevDist) {\n        // Return previous anchor\n        return panels[panelIdx - 1];\n      }\n\n      prevDist = dist;\n    }\n\n    // Return last anchor\n    return panels[panels.length - 1];\n  }\n}\n\nexport default BoundCamera;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { ComponentEvent } from \"@egjs/component\";\nimport ImReady from \"@egjs/imready\";\n\nimport Flicking, { FlickingOptions } from \"../Flicking\";\nimport Panel, { PanelOptions } from \"../core/panel/Panel\";\nimport FlickingError from \"../core/FlickingError\";\nimport { ALIGN, EVENTS } from \"../const/external\";\nimport * as ERROR from \"../const/error\";\nimport { getFlickingAttached, getMinusCompensatedIndex, includes } from \"../utils\";\n\nexport interface RendererOptions {\n  align: FlickingOptions[\"align\"];\n}\n\n/**\n * A component that manages {@link Panel} and its elements\n * @ko {@link Panel}과 그 엘리먼트들을 관리하는 컴포넌트\n */\nabstract class Renderer {\n  // Internal States\n  protected _flicking: Flicking | null;\n  protected _panels: Panel[];\n\n  // Options\n  protected _align: RendererOptions[\"align\"];\n\n  // Internal states Getter\n  /**\n   * Array of panels\n   * @ko 전체 패널들의 배열\n   * @type {Panel[]}\n   * @readonly\n   * @see Panel\n   */\n  public get panels() { return this._panels; }\n  /**\n   * Count of panels\n   * @ko 전체 패널의 개수\n   * @type {number}\n   * @readonly\n   */\n  public get panelCount() { return this._panels.length; }\n\n  // Options Getter\n  /**\n   * A {@link Panel}'s {@link Panel#align align} value that applied to all panels\n   * @ko {@link Panel}에 공통적으로 적용할 {@link Panel#align align} 값\n   * @type {Constants.ALIGN | string | number}\n   */\n  public get align() { return this._align; }\n\n  // Options Setter\n  public set align(val: RendererOptions[\"align\"]) {\n    this._align = val;\n\n    const panelAlign = this._getPanelAlign();\n    this._panels.forEach(panel => { panel.align = panelAlign; });\n  }\n\n  /**\n   * @param {object} options An options object<ko>옵션 오브젝트</ko>\n   * @param {Constants.ALIGN | string | number} [options.align] An {@link Flicking#align align} value that will be applied to all panels<ko>전체 패널에 적용될 {@link Flicking#align align} 값</ko>\n   */\n  public constructor({\n    align = ALIGN.CENTER\n  }: Partial<RendererOptions> = {}) {\n    this._flicking = null;\n    this._panels = [];\n\n    // Bind options\n    this._align = align;\n  }\n\n  /**\n   * Render panel elements inside the camera element\n   * @ko 패널 엘리먼트들을 카메라 엘리먼트 내부에 렌더링합니다\n   * @method\n   * @abstract\n   * @memberof Renderer\n   * @instance\n   * @name render\n   * @chainable\n   * @return {this}\n   */\n  public abstract render(): Promise<void>;\n  public abstract forceRenderAllPanels(): Promise<void>;\n\n  protected abstract _collectPanels(): void;\n  protected abstract _createPanel(el: any, options: PanelOptions): Panel;\n  protected abstract _insertPanelElements(panels: Panel[], nextSibling: Panel | null): void;\n  protected abstract _removePanelElements(panels: Panel[]): void;\n\n  /**\n   * Initialize Renderer\n   * @ko Renderer를 초기화합니다\n   * @param {Flicking} flicking An instance of {@link Flicking}<ko>Flicking의 인스턴스</ko>\n   * @chainable\n   * @return {this}\n   */\n  public init(flicking: Flicking): this {\n    this._flicking = flicking;\n    this._collectPanels();\n\n    return this;\n  }\n\n  /**\n   * Destroy Renderer and return to initial state\n   * @ko Renderer를 초기 상태로 되돌립니다\n   * @return {void}\n   */\n  public destroy(): void {\n    this._flicking = null;\n    this._panels = [];\n  }\n\n  /**\n   * Return the {@link Panel} at the given index. `null` if it doesn't exists.\n   * @ko 주어진 인덱스에 해당하는 {@link Panel}을 반환합니다. 주어진 인덱스에 해당하는 패널이 존재하지 않을 경우 `null`을 반환합니다.\n   * @return {Panel | null} Panel at the given index<ko>주어진 인덱스에 해당하는 패널</ko>\n   * @see Panel\n   */\n  public getPanel(index: number): Panel | null {\n    return this._panels[index] || null;\n  }\n\n  /**\n   * Update all panel sizes\n   * @ko 모든 패널의 크기를 업데이트합니다\n   * @chainable\n   * @return {this}\n   */\n  public updatePanelSize(): this {\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n\n    if (flicking.panelsPerView > 0) {\n      this._updatePanelSizeByGrid(flicking);\n    } else {\n      flicking.panels.forEach(panel => panel.resize());\n    }\n\n    return this;\n  }\n\n  /**\n   * Insert new panels at given index\n   * This will increase index of panels after by the number of panels added\n   * @ko 주어진 인덱스에 새로운 패널들을 추가합니다\n   * 해당 인덱스보다 같거나 큰 인덱스를 가진 기존 패널들은 추가한 패널의 개수만큼 인덱스가 증가합니다.\n   * @param {number} index Index to insert new panels at<ko>새로 패널들을 추가할 인덱스</ko>\n   * @param {any[]} elements An array of element or framework component with element in it<ko>엘리먼트의 배열 혹은 프레임워크에서 엘리먼트를 포함한 컴포넌트들의 배열</ko>\n   * @return {Panel[]} An array of prepended panels<ko>추가된 패널들의 배열</ko>\n   */\n  public batchInsert(...items: Array<{\n    index: number;\n    elements: any[];\n  }>): Panel[] {\n    const panels = this._panels;\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n\n    const { control } = flicking;\n    const align = this._getPanelAlign();\n\n    const allPanelsInserted = items.reduce((addedPanels, item) => {\n      const insertingIdx = getMinusCompensatedIndex(item.index, panels.length);\n      const panelsPushed = panels.slice(insertingIdx);\n      const panelsInserted = item.elements.map((el, idx) => this._createPanel(el, { index: insertingIdx + idx, align, flicking }));\n\n      panels.splice(insertingIdx, 0, ...panelsInserted);\n\n      // Insert the actual elements as camera element's children\n      this._insertPanelElements(panelsInserted, panelsPushed[0] ?? null);\n\n      // Resize the newly added panels\n      panelsInserted.forEach(panel => panel.resize());\n\n      // Update panel indexes & positions\n      panelsPushed.forEach(panel => {\n        panel.increaseIndex(panelsInserted.length);\n        panel.updatePosition();\n      });\n\n      return [...addedPanels, ...panelsInserted];\n    }, []);\n\n    if (allPanelsInserted.length <= 0) return [];\n\n    // Update camera & control\n    this._updateCameraAndControl();\n\n    void this.render();\n\n    // Move to the first panel added if no panels existed\n    // FIXME: fix for animating case\n    if (allPanelsInserted.length > 0 && !control.animating) {\n      void control.moveToPanel(control.activePanel || allPanelsInserted[0], {\n        duration: 0\n      }).catch(() => void 0);\n    }\n\n    flicking.camera.updateOffset();\n\n    flicking.trigger(new ComponentEvent(EVENTS.PANEL_CHANGE, {\n      added: allPanelsInserted,\n      removed: []\n    }));\n\n    this.checkPanelContentsReady(allPanelsInserted);\n\n    return allPanelsInserted;\n  }\n\n  /**\n   * Remove the panel at the given index\n   * This will decrease index of panels after by the number of panels removed\n   * @ko 주어진 인덱스의 패널을 제거합니다\n   * 해당 인덱스보다 큰 인덱스를 가진 기존 패널들은 제거한 패널의 개수만큼 인덱스가 감소합니다\n   * @param {number} index Index of panel to remove<ko>제거할 패널의 인덱스</ko>\n   * @param {number} [deleteCount=1] Number of panels to remove from index<ko>`index` 이후로 제거할 패널의 개수</ko>\n   * @return An array of removed panels<ko>제거된 패널들의 배열</ko>\n   */\n  public batchRemove(...items: Array<{ index: number; deleteCount: number }>): Panel[] {\n    const panels = this._panels;\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n\n    const { camera, control } = flicking;\n    const activePanel = control.activePanel;\n    const activeIndex = control.activeIndex;\n\n    const allPanelsRemoved = items.reduce((removed, item) => {\n      const { index, deleteCount } = item;\n      const removingIdx = getMinusCompensatedIndex(index, panels.length);\n\n      const panelsPulled = panels.slice(removingIdx + deleteCount);\n      const panelsRemoved = panels.splice(removingIdx, deleteCount);\n\n      if (panelsRemoved.length <= 0) return [];\n\n      // Update panel indexes & positions\n      panelsPulled.forEach(panel => {\n        panel.decreaseIndex(panelsRemoved.length);\n        panel.updatePosition();\n      });\n\n      this._removePanelElements(panelsRemoved);\n\n      // Remove panel elements\n      panelsRemoved.forEach(panel => panel.destroy());\n\n      // Update camera & control\n      this._updateCameraAndControl();\n\n      if (includes(panelsRemoved, activePanel)) {\n        control.resetActive();\n      }\n\n      return [...removed, ...panelsRemoved];\n    }, []);\n\n    void this.render();\n\n    // FIXME: fix for animating case\n    if (allPanelsRemoved.length > 0 && !control.animating) {\n      const targetPanel = includes(allPanelsRemoved, activePanel)\n        ? (panels[activeIndex] || panels[panels.length - 1])\n        : activePanel;\n\n      if (targetPanel) {\n        void control.moveToPanel(targetPanel, {\n          duration: 0\n        }).catch(() => void 0);\n      } else {\n        // All panels removed\n        camera.lookAt(0);\n      }\n    }\n\n    flicking.camera.updateOffset();\n\n    flicking.trigger(new ComponentEvent(EVENTS.PANEL_CHANGE, {\n      added: [],\n      removed: allPanelsRemoved\n    }));\n\n    return allPanelsRemoved;\n  }\n\n  /**\n   * @internal\n   */\n  public checkPanelContentsReady(checkingPanels: Panel[]) {\n    const resizeOnContentsReady = getFlickingAttached(this._flicking, \"Renderer\").resizeOnContentsReady;\n    const panels = this._panels;\n\n    if (!resizeOnContentsReady) return;\n\n    const hasContents = (panel: Panel) => !!panel.element.querySelector(\"img, video\");\n    checkingPanels = checkingPanels.filter(panel => hasContents(panel));\n\n    if (checkingPanels.length <= 0) return;\n\n    const contentsReadyChecker = new ImReady();\n\n    checkingPanels.forEach(panel => {\n      panel.loading = true;\n    });\n\n    contentsReadyChecker.on(\"readyElement\", e => {\n      const flicking = this._flicking;\n\n      if (!flicking) {\n        // Renderer's destroy() is called before\n        contentsReadyChecker.destroy();\n        return;\n      }\n\n      const panel = checkingPanels[e.index];\n      const camera = flicking.camera;\n      const control = flicking.control;\n      const prevProgressInPanel = control.activePanel\n        ? camera.getProgressInPanel(control.activePanel)\n        : 0;\n\n      panel.loading = false;\n      panel.resize();\n      panels.slice(panel.index + 1).forEach(panelBehind => panelBehind.updatePosition());\n\n      if (!flicking.initialized) return;\n\n      camera.updateRange();\n      camera.updateAnchors();\n\n      if (control.animating) {\n        // TODO: Need Axes update\n      } else {\n        control.updatePosition(prevProgressInPanel);\n        control.updateInput();\n      }\n    });\n\n    contentsReadyChecker.on(\"preReady\", e => {\n      if (this._flicking) {\n        void this.render();\n      }\n\n      if (e.readyCount === e.totalCount) {\n        contentsReadyChecker.destroy();\n      }\n    });\n\n    contentsReadyChecker.on(\"ready\", () => {\n      if (this._flicking) {\n        void this.render();\n      }\n      contentsReadyChecker.destroy();\n    });\n\n    contentsReadyChecker.check(checkingPanels.map(panel => panel.element));\n  }\n\n  protected _getPanelAlign() {\n    const align = this._align;\n\n    return typeof align === \"object\"\n      ? (align as { panel: string | number }).panel\n      : align;\n  }\n\n  protected _updateCameraAndControl() {\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n    const { camera, control } = flicking;\n\n    camera.updateRange();\n    camera.updateAnchors();\n    camera.resetNeedPanelHistory();\n    control.updateInput();\n  }\n\n  protected _updateRenderingPanels(): void {\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n\n    if (flicking.renderOnlyVisible) {\n      this._showOnlyVisiblePanels(flicking);\n    } else {\n      flicking.panels.forEach(panel => panel.markForShow());\n    }\n  }\n\n  protected _showOnlyVisiblePanels(flicking: Flicking) {\n    const panels = flicking.renderer.panels;\n    const camera = flicking.camera;\n\n    const visibleIndexes = camera.visiblePanels.reduce((visibles, panel) => {\n      visibles[panel.index] = true;\n      return visibles;\n    }, {});\n\n    panels.forEach(panel => {\n      if (panel.index in visibleIndexes || panel.loading) {\n        panel.markForShow();\n      } else if (!flicking.holding) {\n        // During the input sequence,\n        // Do not remove panel elements as it won't trigger touchend event.\n        panel.markForHide();\n      }\n    });\n\n    camera.updateOffset();\n  }\n\n  protected _updatePanelSizeByGrid(flicking: Flicking) {\n    const panels = flicking.panels;\n    const panelsPerView = flicking.panelsPerView;\n\n    if (panelsPerView <= 0) {\n      throw new FlickingError(ERROR.MESSAGE.WRONG_OPTION(\"panelsPerView\", panelsPerView), ERROR.CODE.WRONG_OPTION);\n    }\n    if (panels.length <= 0) return;\n\n    // resize only the first panel\n    const firstPanel = panels[0];\n    firstPanel.resize();\n\n    const viewportSize = flicking.camera.size;\n    const gap = firstPanel.margin.prev + firstPanel.margin.next;\n\n    const panelSize = (viewportSize - gap * (panelsPerView - 1)) / panelsPerView;\n    const panelSizeObj = flicking.horizontal\n      ? { width: panelSize }\n      : { height: panelSize };\n    const firstPanelSizeObj = {\n      size: panelSize,\n      height: firstPanel.height,\n      margin: firstPanel.margin\n    };\n\n    if (!flicking.noPanelStyleOverride) {\n      flicking.panels.forEach(panel => panel.setSize(panelSizeObj));\n    }\n\n    flicking.panels.forEach(panel => panel.resize(firstPanelSizeObj));\n  }\n}\n\nexport default Renderer;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking from \"../../Flicking\";\nimport { getProgress, getStyle, isString, parseAlign } from \"../../utils\";\nimport { ALIGN, DIRECTION } from \"../../const/external\";\nimport { LiteralUnion, ValueOf } from \"../../type/internal\";\n\nexport interface PanelOptions {\n  index: number;\n  align: LiteralUnion<ValueOf<typeof ALIGN>> | number;\n  flicking: Flicking;\n}\n\nabstract class Panel {\n  // Internal States\n  protected _flicking: Flicking;\n  protected _index: number;\n  protected _pos: number;\n  protected _size: number;\n  protected _height: number;\n  protected _margin: { prev: number; next: number };\n  protected _alignPos: number; // Actual align pos\n  protected _removed: boolean;\n  protected _loading: boolean;\n  protected _toggleDirection: ValueOf<typeof DIRECTION>;\n  protected _toggled: boolean;\n  protected _togglePosition: number;\n\n  // Options\n  protected _align: PanelOptions[\"align\"];\n\n  // Internal States Getter\n  /**\n   * `HTMLElement` that panel's referencing\n   * @ko 패널이 참조하고 있는 `HTMLElement`\n   * @type {HTMLElement}\n   * @readonly\n   */\n  abstract get element(): HTMLElement;\n  /**\n   * Index of the panel\n   * @ko 패널의 인덱스\n   * @type {number}\n   * @readonly\n   */\n  public get index() { return this._index; }\n  /**\n   * Position of the panel, including {@link Panel#alignPosition alignPosition}\n   * @ko 패널의 현재 좌표, {@link Panel#alignPosition alignPosition}을 포함하고 있습니다\n   * @type {number}\n   * @readonly\n   */\n  public get position() { return this._pos + this._alignPos; }\n  /**\n   * Cached size of the panel element\n   * This is equal to {@link Panel#element element}'s `offsetWidth` if {@link Flicking#horizontal horizontal} is `true`, and `offsetHeight` else\n   * @ko 패널 엘리먼트의 캐시된 크기\n   * 이 값은 {@link Flicking#horizontal horizontal}이 `true`일 경우 {@link Panel#element element}의 `offsetWidth`와 동일하고, `false`일 경우 `offsetHeight`와 동일합니다\n   * @type {number}\n   * @readonly\n   */\n  public get size() { return this._size; }\n  /**\n   * Panel's size including CSS `margin`\n   * This value includes {@link Panel#element element}'s margin left/right if {@link Flicking#horizontal horizontal} is `true`, and margin top/bottom else\n   * @ko CSS `margin`을 포함한 패널의 크기\n   * 이 값은 {@link Flicking#horizontal horizontal}이 `true`일 경우 margin left/right을 포함하고, `false`일 경우 margin top/bottom을 포함합니다\n   * @type {number}\n   * @readonly\n   */\n  public get sizeIncludingMargin() { return this._size + this._margin.prev + this._margin.next; }\n  /**\n   * Height of the panel element\n   * @ko 패널 엘리먼트의 높이\n   * @type {number}\n   * @readonly\n   */\n  public get height() { return this._height; }\n  /**\n   * Cached CSS `margin` value of the panel element\n   * @ko 패널 엘리먼트의 CSS `margin` 값\n   * @type {object}\n   * @property {number} prev CSS `margin-left` when the {@link Flicking#horizontal horizontal} is `true`, and `margin-top` else\n   * <ko>{@link Flicking#horizontal horizontal}이 `true`일 경우 `margin-left`, `false`일 경우 `margin-top`에 해당하는 값</ko>\n   * @property {number} next CSS `margin-right` when the {@link Flicking#horizontal horizontal} is `true`, and `margin-bottom` else\n   * <ko>{@link Flicking#horizontal horizontal}이 `true`일 경우 `margin-right`, `false`일 경우 `margin-bottom`에 해당하는 값</ko>\n   * @readonly\n   */\n  public get margin() { return this._margin; }\n  /**\n   * Align position inside the panel where {@link Camera}'s {@link Camera#alignPosition alignPosition} inside viewport should be located at\n   * @ko 패널의 정렬 기준 위치. {@link Camera}의 뷰포트 내에서의 {@link Camera#alignPosition alignPosition}이 위치해야 하는 곳입니다\n   * @type {number}\n   * @readonly\n   */\n  public get alignPosition() { return this._alignPos; }\n  /**\n   * A value indicating whether the panel's {@link Flicking#remove remove}d\n   * @ko 패널이 {@link Flicking#remove remove}되었는지 여부를 나타내는 값\n   * @type {boolean}\n   * @readonly\n   */\n  public get removed() { return this._removed; }\n  /**\n   * A value indicating whether the panel's image/video is not loaded and waiting for resize\n   * @ko 패널 내부의 이미지/비디오가 아직 로드되지 않아 {@link Panel#resize resize}될 것인지를 나타내는 값\n   * @type {boolean}\n   * @readonly\n   */\n  public get loading() { return this._loading; }\n  /**\n   * A value indicating whether the panel's element is being rendered on the screen\n   * @ko 패널의 엘리먼트가 화면상에 렌더링되고있는지 여부를 나타내는 값\n   * @type {boolean}\n   * @readonly\n   */\n  public abstract get rendered();\n  /**\n   * Panel element's range of the bounding box\n   * @ko 패널 엘리먼트의 Bounding box 범위\n   * @type {object}\n   * @property {number} [min] Bounding box's left({@link Flicking#horizontal horizontal}: true) / top({@link Flicking#horizontal horizontal}: false)\n   * @property {number} [max] Bounding box's right({@link Flicking#horizontal horizontal}: true) / bottom({@link Flicking#horizontal horizontal}: false)\n   * @readonly\n   */\n  public get range() { return { min: this._pos, max: this._pos + this._size }; }\n  /**\n   * A value indicating whether the panel's position is toggled by circular behavior\n   * @ko 패널의 위치가 circular 동작에 의해 토글되었는지 여부를 나타내는 값\n   * @type {boolean}\n   * @readonly\n   */\n  public get toggled() { return this._toggled; }\n  /**\n   * A direction where the panel's position is toggled\n   * @ko 패널의 위치가 circular 동작에 의해 토글되는 방향\n   * @type {DIRECTION}\n   * @readonly\n   */\n  public get toggleDirection() { return this._toggleDirection; }\n  /**\n   * Actual position offset determined by {@link Panel#order}\n   * @ko {@link Panel#order}에 의한 실제 위치 변경값\n   * @type {number}\n   * @readonly\n   */\n  public get offset() {\n    const toggleDirection = this._toggleDirection;\n    const cameraRangeDiff = this._flicking.camera.rangeDiff;\n\n    return toggleDirection === DIRECTION.NONE || !this._toggled\n      ? 0\n      : toggleDirection === DIRECTION.PREV\n        ? -cameraRangeDiff\n        : cameraRangeDiff;\n  }\n\n  /**\n   * Progress of movement between previous or next panel relative to current panel\n   * @ko 이 패널로부터 이전/다음 패널으로의 이동 진행률\n   * @type {number}\n   * @readonly\n   */\n  public get progress() {\n    const flicking = this._flicking;\n\n    return this.index - flicking.camera.progress;\n  }\n\n  /**\n   * Progress of movement between points that panel is completely invisible outside of viewport(prev direction: -1, selected point: 0, next direction: 1)\n   * @ko 현재 패널이 뷰포트 영역 밖으로 완전히 사라지는 지점을 기준으로 하는 진행도(prev방향: -1, 선택 지점: 0, next방향: 1)\n   * @type {number}\n   * @readonly\n   */\n  public get outsetProgress() {\n    const position = this.position + this.offset;\n    const alignPosition = this._alignPos;\n    const camera = this._flicking.camera;\n    const camPos = camera.position;\n\n    if (camPos === position) {\n      return 0;\n    }\n\n    if (camPos < position) {\n      const disappearPosNext = position + (camera.size - camera.alignPosition) + alignPosition;\n\n      return -getProgress(camPos, position, disappearPosNext);\n    } else {\n      const disappearPosPrev = position - (camera.alignPosition + this._size - alignPosition);\n\n      return 1 - getProgress(camPos, disappearPosPrev, position);\n    }\n  }\n\n  /**\n   * Percentage of area where panel is visible in the viewport\n   * @ko 뷰포트 안에서 패널이 보이는 영역의 비율\n   * @type {number}\n   * @readonly\n   */\n  public get visibleRatio() {\n    const range = this.range;\n    const size = this._size;\n    const offset = this.offset;\n    const visibleRange = this._flicking.camera.visibleRange;\n\n    const checkingRange = {\n      min: range.min + offset,\n      max: range.max + offset\n    };\n\n    if (checkingRange.max <= visibleRange.min || checkingRange.min >= visibleRange.max) {\n      return 0;\n    }\n\n    let visibleSize = size;\n\n    if (visibleRange.min > checkingRange.min) {\n      visibleSize -= visibleRange.min - checkingRange.min;\n    }\n    if (visibleRange.max < checkingRange.max) {\n      visibleSize -= checkingRange.max - visibleRange.max;\n    }\n\n    return visibleSize / size;\n  }\n\n  public set loading(val: boolean) { this._loading = val; }\n\n  // Options Getter\n  /**\n   * A value indicating where the {@link Panel#alignPosition alignPosition} should be located at inside the panel element\n   * @ko {@link Panel#alignPosition alignPosition}이 패널 내의 어디에 위치해야 하는지를 나타내는 값\n   * @type {Constants.ALIGN | string | number}\n   */\n  public get align() { return this._align; }\n\n  // Options Setter\n  public set align(val: PanelOptions[\"align\"]) { this._align = val; }\n\n  /**\n   * @param {object} options An options object<ko>옵션 오브젝트</ko>\n   * @param {number} [options.index] An initial index of the panel<ko>패널의 초기 인덱스</ko>\n   * @param {Constants.ALIGN | string | number} [options.align] An initial {@link Flicking#align align} value of the panel<ko>패널의 초기 {@link Flicking#align align}값</ko>\n   * @param {Flicking} [options.flicking] A Flicking instance panel's referencing<ko>패널이 참조하는 {@link Flicking} 인스턴스</ko>\n   */\n  public constructor({\n    index,\n    align,\n    flicking\n  }: PanelOptions) {\n    this._index = index;\n    this._flicking = flicking;\n\n    this._align = align;\n\n    this._removed = false;\n    this._loading = false;\n    this._resetInternalStates();\n  }\n\n  /**\n   * Mark panel element to be appended on the camera element\n   * @internal\n   */\n  public abstract markForShow();\n\n  /**\n   * Mark panel element to be removed from the camera element\n   * @internal\n   */\n  public abstract markForHide();\n\n  /**\n   * Update size of the panel\n   * @ko 패널의 크기를 갱신합니다\n   * @param {object} cached Predefined cached size of the panel<ko>사전에 캐시된 패널의 크기 정보</ko>\n   * @chainable\n   * @return {this}\n   */\n  public resize(cached?: {\n    size: number;\n    height: number;\n    margin: { prev: number; next: number };\n  }): this {\n    const el = this.element;\n    const elStyle = getStyle(el);\n    const flicking = this._flicking;\n    const horizontal = flicking.horizontal;\n\n    if (cached) {\n      this._size = cached.size;\n      this._margin = { ...cached.margin };\n      this._height = cached.height;\n    } else {\n      this._size = horizontal ? el.offsetWidth : el.offsetHeight;\n      this._margin = horizontal\n        ? {\n          prev: parseFloat(elStyle.marginLeft || \"0\"),\n          next: parseFloat(elStyle.marginRight || \"0\")\n        } : {\n          prev: parseFloat(elStyle.marginTop || \"0\"),\n          next: parseFloat(elStyle.marginBottom || \"0\")\n        };\n      this._height = horizontal ? el.offsetHeight : this._size;\n    }\n\n    this.updatePosition();\n    this._updateAlignPos();\n\n    return this;\n  }\n\n  /**\n   * Change panel's size. This will change the actual size of the panel element by changing its CSS width/height property\n   * @ko 패널 크기를 변경합니다. 패널 엘리먼트에 해당 크기의 CSS width/height를 적용합니다\n   * @param {object} [size] New panel size<ko>새 패널 크기</ko>\n   * @param {number|string} [size.width] CSS string or number(in px)<ko>CSS 문자열 또는 숫자(px)</ko>\n   * @param {number|string} [size.height] CSS string or number(in px)<ko>CSS 문자열 또는 숫자(px)</ko>\n   * @chainable\n   * @return {this}\n   */\n  public setSize({\n    width,\n    height\n  }: Partial<{\n    width: number | string;\n    height: number | string;\n  }>): this {\n    const el = this.element;\n\n    if (width != null) {\n      if (isString(width)) {\n        el.style.width = width;\n      } else {\n        el.style.width = `${width}px`;\n      }\n    }\n    if (height != null) {\n      if (isString(height)) {\n        el.style.height = height;\n      } else {\n        el.style.height = `${height}px`;\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Check whether the given element is inside of this panel's {@link Panel#element element}\n   * @ko 해당 엘리먼트가 이 패널의 {@link Panel#element element} 내에 포함되어 있는지를 반환합니다\n   * @param {HTMLElement} element The HTMLElement to check<ko>확인하고자 하는 HTMLElement</ko>\n   * @return {boolean} A Boolean value indicating the element is inside of this panel {@link Panel#element element}<ko>패널의 {@link Panel#element element}내에 해당 엘리먼트 포함 여부</ko>\n   */\n  public contains(element: HTMLElement): boolean {\n    return !!this.element?.contains(element);\n  }\n\n  /**\n   * Reset internal state and set {@link Panel#removed removed} to `true`\n   * @ko 내부 상태를 초기화하고 {@link Panel#removed removed}를 `true`로 설정합니다.\n   * @return {void}\n   */\n  public destroy(): void {\n    this._resetInternalStates();\n    this._removed = true;\n  }\n\n  /**\n   * Check whether the given position is inside of this panel's {@link Panel#range range}\n   * @ko 주어진 좌표가 현재 패널의 {@link Panel#range range}내에 속해있는지를 반환합니다.\n   * @param {number} pos A position to check<ko>확인하고자 하는 좌표</ko>\n   * @param {boolean} [includeMargin=false] Include {@link Panel#margin margin} to the range<ko>패널 영역에 {@link Panel#margin margin}값을 포함시킵니다</ko>\n   * @return {boolean} A Boolean value indicating whether the given position is included in the panel range<ko>해당 좌표가 패널 영역 내에 속해있는지 여부</ko>\n   */\n  public includePosition(pos: number, includeMargin: boolean = false): boolean {\n    return this.includeRange(pos, pos, includeMargin);\n  }\n\n  /**\n   * Check whether the given range is fully included in this panel's area\n   * @ko 주어진 범위가 이 패널 내부에 완전히 포함되는지를 반환합니다\n   * @param {number} min Minimum value of the range to check<ko>확인하고자 하는 최소 범위</ko>\n   * @param {number} max Maximum value of the range to check<ko>확인하고자 하는 최대 범위</ko>\n   * @param {boolean} [includeMargin=false] Include {@link Panel#margin margin} to the range<ko>패널 영역에 {@link Panel#margin margin}값을 포함시킵니다</ko>\n   * @returns {boolean} A Boolean value indicating whether the given range is fully included in the panel range<ko>해당 범위가 패널 영역 내에 완전히 속해있는지 여부</ko>\n   */\n  public includeRange(min: number, max: number, includeMargin: boolean = false): boolean {\n    const margin = this._margin;\n    const panelRange = this.range;\n\n    if (includeMargin) {\n      panelRange.min -= margin.prev;\n      panelRange.max += margin.next;\n    }\n\n    return max >= panelRange.min && min <= panelRange.max;\n  }\n\n  /**\n   * Move {@link Camera} to this panel\n   * @ko {@link Camera}를 이 패널로 이동합니다\n   * @param {number} [duration] Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>\n   * @returns {Promise<void>} A Promise which will be resolved after reaching the panel<ko>패널 도달시에 resolve되는 Promise</ko>\n   */\n  public focus(duration?: number) {\n    return this._flicking.moveTo(this._index, duration);\n  }\n\n  /**\n   * Get previous(`index - 1`) panel. When the previous panel does not exist, this will return `null` instead\n   * If the {@link Flicking#circularEnabled circular} is enabled, this will return the last panel if called from the first panel\n   * @ko 이전(`index - 1`) 패널을 반환합니다. 이전 패널이 없을 경우 `null`을 반환합니다\n   * {@link Flicking#circularEnabled circular} 모드가 활성화되었을 때 첫번째 패널에서 이 메소드를 호출할 경우 마지막 패널을 반환합니다\n   * @returns {Panel | null} The previous panel<ko>이전 패널</ko>\n   */\n  public prev(): Panel | null {\n    const index = this._index;\n    const flicking = this._flicking;\n    const renderer = flicking.renderer;\n    const panelCount = renderer.panelCount;\n\n    if (panelCount === 1) return null;\n\n    return flicking.circularEnabled\n      ? renderer.getPanel(index === 0 ? panelCount - 1 : index - 1)\n      : renderer.getPanel(index - 1);\n  }\n\n  /**\n   * Get next(`index + 1`) panel. When the next panel does not exist, this will return `null` instead\n   * If the {@link Flicking#circularEnabled circular} is enabled, this will return the first panel if called from the last panel\n   * @ko 다음(`index + 1`) 패널을 반환합니다. 다음 패널이 없을 경우 `null`을 반환합니다\n   * {@link Flicking#circularEnabled circular} 모드가 활성화되었을 때 마지막 패널에서 이 메소드를 호출할 경우 첫번째 패널을 반환합니다\n   * @returns {Panel | null} The previous panel<ko>다음 패널</ko>\n   */\n  public next(): Panel | null {\n    const index = this._index;\n    const flicking = this._flicking;\n    const renderer = flicking.renderer;\n    const panelCount = renderer.panelCount;\n\n    if (panelCount === 1) return null;\n\n    return flicking.circularEnabled\n      ? renderer.getPanel(index === panelCount - 1 ? 0 : index + 1)\n      : renderer.getPanel(index + 1);\n  }\n\n  /**\n   * Increase panel's index by the given value\n   * @ko 패널의 인덱스를 주어진 값만큼 증가시킵니다\n   * @internal\n   * @chainable\n   * @param val An integer greater than or equal to 0<ko>0보다 같거나 큰 정수</ko>\n   * @returns {this}\n   */\n  public increaseIndex(val: number): this {\n    this._index += Math.max(val, 0);\n    return this;\n  }\n\n  /**\n   * Decrease panel's index by the given value\n   * @ko 패널의 인덱스를 주어진 값만큼 감소시킵니다\n   * @internal\n   * @chainable\n   * @param val An integer greater than or equal to 0<ko>0보다 같거나 큰 정수</ko>\n   * @returns {this}\n   */\n  public decreaseIndex(val: number): this {\n    this._index -= Math.max(val, 0);\n    return this;\n  }\n\n  /**\n   * @internal\n   */\n  public updatePosition(): this {\n    const prevPanel = this._flicking.renderer.panels[this._index - 1];\n\n    this._pos = prevPanel\n      ? prevPanel.range.max + prevPanel.margin.next + this._margin.prev\n      : this._margin.prev;\n\n    return this;\n  }\n\n  /**\n   * @internal\n   * @return {boolean} toggled\n   */\n  public toggle(prevPos: number, newPos: number): boolean {\n    const toggleDirection = this._toggleDirection;\n    const togglePosition = this._togglePosition;\n\n    if (toggleDirection === DIRECTION.NONE || newPos === prevPos) return false;\n\n    const prevToggled = this._toggled;\n\n    if (newPos > prevPos) {\n      if (togglePosition >= prevPos && togglePosition <= newPos) {\n        this._toggled = toggleDirection === DIRECTION.NEXT;\n      }\n    } else {\n      if (togglePosition <= prevPos && togglePosition >= newPos) {\n        this._toggled = toggleDirection !== DIRECTION.NEXT;\n      }\n    }\n\n    return prevToggled !== this._toggled;\n  }\n\n  /**\n   * @internal\n   */\n  public updateCircularToggleDirection(): this {\n    const flicking = this._flicking;\n\n    if (!flicking.circularEnabled) {\n      this._toggleDirection = DIRECTION.NONE;\n      this._toggled = false;\n      return this;\n    }\n\n    const camera = flicking.camera;\n    const camRange = camera.range;\n    const camAlignPosition = camera.alignPosition;\n    const camVisibleRange = camera.visibleRange;\n    const camVisibleSize = camVisibleRange.max - camVisibleRange.min;\n\n    const minimumVisible = camRange.min - camAlignPosition;\n    const maximumVisible = camRange.max - camAlignPosition + camVisibleSize;\n\n    const shouldBeVisibleAtMin = this.includeRange(maximumVisible - camVisibleSize, maximumVisible, false);\n    const shouldBeVisibleAtMax = this.includeRange(minimumVisible, minimumVisible + camVisibleSize, false);\n\n    this._toggled = false;\n    if (shouldBeVisibleAtMin) {\n      this._toggleDirection = DIRECTION.PREV;\n      this._togglePosition = this.range.max + camRange.min - camRange.max + camAlignPosition;\n      this.toggle(Infinity, camera.position);\n    } else if (shouldBeVisibleAtMax) {\n      this._toggleDirection = DIRECTION.NEXT;\n      this._togglePosition = this.range.min + camRange.max - camVisibleSize + camAlignPosition;\n      this.toggle(-Infinity, camera.position);\n    } else {\n      this._toggleDirection = DIRECTION.NONE;\n      this._togglePosition = 0;\n    }\n\n    return this;\n  }\n\n  private _updateAlignPos() {\n    this._alignPos = parseAlign(this._align, this._size);\n  }\n\n  private _resetInternalStates() {\n    this._size = 0;\n    this._pos = 0;\n    this._margin = { prev: 0, next: 0 };\n    this._height = 0;\n    this._alignPos = 0;\n    this._toggled = false;\n    this._togglePosition = 0;\n    this._toggleDirection = DIRECTION.NONE;\n  }\n}\n\nexport default Panel;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Panel, { PanelOptions } from \"./Panel\";\n\nexport interface ElementPanelOptions extends PanelOptions {\n  el: HTMLElement;\n}\n\n/**\n * An slide data component that holds information of a single HTMLElement\n * @ko 슬라이드 데이터 컴포넌트로, 단일 HTMLElement의 정보를 갖고 있습니다\n */\nclass ElementPanel extends Panel {\n  private _el: HTMLElement;\n  private _rendered: boolean;\n\n  /**\n   * `HTMLElement` that panel's referencing\n   * @ko 패널이 참조하고 있는 `HTMLElement`\n   * @type {HTMLElement}\n   * @readonly\n   */\n  public get element() { return this._el; }\n\n  public get rendered() { return this._rendered; }\n\n  /**\n   * @param {object} options An options object<ko>옵션 오브젝트</ko>\n   * @param {HTMLElement} [options.el] A `HTMLElement` panel's referencing<ko>패널이 참조하는 `HTMLElement`</ko>\n   * @param {number} [options.index] An initial index of the panel<ko>패널의 초기 인덱스</ko>\n   * @param {Constants.ALIGN | string | number} [options.align] An initial {@link Flicking#align align} value of the panel<ko>패널의 초기 {@link Flicking#align align}값</ko>\n   * @param {Flicking} [options.flicking] A Flicking instance panel's referencing<ko>패널이 참조하는 {@link Flicking} 인스턴스</ko>\n   */\n  public constructor(options: ElementPanelOptions) {\n    super(options);\n\n    this._el = options.el;\n    this._rendered = true;\n  }\n\n  public markForShow() {\n    this._rendered = true;\n  }\n\n  public markForHide() {\n    this._rendered = false;\n  }\n}\n\nexport default ElementPanel;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { getFlickingAttached, toArray } from \"../utils\";\nimport Panel, { PanelOptions } from \"../core/panel/Panel\";\nimport ElementPanel from \"../core/panel/ElementPanel\";\n\nimport Renderer from \"./Renderer\";\n\n/**\n *\n */\nclass VanillaRenderer extends Renderer {\n  // eslint-disable-next-line @typescript-eslint/require-await\n  public async render() {\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n    const cameraEl = flicking.camera.element;\n    const wasRenderedPanels = this._panels.filter(panel => panel.element.parentElement === cameraEl);\n\n    this._updateRenderingPanels();\n    const renderingPanels = this._getRenderingPanelsByOrder();\n\n    this._removePanelElements(wasRenderedPanels.filter(panel => !panel.rendered));\n    this._insertPanelElements(renderingPanels.filter(panel => panel.element.parentElement !== cameraEl), null);\n    this._resetPanelElementOrder(renderingPanels);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  public async forceRenderAllPanels() {\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n    const camera = flicking.camera;\n    const cameraElement = camera.element;\n    const fragment = document.createDocumentFragment();\n\n    this._panels.forEach(panel => fragment.appendChild(panel.element));\n\n    this._removeAllChildsFromCamera();\n\n    cameraElement.appendChild(fragment);\n  }\n\n  protected _collectPanels() {\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n\n    const cameraElement = flicking.camera.element;\n\n    // Remove all text nodes in the camera element\n    toArray(cameraElement.childNodes).forEach(node => {\n      if (node.nodeType === Node.TEXT_NODE) {\n        cameraElement.removeChild(node);\n      }\n    });\n\n    const align = this._getPanelAlign();\n    const cameraChilds = toArray(cameraElement.children);\n\n    this._panels = cameraChilds.map(\n      (el: HTMLElement, index: number) => new ElementPanel({ flicking, el, index, align })\n    );\n  }\n\n  protected _createPanel(el: HTMLElement, options: PanelOptions): ElementPanel {\n    return new ElementPanel({ el, ...options });\n  }\n\n  protected _insertPanelElements(panels: Panel[], nextSibling: Panel | null) {\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n    const camera = flicking.camera;\n    const cameraElement = camera.element;\n    const nextSiblingElement = nextSibling?.element || null;\n    const fragment = document.createDocumentFragment();\n\n    panels.forEach(panel => fragment.appendChild(panel.element));\n    cameraElement.insertBefore(fragment, nextSiblingElement);\n\n    return this;\n  }\n\n  protected _removePanelElements(panels: Panel[]): this {\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n    const cameraElement = flicking.camera.element;\n\n    panels.forEach(panel => {\n      cameraElement.removeChild(panel.element);\n    });\n\n    return this;\n  }\n\n  private _resetPanelElementOrder(panels: Panel[]) {\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n    const cameraEl = flicking.camera.element;\n\n    // We're using reversed panels here as last panel should be the last element of camera element\n    const reversedPanels = [...panels].reverse();\n    reversedPanels.forEach((panel, idx) => {\n      const nextPanel = reversedPanels[idx - 1];\n      const nextPanelEl = nextPanel ? nextPanel.element : null;\n\n      if (panel.element.nextElementSibling !== nextPanelEl) {\n        cameraEl.insertBefore(panel.element, nextPanelEl);\n      }\n    });\n  }\n\n  private _removeAllChildsFromCamera() {\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n    const cameraElement = flicking.camera.element;\n\n    // Remove other elements\n    while (cameraElement.firstChild) {\n      cameraElement.removeChild(cameraElement.firstChild);\n    }\n  }\n\n  private _getRenderingPanelsByOrder(): Panel[] {\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n    const panels = flicking.renderer.panels;\n\n    return panels.filter(panel => panel.rendered)\n      .sort((a, b) => (a.position + a.offset) - (b.position + b.offset));\n  }\n}\n\nexport default VanillaRenderer;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Panel from \"../core/panel/Panel\";\n\nimport Renderer from \"./Renderer\";\n\n/**\n *\n */\nabstract class ExternalRenderer extends Renderer {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  protected _insertPanelElements(panels: Panel[], nextSibling: Panel | null): void {\n    // DO NOTHING\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  protected _removePanelElements(panels: Panel[]): void {\n    // DO NOTHING\n  }\n}\n\nexport default ExternalRenderer;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Component, { ComponentEvent } from \"@egjs/component\";\n\nimport FlickingError from \"./core/FlickingError\";\nimport Viewport from \"./core/Viewport\";\nimport { Panel } from \"./core/panel\";\nimport { Control, SnapControl, SnapControlOptions, FreeControl, StrictControl, FreeControlOptions, StrictControlOptions } from \"./control\";\nimport { BoundCamera, Camera, CircularCamera, LinearCamera } from \"./camera\";\nimport { Renderer, VanillaRenderer, ExternalRenderer } from \"./renderer\";\nimport { EVENTS, ALIGN, MOVE_TYPE, DIRECTION } from \"./const/external\";\nimport * as ERROR from \"./const/error\";\nimport { findIndex, getElement, includes, parseElement } from \"./utils\";\nimport { HoldStartEvent, HoldEndEvent, MoveStartEvent, SelectEvent, MoveEvent, MoveEndEvent, WillChangeEvent, WillRestoreEvent, NeedPanelEvent, VisibleChangeEvent, ReachEdgeEvent, ReadyEvent, AfterResizeEvent, BeforeResizeEvent, ChangedEvent, RestoredEvent, PanelChangeEvent } from \"./type/event\";\nimport { LiteralUnion, ValueOf } from \"./type/internal\";\nimport { ElementLike, Plugin, Status, MoveTypeOptions } from \"./type/external\";\n\n/**\n * @interface\n */\nexport interface FlickingEvents {\n  [EVENTS.READY]: ReadyEvent;\n  [EVENTS.BEFORE_RESIZE]: BeforeResizeEvent;\n  [EVENTS.AFTER_RESIZE]: AfterResizeEvent;\n  [EVENTS.HOLD_START]: HoldStartEvent;\n  [EVENTS.HOLD_END]: HoldEndEvent;\n  [EVENTS.MOVE_START]: MoveStartEvent;\n  [EVENTS.MOVE]: MoveEvent;\n  [EVENTS.MOVE_END]: MoveEndEvent;\n  [EVENTS.WILL_CHANGE]: WillChangeEvent;\n  [EVENTS.CHANGED]: ChangedEvent;\n  [EVENTS.WILL_RESTORE]: WillRestoreEvent;\n  [EVENTS.RESTORED]: RestoredEvent;\n  [EVENTS.SELECT]: SelectEvent;\n  [EVENTS.NEED_PANEL]: NeedPanelEvent;\n  [EVENTS.VISIBLE_CHANGE]: VisibleChangeEvent;\n  [EVENTS.REACH_EDGE]: ReachEdgeEvent;\n  [EVENTS.PANEL_CHANGE]: PanelChangeEvent;\n}\n\n/**\n * @interface\n */\nexport interface FlickingOptions {\n  // UI / LAYOUT\n  align: LiteralUnion<ValueOf<typeof ALIGN>> | number | { panel: number | string; camera: number | string };\n  defaultIndex: number;\n  horizontal: boolean;\n  circular: boolean;\n  bound: boolean;\n  adaptive: boolean;\n  panelsPerView: number;\n  noPanelStyleOverride: boolean;\n  resizeOnContentsReady: boolean;\n  // EVENT\n  needPanelThreshold: number;\n  preventEventsBeforeInit: boolean;\n  // ANIMATION\n  deceleration: number;\n  duration: number;\n  easing: (x: number) => number;\n  // INPUT\n  inputType: string[];\n  moveType: ValueOf<typeof MOVE_TYPE> | MoveTypeOptions<ValueOf<typeof MOVE_TYPE>>;\n  threshold: number;\n  interruptable: boolean;\n  bounce: number | string | [number | string, number | string];\n  iOSEdgeSwipeThreshold: number;\n  preventClickOnDrag: boolean;\n  disableOnInit: boolean;\n  // PERFORMANCE\n  renderOnlyVisible: boolean;\n  // OTHERS\n  autoInit: boolean;\n  autoResize: boolean;\n  renderExternal: {\n    renderer: typeof ExternalRenderer;\n    rendererOptions: {[key: string]: any};\n  } | null;\n}\n\n/**\n * @extends Component\n * @support {\"ie\": \"9+(with polyfill)\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\", \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"4.X+\"}\n * @requires {@link https://github.com/naver/egjs-component|@egjs/component}\n * @requires {@link https://github.com/naver/egjs-axes|@egjs/axes}\n */\nclass Flicking extends Component<FlickingEvents> {\n  /**\n   * Version info string\n   * @ko 버전정보 문자열\n   * @type {string}\n   * @readonly\n   * @example\n   * ```ts\n   * Flicking.VERSION;  // ex) 4.0.0\n   * ```\n   */\n  public static VERSION = \"#__VERSION__#\";\n\n  // Core components\n  private _viewport: Viewport;\n  private _camera: Camera;\n  private _control: Control;\n  private _renderer: Renderer;\n\n  // Options\n  private _align: FlickingOptions[\"align\"];\n  private _defaultIndex: FlickingOptions[\"defaultIndex\"];\n  private _horizontal: FlickingOptions[\"horizontal\"];\n  private _circular: FlickingOptions[\"circular\"];\n  private _bound: FlickingOptions[\"bound\"];\n  private _adaptive: FlickingOptions[\"adaptive\"];\n  private _panelsPerView: FlickingOptions[\"panelsPerView\"];\n  private _noPanelStyleOverride: FlickingOptions[\"noPanelStyleOverride\"];\n  private _resizeOnContentsReady: FlickingOptions[\"resizeOnContentsReady\"];\n\n  private _needPanelThreshold: FlickingOptions[\"needPanelThreshold\"];\n  private _preventEventsBeforeInit: FlickingOptions[\"preventEventsBeforeInit\"];\n\n  private _deceleration: FlickingOptions[\"deceleration\"];\n  private _duration: FlickingOptions[\"duration\"];\n  private _easing: FlickingOptions[\"easing\"];\n\n  private _inputType: FlickingOptions[\"inputType\"];\n  private _moveType: FlickingOptions[\"moveType\"];\n  private _threshold: FlickingOptions[\"threshold\"];\n  private _interruptable: FlickingOptions[\"interruptable\"];\n  private _bounce: FlickingOptions[\"bounce\"];\n  private _iOSEdgeSwipeThreshold: FlickingOptions[\"iOSEdgeSwipeThreshold\"];\n  private _preventClickOnDrag: FlickingOptions[\"preventClickOnDrag\"];\n  private _disableOnInit: FlickingOptions[\"disableOnInit\"];\n\n  private _renderOnlyVisible: FlickingOptions[\"renderOnlyVisible\"];\n\n  private _autoResize: FlickingOptions[\"autoResize\"];\n  private _autoInit: FlickingOptions[\"autoInit\"];\n  private _renderExternal: FlickingOptions[\"renderExternal\"];\n\n  // Internal State\n  private _initialized: boolean;\n  private _plugins: Plugin[];\n\n  // Components\n  /**\n   * {@link Control} instance of the Flicking\n   * @ko 현재 Flicking에 활성화된 {@link Control} 인스턴스\n   * @type {Control}\n   * @default SnapControl\n   * @readonly\n   * @see Control\n   * @see SnapControl\n   * @see FreeControl\n   */\n  public get control() { return this._control; }\n  /**\n   * {@link Camera} instance of the Flicking\n   * @ko 현재 Flicking에 활성화된 {@link Camera} 인스턴스\n   * @type {Camera}\n   * @default LinearCamera\n   * @readonly\n   * @see Camera\n   * @see LinearCamera\n   * @see BoundCamera\n   * @see CircularCamera\n   */\n  public get camera() { return this._camera; }\n  /**\n   * {@link Renderer} instance of the Flicking\n   * @ko 현재 Flicking에 활성화된 {@link Renderer} 인스턴스\n   * @type {Renderer}\n   * @default VanillaRenderer\n   * @readonly\n   * @see Renderer\n   * @see VanillaRenderer\n   * @see ExternalRenderer\n   */\n  public get renderer() { return this._renderer; }\n  /**\n   * A component that manages viewport size\n   * @ko 뷰포트 크기 정보를 담당하는 컴포넌트\n   * @type {Viewport}\n   * @readonly\n   * @see Viewport\n   */\n  public get viewport() { return this._viewport; }\n  // Internal States\n  /**\n   * Whether Flicking's {@link Flicking#init init()} is called.\n   * This is `true` when {@link Flicking#init init()} is called, and is `false` after calling {@link Flicking#destroy destroy()}.\n   * @ko Flicking의 {@link Flicking#init init()}이 호출되었는지를 나타내는 멤버 변수.\n   * 이 값은 {@link Flicking#init init()}이 호출되었으면 `true`로 변하고, {@link Flicking#destroy destroy()}호출 이후에 다시 `false`로 변경됩니다.\n   * @type {boolean}\n   * @default false\n   * @readonly\n   */\n  public get initialized() { return this._initialized; }\n  /**\n   * Whether the `circular` option is enabled.\n   * The {@link Flicking#circular circular} option can't be enabled when sum of the panel sizes are too small.\n   * @ko {@link Flicking#circular circular} 옵션이 활성화되었는지 여부를 나타내는 멤버 변수.\n   * {@link Flicking#circular circular} 옵션은 패널의 크기의 합이 충분하지 않을 경우 비활성화됩니다.\n   * @type {boolean}\n   * @default false\n   * @readonly\n   */\n  public get circularEnabled() { return this._camera.controlParams.circular; }\n  /**\n   * Index number of the {@link Flicking#currentPanel currentPanel}\n   * @ko {@link Flicking#currentPanel currentPanel}의 인덱스 번호\n   * @type {number}\n   * @default 0\n   * @readonly\n   */\n  public get index() { return this._control.activeIndex; }\n  /**\n   * The root(`.flicking-viewport`) element\n   * @ko root(`.flicking-viewport`) 엘리먼트\n   * @type {HTMLElement}\n   * @readonly\n   */\n  public get element() { return this._viewport.element; }\n  /**\n   * Currently active panel\n   * @ko 현재 선택된 패널\n   * @type {Panel}\n   * @readonly\n   * @see Panel\n   */\n  public get currentPanel() { return this._control.activePanel; }\n  /**\n   * Array of panels\n   * @ko 전체 패널들의 배열\n   * @type {Panel[]}\n   * @readonly\n   * @see Panel\n   */\n  public get panels() { return this._renderer.panels; }\n  /**\n   * Count of panels\n   * @ko 전체 패널의 개수\n   * @type {number}\n   * @readonly\n   */\n  public get panelCount() { return this._renderer.panelCount; }\n  /**\n   * Array of panels that is visible at the current position\n   * @ko 현재 보이는 패널의 배열\n   * @type {Panel[]}\n   * @readonly\n   * @see Panel\n   */\n  public get visiblePanels() { return this._camera.visiblePanels; }\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {boolean}\n   * @readonly\n   */\n  public get animating() { return this._control.animating; }\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {boolean}\n   * @readonly\n   */\n  public get holding() { return this._control.holding; }\n  /**\n   * A current list of activated plugins\n   * @ko 현재 활성화된 플러그인 목록\n   * @type {Plugin[]}\n   * @readonly\n   */\n  public get activePlugins() { return this._plugins; }\n\n  // Options Getter\n  // UI / LAYOUT\n  /**\n   * Align position of the panels within viewport. You can set different values each for the panel and camera\n   * @ko 뷰포트 내에서 패널 정렬방식을 설정하는 옵션. 카메라와 패널 개별로 옵션을 설정할 수도 있습니다\n   * @type {ALIGN | string | number | { panel: string | number, camera: string | number }}\n   * @property {ALIGN | string | number} panel The align value for each {@link Panel}s<ko>개개의 {@link Panel}에 적용할 값</ko>\n   * @property {ALIGN | string | number} camera The align value for {@link Camera}<ko>{@link Camera}에 적용할 값</ko>\n   * @default \"center\"\n   * @example\n   * ```ts\n   * const possibleOptions = [\n   *   // Literal strings\n   *   \"prev\", \"center\", \"next\",\n   *   // % values, applied to both panel & camera\n   *   \"0%\", \"25%\", \"42%\",\n   *   // px values, arithmetic calculation with (+/-) is also allowed.\n   *   \"0px\", \"100px\", \"50% - 25px\",\n   *   // numbers, same to number + px (\"0px\", \"100px\")\n   *   0, 100, 1000,\n   *   // Setting a different value for panel & camera\n   *   { panel: \"10%\", camera: \"25%\" }\n   * ];\n   *\n   * possibleOptions.forEach(align => {\n   *   new Flicking(\"#el\", { align });\n   * });\n   * ```\n   */\n  public get align() { return this._align; }\n  /**\n   * Index of the panel to move when Flicking's {@link Flicking#init init()} is called. A zero-based integer\n   * @ko Flicking의 {@link Flicking#init init()}이 호출될 때 이동할 디폴트 패널의 인덱스로, 0부터 시작하는 정수입니다\n   * @type {number}\n   * @default 0\n   */\n  public get defaultIndex() { return this._defaultIndex; }\n  /**\n   * Direction of panel movement (true: horizontal, false: vertical)\n   * @ko 패널 이동 방향 (true: 가로방향, false: 세로방향)\n   * @type {boolean}\n   * @default true\n   */\n  public get horizontal() { return this._horizontal; }\n  /**\n   * Enables circular(continuous loop) mode, which connects first/last panel for continuous scrolling.\n   * @ko 순환 모드를 활성화합니다. 순환 모드에서는 양 끝의 패널이 서로 연결되어 끊김없는 스크롤이 가능합니다.\n   * @type {boolean}\n   * @default false\n   */\n  public get circular() { return this._circular; }\n  /**\n   * Prevent the view(camera element) from going out of the first/last panel, so it won't show empty spaces before/after the first/last panel\n   * Only can be enabled when `circular=false`\n   * @ko 뷰(카메라 엘리먼트)가 첫번째와 마지막 패널 밖으로 넘어가지 못하게 하여, 첫번째/마지막 패널 전/후의 빈 공간을 보이지 않도록 하는 옵션입니다\n   * `circular=false`인 경우에만 사용할 수 있습니다\n   * @type {boolean}\n   * @default false\n   */\n  public get bound() { return this._bound; }\n  /**\n   * Update height of the viewport element after movement same to the height of the panel below. This can be only enabled when `horizontal=true`\n   * @ko 이동한 후 뷰포트 엘리먼트의 크기를 현재 패널의 높이와 동일하게 설정합니다. `horizontal=true`인 경우에만 사용할 수 있습니다.\n   * @type {boolean}\n   * @default false\n   */\n  public get adaptive() { return this._adaptive; }\n  /**\n   * A visible number of panels on viewport. Enabling this option will automatically resize panel size\n   * @ko 한 화면에 보이는 패널의 개수. 이 옵션을 활성화할 경우 패널의 크기를 강제로 재조정합니다\n   * @type {number}\n   * @default -1\n   */\n  public get panelsPerView() { return this._panelsPerView; }\n  /**\n   * Enabling this option will not change `width/height` style of the panels if {@link Flicking#panelsPerView} is enabled.\n   * This behavior can be useful in terms of performance when you're manually managing all panel sizes\n   * @ko 이 옵션을 활성화할 경우, {@link Flicking#panelsPerView} 옵션이 활성화되었을 때 패널의 `width/height` 스타일을 변경하지 않도록 설정합니다.\n   * 모든 패널들의 크기를 직접 관리하고 있을 경우, 이 옵션을 활성화하면 성능면에서 유리할 수 있습니다\n   * @type {boolean}\n   * @default false\n   */\n  public get noPanelStyleOverride() { return this._noPanelStyleOverride; }\n  /**\n   * Enabling this option will automatically call {@link Flicking#resize} when all image/video inside panels are loaded.\n   * This can be useful when you have contents inside Flicking that changes its size when it's loaded\n   * @ko 이 옵션을 활성화할 경우, Flicking 패널 내부의 이미지/비디오들이 로드되었을 때 자동으로 {@link Flicking#resize}를 호출합니다.\n   * 이 동작은 Flicking 내부에 로드 전/후로 크기가 변하는 콘텐츠를 포함하고 있을 때 유용하게 사용하실 수 있습니다.\n   * @type {boolean}\n   * @default false\n   */\n  public get resizeOnContentsReady() { return this._resizeOnContentsReady; }\n  // EVENTS\n  /**\n   * A Threshold from viewport edge before triggering `needPanel` event\n   * @ko `needPanel`이벤트가 발생하기 위한 뷰포트 끝으로부터의 최대 거리\n   * @type {number}\n   * @default 0\n   */\n  public get needPanelThreshold() { return this._needPanelThreshold; }\n  /**\n   * When enabled, events are not triggered before `ready` when initializing\n   * @ko 활성화할 경우 초기화시 `ready` 이벤트 이전의 이벤트가 발생하지 않습니다.\n   * @type {boolean}\n   * @default true\n   */\n  public get preventEventsBeforeInit() { return this._preventEventsBeforeInit; }\n  // ANIMATION\n  /**\n   * Deceleration value for panel movement animation which is triggered by user input. A higher value means a shorter animation time\n   * @ko 사용자의 동작으로 가속도가 적용된 패널 이동 애니메이션의 감속도. 값이 높을수록 애니메이션 실행 시간이 짧아집니다\n   * @type {number}\n   * @default 0.0075\n   */\n  public get deceleration() { return this._deceleration; }\n  /**\n   * An easing function applied to the panel movement animation. Default value is `easeOutCubic`\n   * @ko 패널 이동 애니메이션에 적용할 easing 함수. 기본값은 `easeOutCubic`이다\n   * @type {function}\n   * @default x => 1 - Math.pow(1 - x, 3)\n   * @see Easing Functions Cheat Sheet {@link http://easings.net/} <ko>이징 함수 Cheat Sheet {@link http://easings.net/}</ko>\n   */\n  public get easing() { return this._easing; }\n  /**\n   * Default duration of the animation (ms)\n   * @ko 디폴트 애니메이션 재생 시간 (ms)\n   * @type {number}\n   * @default 500\n   */\n  public get duration() { return this._duration; }\n  // INPUT\n  /**\n   * Types of input devices to enable\n   * @ko 활성화할 입력 장치 종류\n   * @type {string[]}\n   * @default [\"touch\", \"mouse\"]\n   * @see {@link https://naver.github.io/egjs-axes/release/latest/doc/global.html#PanInputOption Possible values (PanInputOption#inputType)}\n   * <ko>{@link https://naver.github.io/egjs-axes/release/latest/doc/global.html#PanInputOption 가능한 값들 (PanInputOption#inputType)}</ko>\n   */\n  public get inputType() { return this._inputType; }\n  /**\n   * Movement style by user input. This will change instance type of {@link Flicking#control}\n   * You can use the values of the constant {@link MOVE_TYPE}\n   * @ko 사용자 입력에 의한 이동 방식. 이 값에 따라 {@link Flicking#control}의 인스턴스 타입이 결정됩니다\n   * 상수 {@link MOVE_TYPE}에 정의된 값들을 이용할 수 있습니다\n   * @type {MOVE_TYPE | Pair<string, object>}\n   * @default \"snap\"\n   * @example\n   * |moveType|control|options|\n   * |:---:|:---:|:---:|\n   * |\"snap\"|{@link SnapControl}||\n   * |\"freeScroll\"|{@link FreeControl}|{@link FreeControlOptions}|\n   *\n   * ```ts\n   * import Flicking, { MOVE_TYPE } from \"@egjs/flicking\";\n   *\n   * const flicking = new Flicking({\n   *   moveType: MOVE_TYPE.SNAP\n   * });\n   * ```\n   *\n   * ```ts\n   * const flicking = new Flicking({\n   *   // If you want more specific settings for the moveType\n   *   // [moveType, options for that moveType]\n   *   // In this case, it's [\"freeScroll\", FreeControlOptions]\n   *   moveType: [MOVE_TYPE.FREE_SCROLL, { stopAtEdge: true }]\n   * });\n   * ```\n   */\n  public get moveType() { return this._moveType; }\n  /**\n   * Movement threshold to change panel (unit: px). It should be dragged above the threshold to change the current panel.\n   * @ko 패널 변경을 위한 이동 임계값 (단위: px). 주어진 값 이상으로 스크롤해야만 패널 변경이 가능하다.\n   * @type {number}\n   * @default 40\n   */\n  public get threshold() { return this._threshold; }\n  /**\n   * Set animation to be interruptable by click/touch.\n   * @ko 사용자의 클릭/터치로 인해 애니메이션을 도중에 멈출 수 있도록 설정합니다.\n   * @type {boolean}\n   * @default true\n   */\n  public get interruptable() { return this._interruptable; }\n  /**\n   * The size value of the bounce area. Only can be enabled when `circular=false`.\n   * You can set different bounce value for prev/next direction by using array.\n   * `number` for px value, and `string` for px, and % value relative to viewport size.\n   * You have to call {@link Control#updateInput} after changing this to take effect.\n   * @ko Flicking이 최대 영역을 넘어서 갈 수 있는 최대 크기. `circular=false`인 경우에만 사용할 수 있습니다.\n   * 배열을 통해 prev/next 방향에 대해 서로 다른 바운스 값을 지정할 수 있습니다.\n   * `number`를 통해 px값을, `stirng`을 통해 px 혹은 뷰포트 크기 대비 %값을 사용할 수 있습니다.\n   * 이 값을 변경시 {@link Control#updateInput}를 호출해야 합니다.\n   * @type {string | number | Array<string | number>}\n   * @default \"20%\"\n   * @example\n   * ```ts\n   * const possibleOptions = [\n   *   // % values, relative to viewport element(\".flicking-viewport\")'s size\n   *   \"0%\", \"25%\", \"42%\",\n   *   // px values, arithmetic calculation with (+/-) is also allowed.\n   *   \"0px\", \"100px\", \"50% - 25px\",\n   *   // numbers, same to number + px (\"0px\", \"100px\")\n   *   0, 100, 1000\n   * ];\n   * ```\n   *\n   * @example\n   * ```ts\n   * const flicking = new Flicking(\"#el\", { bounce: \"20%\" });\n   *\n   * flicking.bounce = \"100%\";\n   * flicking.control.updateInput(); // Call this to update!\n   * ```\n   */\n  public get bounce() { return this._bounce; }\n  /**\n   * Size of the area from the right edge in iOS safari (in px) which enables swipe-back or swipe-forward\n   * @ko iOS Safari에서 swipe를 통한 뒤로가기/앞으로가기를 활성화하는 오른쪽 끝으로부터의 영역의 크기 (px)\n   * @type {number}\n   * @default 30\n   */\n  public get iOSEdgeSwipeThreshold() { return this._iOSEdgeSwipeThreshold; }\n  /**\n   * Automatically prevent `click` event if the user has dragged at least a single pixel on the viewport element\n   * @ko 사용자가 뷰포트 영역을 1픽셀이라도 드래그했을 경우 자동으로 {@link https://developer.mozilla.org/ko/docs/Web/API/Element/click_event click} 이벤트를 취소합니다\n   * @type {boolean}\n   * @default true\n   */\n  public get preventClickOnDrag() { return this._preventClickOnDrag; }\n  /**\n   * Automatically call {@link Flicking#disableInput disableInput()} on initialization\n   * @ko Flicking init시에 {@link Flicking#disableInput disableInput()}을 바로 호출합니다\n   * @type {boolean}\n   * @default false\n   */\n  public get disableOnInit() { return this._disableOnInit; }\n  // PERFORMANCE\n  /**\n   * Whether to render visible panels only. This can dramatically increase performance when there're many panels.\n   * @ko 보이는 패널만 렌더링할지 여부를 설정합니다. 패널이 많을 경우에 퍼포먼스를 크게 향상시킬 수 있습니다.\n   * @type {boolean}\n   * @default false\n   */\n  public get renderOnlyVisible() { return this._renderOnlyVisible; }\n  // OTHERS\n  /**\n   * Call {@link Flicking#init init()} automatically when creating Flicking's instance\n   * @ko Flicking 인스턴스를 생성할 때 자동으로 {@link Flicking#init init()}를 호출합니다\n   * @type {boolean}\n   * @default true\n   * @readonly\n   */\n  public get autoInit() { return this._autoInit; }\n  /**\n   * Attach Flicking's {@link Flicking#resize resize} method to window's resize event.\n   * Flicking will automatically call {@link Flicking#resize resize} window size and orientation change.\n   * @ko Flicking의 {@link Flicking#resize resize} 메소드를 window의 resize 이벤트 핸들러로 등록합니다.\n   * 설정시 window 창 크기 및 orientation 변경에 의해 자동으로 {@link Flicking#resize resize}를 호출합니다.\n   * @type {boolean}\n   * @default true\n   */\n  public get autoResize() { return this._autoResize; }\n  /**\n   * This is an option for the frameworks(React, Vue, Angular, ...). Don't set it as it's automatically managed by Flicking.\n   * @ko 프레임워크(React, Vue, Angular, ...)에서만 사용하는 옵션으로, 자동으로 설정되므로 따로 사용하실 필요 없습니다!\n   * @type {boolean}\n   * @default false\n   * @internal\n   * @readonly\n   */\n  public get renderExternal() { return this._renderExternal; }\n\n  // Options Setter\n  // UI / LAYOUT\n  public set align(val: FlickingOptions[\"align\"]) {\n    this._align = val;\n    this._renderer.align = val;\n    this._camera.align = val;\n  }\n\n  public set defaultIndex(val: FlickingOptions[\"defaultIndex\"]) { this._defaultIndex = val; }\n  public set horizontal(val: FlickingOptions[\"horizontal\"]) { this._horizontal = val; }\n  public set circular(val: FlickingOptions[\"circular\"]) { this._circular = val; }\n  public set bound(val: FlickingOptions[\"bound\"]) { this._bound = val; }\n  public set adaptive(val: FlickingOptions[\"adaptive\"]) { this._adaptive = val; }\n  public set panelsPerView(val: FlickingOptions[\"panelsPerView\"]) { this._panelsPerView = val; }\n  public set noPanelStyleOverride(val: FlickingOptions[\"noPanelStyleOverride\"]) { this._noPanelStyleOverride = val; }\n  public set resizeOnContentsReady(val: FlickingOptions[\"resizeOnContentsReady\"]) { this._resizeOnContentsReady = val; }\n  // EVENTS\n  public set needPanelThreshold(val: FlickingOptions[\"needPanelThreshold\"]) { this._needPanelThreshold = val; }\n  public set preventEventsBeforeInit(val: FlickingOptions[\"preventEventsBeforeInit\"]) { this._preventEventsBeforeInit = val; }\n  // ANIMATION\n  public set deceleration(val: FlickingOptions[\"deceleration\"]) { this._deceleration = val; }\n  public set easing(val: FlickingOptions[\"easing\"]) { this._easing = val; }\n  public set duration(val: FlickingOptions[\"duration\"]) { this._duration = val; }\n  // INPUT\n  public set inputType(val: FlickingOptions[\"inputType\"]) { this._inputType = val; }\n  public set moveType(val: FlickingOptions[\"moveType\"]) { this._moveType = val; }\n  public set threshold(val: FlickingOptions[\"threshold\"]) { this._threshold = val; }\n  public set interruptable(val: FlickingOptions[\"interruptable\"]) { this._interruptable = val; }\n  public set bounce(val: FlickingOptions[\"bounce\"]) { this._bounce = val; }\n  public set iOSEdgeSwipeThreshold(val: FlickingOptions[\"iOSEdgeSwipeThreshold\"]) { this._iOSEdgeSwipeThreshold = val; }\n  public set preventClickOnDrag(val: FlickingOptions[\"preventClickOnDrag\"]) {\n    const prevVal = this._preventClickOnDrag;\n\n    if (val === prevVal) return;\n\n    const controller = this._control.controller;\n\n    if (val) {\n      controller.addPreventClickHandler();\n    } else {\n      controller.removePreventClickHandler();\n    }\n\n    this._preventClickOnDrag = val;\n  }\n\n  public set disableOnInit(val: FlickingOptions[\"disableOnInit\"]) { this._disableOnInit = val; }\n  // PERFORMANCE\n  public set renderOnlyVisible(val: FlickingOptions[\"renderOnlyVisible\"]) { this._renderOnlyVisible = val; }\n  // OTHERS\n  public set autoResize(val: FlickingOptions[\"autoResize\"]) { this._autoResize = val; }\n\n  /**\n   * @param root A root HTMLElement to initialize Flicking on it. When it's a typeof `string`, it should be a css selector string\n   * <ko>Flicking을 초기화할 HTMLElement로, `string` 타입으로 지정시 css 선택자 문자열을 지정해야 합니다.</ko>\n   * @param {object} [options={}] An options object for Flicking.<ko>Flicking에 적용할 옵션 오브젝트</ko>\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE WRONG_TYPE}|When the root is not either string or HTMLElement|\n   * |{@link ERROR_CODE ELEMENT_NOT_FOUND}|When the element with given CSS selector does not exist|\n   * <ko>\n   *\n   * |code|조건|\n   * |---|---|\n   * |{@link ERROR_CODE WRONG_TYPE}|루트 엘리먼트가 string이나 HTMLElement가 아닐 경우|\n   * |{@link ERROR_CODE ELEMENT_NOT_FOUND}|주어진 CSS selector로 엘리먼트를 찾지 못했을 경우|\n   *\n   * </ko>\n   * @example\n   * ```ts\n   * import Flicking from \"@egjs/flicking\";\n   *\n   * // Creating new instance of Flicking with HTMLElement\n   * const flicking = new Flicking(document.querySelector(\".flicking-viewport\"), { circular: true });\n   *\n   * // Creating new instance of Flicking with CSS selector\n   * const flicking2 = new Flicking(\".flicking-viewport\", { circular: true });\n   * ```\n   */\n  public constructor(root: HTMLElement | string, {\n    align = ALIGN.CENTER,\n    defaultIndex = 0,\n    horizontal = true,\n    circular = false,\n    bound = false,\n    adaptive = false,\n    panelsPerView = -1,\n    noPanelStyleOverride = false,\n    resizeOnContentsReady = false,\n    needPanelThreshold = 0,\n    preventEventsBeforeInit = true,\n    deceleration = 0.0075,\n    duration = 500,\n    easing = x => 1 - Math.pow(1 - x, 3),\n    inputType = [\"mouse\", \"touch\"],\n    moveType = \"snap\",\n    threshold = 40,\n    interruptable = true,\n    bounce = \"20%\",\n    iOSEdgeSwipeThreshold = 30,\n    preventClickOnDrag = true,\n    disableOnInit = false,\n    renderOnlyVisible = false,\n    autoInit = true,\n    autoResize = true,\n    renderExternal = null\n  }: Partial<FlickingOptions> = {}) {\n    super();\n\n    // Internal states\n    this._initialized = false;\n    this._plugins = [];\n\n    // Bind options\n    this._align = align;\n    this._defaultIndex = defaultIndex;\n    this._horizontal = horizontal;\n    this._circular = circular;\n    this._bound = bound;\n    this._adaptive = adaptive;\n    this._panelsPerView = panelsPerView;\n    this._noPanelStyleOverride = noPanelStyleOverride;\n    this._resizeOnContentsReady = resizeOnContentsReady;\n    this._needPanelThreshold = needPanelThreshold;\n    this._preventEventsBeforeInit = preventEventsBeforeInit;\n    this._deceleration = deceleration;\n    this._duration = duration;\n    this._easing = easing;\n    this._inputType = inputType;\n    this._moveType = moveType;\n    this._threshold = threshold;\n    this._interruptable = interruptable;\n    this._bounce = bounce;\n    this._iOSEdgeSwipeThreshold = iOSEdgeSwipeThreshold;\n    this._preventClickOnDrag = preventClickOnDrag;\n    this._disableOnInit = disableOnInit;\n    this._renderOnlyVisible = renderOnlyVisible;\n    this._autoResize = autoResize;\n    this._autoInit = autoInit;\n    this._renderExternal = renderExternal;\n\n    // Create core components\n    this._viewport = new Viewport(getElement(root));\n    this._renderer = this._createRenderer();\n    this._camera = this._createCamera();\n    this._control = this._createControl();\n\n    this.resize = this.resize.bind(this);\n\n    if (this._autoInit) {\n      void this.init();\n    }\n  }\n\n  /**\n   * Initialize Flicking and move to the default index\n   * This is automatically called on Flicking's constructor when `autoInit` is true(default)\n   * @ko Flicking을 초기화하고, 디폴트 인덱스로 이동합니다\n   * 이 메소드는 `autoInit` 옵션이 true(default)일 경우 Flicking이 생성될 때 자동으로 호출됩니다\n   * @fires Flicking#ready\n   * @return {this}\n   */\n  public async init(): Promise<void> {\n    if (this._initialized) return;\n\n    const camera = this._camera;\n    const renderer = this._renderer;\n    const control = this._control;\n    const originalTrigger = this.trigger;\n    const preventEventsBeforeInit = this._preventEventsBeforeInit;\n\n    camera.init(this);\n    renderer.init(this);\n    control.init(this);\n\n    if (preventEventsBeforeInit) {\n      this.trigger = () => this;\n    }\n\n    await this.resize();\n\n    // Look at initial panel\n    await this._moveToInitialPanel();\n\n    if (this._autoResize) {\n      window.addEventListener(\"resize\", this.resize);\n    }\n    if (this._preventClickOnDrag) {\n      control.controller.addPreventClickHandler();\n    }\n    if (this._disableOnInit) {\n      this.disableInput();\n    }\n    renderer.checkPanelContentsReady(renderer.panels);\n\n    this._plugins.forEach(plugin => plugin.init(this));\n\n    // Done initializing & emit ready event\n    this._initialized = true;\n    if (preventEventsBeforeInit) {\n      this.trigger = originalTrigger;\n    }\n    this.trigger(new ComponentEvent(EVENTS.READY));\n\n    return;\n  }\n\n  /**\n   * Destroy Flicking and remove all event handlers\n   * @ko Flicking과 하위 컴포넌트들을 초기 상태로 되돌리고, 부착된 모든 이벤트 핸들러를 제거합니다\n   * @return {void}\n   */\n  public destroy(): void {\n    this.off();\n    window.removeEventListener(\"resize\", this.resize);\n\n    this._control.destroy();\n    this._camera.destroy();\n    this._renderer.destroy();\n\n    this._plugins.forEach(plugin => plugin.destroy());\n\n    this._initialized = false;\n  }\n\n  /**\n   * Move to the previous panel (current index - 1)\n   * @ko 이전 패널로 이동합니다 (현재 인덱스 - 1)\n   * @param {number} [duration={@link Flicking#duration options.duration}] Duration of the panel movement animation (unit: ms)<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>\n   * @async\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|When the previous panel does not exist|\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|When the animation is already playing|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the any of the event's `stop()` is called|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|이전 패널이 존재하지 않을 경우|\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|애니메이션이 이미 진행중인 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the previous panel<ko>이전 패널 도달시에 resolve되는 Promise</ko>\n   */\n  public prev(duration: number = this._duration): Promise<void> {\n    return this.moveTo(this._control.activePanel?.prev()?.index ?? -1, duration, DIRECTION.PREV);\n  }\n\n  /**\n   * Move to the next panel (current index + 1)\n   * @ko 다음 패널로 이동합니다 (현재 인덱스 + 1)\n   * @param {number} [duration={@link Flicking#duration options.duration}] Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>\n   * @async\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|When the next panel does not exist|\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|When the animation is already playing|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the any of the event's `stop()` is called|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|다음 패널이 존재하지 않을 경우|\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|애니메이션이 이미 진행중인 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the next panel<ko>다음 패널 도달시에 resolve되는 Promise</ko>\n   */\n  public next(duration: number = this._duration) {\n    return this.moveTo(this._control.activePanel?.next()?.index ?? this._renderer.panelCount, duration, DIRECTION.NEXT);\n  }\n\n  /**\n   * Move to the panel with given index\n   * @ko 주어진 인덱스에 해당하는 패널로 이동합니다\n   * @param {number} index The index of the panel to move<ko>이동할 패널의 인덱스</ko>\n   * @param {number} [duration={@link Flicking#duration options.duration}] Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {DIRECTION} [direction=DIRECTION.NONE] Direction to move, only available in the {@link Flicking#circular circular} mode<ko>이동할 방향. {@link Flicking#circular circular} 옵션 활성화시에만 사용 가능합니다</ko>\n   * @async\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|When the root is not either string or HTMLElement|\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|When the animation is already playing|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the any of the event's `stop()` is called|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|해당 인덱스를 가진 패널이 존재하지 않을 경우|\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|애니메이션이 이미 진행중인 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target panel<ko>해당 패널 도달시에 resolve되는 Promise</ko>\n   */\n  public moveTo(index: number, duration: number = this._duration, direction: ValueOf<typeof DIRECTION> = DIRECTION.NONE) {\n    const renderer = this._renderer;\n    const panelCount = renderer.panelCount;\n\n    const panel = renderer.getPanel(index);\n\n    if (!panel) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.INDEX_OUT_OF_RANGE(index, 0, panelCount - 1), ERROR.CODE.INDEX_OUT_OF_RANGE));\n    }\n\n    if (this._control.animating) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.ANIMATION_ALREADY_PLAYING, ERROR.CODE.ANIMATION_ALREADY_PLAYING));\n    }\n\n    return this._control.moveToPanel(panel, {\n      duration,\n      direction\n    });\n  }\n\n  /**\n   * Return the {@link Panel} at the given index. `null` if it doesn't exists.\n   * @ko 주어진 인덱스에 해당하는 {@link Panel}을 반환합니다. 주어진 인덱스에 해당하는 패널이 존재하지 않을 경우 `null`을 반환합니다.\n   * @return {Panel | null} Panel at the given index<ko>주어진 인덱스에 해당하는 패널</ko>\n   * @see Panel\n   * @example\n   * ```ts\n   * const panel = flicking.getPanel(0);\n   * // Which is a shorthand to...\n   * const samePanel = flicking.panels[0];\n   * ```\n   */\n  public getPanel(index: number): Panel | null {\n    return this._renderer.getPanel(index);\n  }\n\n  /**\n   * Enable input from the user (mouse/touch)\n   * @ko 사용자의 입력(마우스/터치)를 활성화합니다\n   * @return {this}\n   */\n  public enableInput(): this {\n    this._control.enable();\n    return this;\n  }\n\n  /**\n   * Disable input from the user (mouse/touch)\n   * @ko 사용자의 입력(마우스/터치)를 막습니다\n   * @return {this}\n   */\n  public disableInput(): this {\n    this._control.disable();\n    return this;\n  }\n\n  /**\n   * Get current flicking status. You can restore current state by giving returned value to {@link Flicking#setStatus setStatus()}\n   * @ko 현재 상태를 반환합니다. 반환받은 값을 {@link Flicking#setStatus setStatus()} 메소드의 인자로 지정하면 현재 상태를 복원할 수 있습니다\n   * @param {object} options Status retrieving options<ko>Status 반환 옵션</ko>\n   * @param {boolean} [options.index=true] Include current panel index to the returning status. Camera will automatically move to the given index when the {@link Flicking#setStatus setStatus} is called<ko>현재 패널 인덱스를 반환값에 포함시킵니다. {@link Flicking#setStatus setStatus} 호출시 자동으로 해당 인덱스로 카메라를 움직입니다</ko>\n   * @param {boolean} [options.position=true] Include camera position to the returning status. This works only when the {@link Flicking#moveType moveType} is `freeScroll`<ko>카메라의 현재 위치를 반환값에 포함시킵니다. 이 옵션은 {@link Flicking#moveType moveType}이 `freeScroll`일 경우에만 동작합니다</ko>\n   * @param {boolean} [options.includePanelHTML=false] Include panel's `outerHTML` to the returning status<ko>패널의 `outerHTML`을 반환값에 포함시킵니다</ko>\n   * @param {boolean} [options.visiblePanelsOnly=false] Include only {@link Flicking#visiblePanel visiblePanel}'s HTML. This option is available only when the `includePanelHTML` is true\n   * <ko>현재 보이는 패널({@link Flicking#visiblePanel visiblePanel})의 HTML만 반환합니다. `includePanelHTML`이 `true`일 경우에만 동작합니다.</ko>\n   * @return {Partial<Status>} An object with current status value information<ko>현재 상태값 정보를 가진 객체.</ko>\n   */\n  public getStatus({\n    index = true,\n    position = true,\n    includePanelHTML = false,\n    visiblePanelsOnly = false\n  }: Partial<{\n    index: boolean;\n    position: boolean;\n    includePanelHTML: boolean;\n    visiblePanelsOnly: boolean;\n  }> = {}): Status {\n    const camera = this._camera;\n    const panels = visiblePanelsOnly ? this.visiblePanels : this.panels;\n\n    const status: Status = {\n      panels: panels.map(panel => {\n        const panelInfo: Status[\"panels\"][0] = { index: panel.index };\n\n        if (includePanelHTML) {\n          panelInfo.html = panel.element.outerHTML;\n        }\n\n        return panelInfo;\n      })\n    };\n\n    if (index) {\n      status.index = this.index;\n    }\n    if (position) {\n      const nearestAnchor = camera.findNearestAnchor(camera.position);\n\n      if (nearestAnchor) {\n        status.position = {\n          panel: nearestAnchor.panel.index,\n          progressInPanel: camera.getProgressInPanel(nearestAnchor.panel)\n        };\n      }\n\n    }\n\n    if (visiblePanelsOnly) {\n      const visiblePanels = this.visiblePanels;\n\n      status.visibleOffset = visiblePanels[0]?.index ?? 0;\n    }\n\n    return status;\n  }\n\n  /**\n   * Restore to the state of the given {@link Status}\n   * @ko 주어진 {@link Status}의 상태로 복원합니다\n   * @param {Partial<Status>} status Status value to be restored. You should use the return value of the {@link Flicking#getStatus getStatus()} method<ko>복원할 상태 값. {@link Flicking#getStatus getStatus()} 메서드의 반환값을 지정하면 됩니다</ko>\n   * @return {void}\n   */\n  public setStatus(status: Status): void {\n    if (!this._initialized) {\n      throw new FlickingError(ERROR.MESSAGE.NOT_INITIALIZED, ERROR.CODE.NOT_INITIALIZED);\n    }\n\n    const {\n      index,\n      position,\n      visibleOffset,\n      panels\n    } = status;\n\n    const renderer = this._renderer;\n    const control = this._control;\n\n    // Can't add/remove panels on external rendering\n    if (panels[0]?.html && !this._renderExternal) {\n      renderer.batchRemove({ index: 0, deleteCount: this.panels.length });\n      renderer.batchInsert({ index: 0, elements: parseElement(panels.map(panel => panel.html!)) });\n    }\n\n    if (index) {\n      const panelIndex = visibleOffset\n        ? index - visibleOffset\n        : index;\n\n      void this.moveTo(panelIndex, 0).catch(() => void 0);\n    }\n\n    if (position && this._moveType === MOVE_TYPE.FREE_SCROLL) {\n      const { panel, progressInPanel } = position;\n      const panelIndex = visibleOffset\n        ? panel - visibleOffset\n        : panel;\n      const panelRange = renderer.panels[panelIndex].range;\n      const newCameraPos = panelRange.min + (panelRange.max - panelRange.min) * progressInPanel;\n\n      void control.moveToPosition(newCameraPos, 0).catch(() => void 0);\n    }\n  }\n\n  /**\n   * Add plugins that can have different effects on Flicking\n   * @ko 플리킹에 다양한 효과를 부여할 수 있는 플러그인을 추가합니다\n   * @param {...Plugin} plugins The plugin(s) to add<ko>추가할 플러그인(들)</ko>\n   * @return {this}\n   * @see https://github.com/naver/egjs-flicking-plugins\n   */\n  public addPlugins(...plugins: Plugin[]) {\n    if (this._initialized) {\n      plugins.forEach(item => item.init(this));\n    }\n\n    this._plugins.push(...plugins);\n\n    return this;\n  }\n\n  /**\n   * Remove plugins from Flicking.\n   * @ko 플리킹으로부터 플러그인들을 제거합니다.\n   * @param {...Plugin} plugin The plugin(s) to remove.<ko>제거 플러그인(들).</ko>\n   * @return {this}\n   * @see https://github.com/naver/egjs-flicking-plugins\n   */\n  public removePlugins(...plugins: Plugin[]) {\n    plugins.forEach(item => {\n      const foundIndex = findIndex(this._plugins, val => val === item);\n\n      if (foundIndex >= 0) {\n        item.destroy();\n        this._plugins.splice(foundIndex, 1);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Update viewport/panel sizes\n   * @ko 패널 및 뷰포트의 크기를 갱신합니다\n   * @method\n   * @fires Flicking#beforeResize\n   * @fires Flicking#afterResize\n   * @return {this}\n   */\n  public async resize(): Promise<void> {\n    const viewport = this._viewport;\n    const renderer = this._renderer;\n    const camera = this._camera;\n    const control = this._control;\n\n    const activePanel = control.activePanel;\n    const prevWidth = viewport.width;\n    const prevHeight = viewport.height;\n    const prevProgressInPanel = activePanel\n      ? camera.getProgressInPanel(activePanel)\n      : 0;\n\n    this.trigger(new ComponentEvent(EVENTS.BEFORE_RESIZE, {\n      width: prevWidth,\n      height: prevHeight,\n      element: viewport.element\n    }));\n\n    viewport.resize();\n    await renderer.forceRenderAllPanels(); // Render all panel elements, to update sizes\n    renderer.updatePanelSize();\n    camera.updateAlignPos();\n    camera.updateRange();\n    camera.updateAnchors();\n    await renderer.render();\n\n    if (control.animating) {\n      // TODO:\n    } else {\n      control.updatePosition(prevProgressInPanel);\n      control.updateInput();\n    }\n\n    const newWidth = viewport.width;\n    const newHeight = viewport.height;\n    const sizeChanged = newWidth !== prevWidth || newHeight !== prevHeight;\n\n    this.trigger(new ComponentEvent(EVENTS.AFTER_RESIZE, {\n      width: viewport.width,\n      height: viewport.height,\n      prev: {\n        width: prevWidth,\n        height: prevHeight\n      },\n      sizeChanged,\n      element: viewport.element\n    }));\n  }\n\n  /**\n   * Add new panels after the last panel\n   * @ko 패널 목록의 제일 끝에 새로운 패널들을 추가합니다\n   * @param {ElementLike | ElementLike[]} element A new HTMLElement, a outerHTML of element, or an array of both\n   * <ko>새로운 HTMLElement, 혹은 엘리먼트의 outerHTML, 혹은 그것들의 배열</ko>\n   * @return {Panel[]} An array of appended panels<ko>추가된 패널들의 배열</ko>\n   * @see Panel\n   * @see ElementLike\n   * @throws {FlickingError} {@link ERROR_CODE ERROR_CODE.NOT_ALLOWED_IN_FRAMEWORK} if called on frameworks (React, Angular, Vue...)\n   * @example\n   * ```ts\n   * const flicking = new Flicking(\"#flick\");\n   * // These are possible parameters\n   * flicking.append(document.createElement(\"div\"));\n   * flicking.append(\"\\<div\\>Panel\\</div\\>\");\n   * flicking.append([\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]);\n   * // Even this is possible\n   * flicking.append(\"\\<div\\>Panel 1\\</div\\>\\<div\\>Panel 2\\</div\\>\");\n   * ```\n   */\n  public append(element: ElementLike | ElementLike[]): Panel[] {\n    return this.insert(this._renderer.panelCount, element);\n  }\n\n  /**\n   * Add new panels before the first panel\n   * This will increase index of panels after by the number of panels added\n   * @ko 패널 목록의 제일 앞(index 0)에 새로운 패널들을 추가합니다\n   * 추가한 패널의 개수만큼 기존 패널들의 인덱스가 증가합니다.\n   * @param {ElementLike | ElementLike[]} element A new HTMLElement, a outerHTML of element, or an array of both\n   * <ko>새로운 HTMLElement, 혹은 엘리먼트의 outerHTML, 혹은 그것들의 배열</ko>\n   * @return {Panel[]} An array of prepended panels<ko>추가된 패널들의 배열</ko>\n   * @see Panel\n   * @see ElementLike\n   * @throws {FlickingError} {@link ERROR_CODE ERROR_CODE.NOT_ALLOWED_IN_FRAMEWORK} if called on frameworks (React, Angular, Vue...)\n   * @example\n   * ```ts\n   * const flicking = new eg.Flicking(\"#flick\");\n   * flicking.prepend(document.createElement(\"div\"));\n   * flicking.prepend(\"\\<div\\>Panel\\</div\\>\");\n   * flicking.prepend([\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]);\n   * // Even this is possible\n   * flicking.prepend(\"\\<div\\>Panel 1\\</div\\>\\<div\\>Panel 2\\</div\\>\");\n   * ```\n   */\n  public prepend(element: ElementLike | ElementLike[]): Panel[] {\n    return this.insert(0, element);\n  }\n\n  /**\n   * Insert new panels at given index\n   * This will increase index of panels after by the number of panels added\n   * @ko 주어진 인덱스에 새로운 패널들을 추가합니다\n   * 해당 인덱스보다 같거나 큰 인덱스를 가진 기존 패널들은 추가한 패널의 개수만큼 인덱스가 증가합니다.\n   * @param {number} index Index to insert new panels at<ko>새로 패널들을 추가할 인덱스</ko>\n   * @param {ElementLike | ElementLike[]} element A new HTMLElement, a outerHTML of element, or an array of both\n   * <ko>새로운 HTMLElement, 혹은 엘리먼트의 outerHTML, 혹은 그것들의 배열</ko>\n   * @return {Panel[]} An array of prepended panels<ko>추가된 패널들의 배열</ko>\n   * @throws {FlickingError} {@link ERROR_CODE ERROR_CODE.NOT_ALLOWED_IN_FRAMEWORK} if called on frameworks (React, Angular, Vue...)\n   * @example\n   * ```ts\n   * const flicking = new eg.Flicking(\"#flick\");\n   * flicking.insert(0, document.createElement(\"div\"));\n   * flicking.insert(2, \"\\<div\\>Panel\\</div\\>\");\n   * flicking.insert(1, [\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]);\n   * // Even this is possible\n   * flicking.insert(3, \"\\<div\\>Panel 1\\</div\\>\\<div\\>Panel 2\\</div\\>\");\n   * ```\n   */\n  public insert(index: number, element: ElementLike | ElementLike[]): Panel[] {\n    if (this._renderExternal) {\n      throw new FlickingError(ERROR.MESSAGE.NOT_ALLOWED_IN_FRAMEWORK, ERROR.CODE.NOT_ALLOWED_IN_FRAMEWORK);\n    }\n\n    return this._renderer.batchInsert({ index, elements: parseElement(element) });\n  }\n\n  /**\n   * Remove the panel at the given index\n   * This will decrease index of panels after by the number of panels removed\n   * @ko 주어진 인덱스의 패널을 제거합니다\n   * 해당 인덱스보다 큰 인덱스를 가진 기존 패널들은 제거한 패널의 개수만큼 인덱스가 감소합니다\n   * @param {number} index Index of panel to remove<ko>제거할 패널의 인덱스</ko>\n   * @param {number} [deleteCount=1] Number of panels to remove from index<ko>`index` 이후로 제거할 패널의 개수</ko>\n   * @return {Panel[]} An array of removed panels<ko>제거된 패널들의 배열</ko>\n   */\n  public remove(index: number, deleteCount: number = 1): Panel[] {\n    if (this._renderExternal) {\n      throw new FlickingError(ERROR.MESSAGE.NOT_ALLOWED_IN_FRAMEWORK, ERROR.CODE.NOT_ALLOWED_IN_FRAMEWORK);\n    }\n\n    return this._renderer.batchRemove({ index, deleteCount });\n  }\n\n  private _createControl(): Control {\n    const moveType = this._moveType;\n    const moveTypes = Object.keys(MOVE_TYPE).map(key => MOVE_TYPE[key] as ValueOf<typeof MOVE_TYPE>);\n\n    const moveTypeStr = Array.isArray(moveType)\n      ? moveType[0]\n      : moveType;\n\n    const moveTypeOptions = Array.isArray(moveType)\n      ? moveType[1] ?? {}\n      : {};\n\n    if (!includes(moveTypes, moveTypeStr)) {\n      throw new FlickingError(ERROR.MESSAGE.WRONG_OPTION(\"moveType\", JSON.stringify(moveType)), ERROR.CODE.WRONG_OPTION);\n    }\n\n    switch (moveTypeStr) {\n      case MOVE_TYPE.SNAP:\n        return new SnapControl(moveTypeOptions as SnapControlOptions);\n      case MOVE_TYPE.FREE_SCROLL:\n        return new FreeControl(moveTypeOptions as FreeControlOptions);\n      case MOVE_TYPE.STRICT:\n        return new StrictControl(moveTypeOptions as StrictControlOptions);\n    }\n  }\n\n  private _createCamera(): Camera {\n    const cameraOption = { align: this._align };\n\n    if (this._circular) {\n      if (this._bound) {\n        // eslint-disable-next-line no-console\n        console.warn(\"\\\"circular\\\" and \\\"bound\\\" option cannot be used together, ignoring bound.\");\n      }\n      return new CircularCamera(cameraOption);\n    } else if (this._bound) {\n      return new BoundCamera(cameraOption);\n    } else {\n      return new LinearCamera(cameraOption);\n    }\n  }\n\n  private _createRenderer(): Renderer {\n    const rendererOptions = {\n      align: this._align\n    };\n\n    const renderExternal = this._renderExternal;\n\n    return renderExternal\n      ? new (renderExternal.renderer as any)({ ...rendererOptions, ...renderExternal.rendererOptions })\n      : new VanillaRenderer(rendererOptions);\n  }\n\n  private async _moveToInitialPanel(): Promise<void> {\n    const renderer = this._renderer;\n    const control = this._control;\n    const initialPanel = renderer.getPanel(this._defaultIndex) || renderer.getPanel(0);\n\n    if (!initialPanel) return;\n\n    control.setActive(initialPanel, null, false);\n\n    return control.moveToPanel(initialPanel, {\n      duration: 0\n    });\n  }\n}\n\nexport default Flicking;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Panel, { PanelOptions } from \"./Panel\";\n\nexport interface ExternalPanelOptions<T> extends PanelOptions {\n  externalComponent: T;\n}\n\n/**\n * An slide data component that holds information of a single HTMLElement\n * @ko 슬라이드 데이터 컴포넌트로, 단일 HTMLElement의 정보를 갖고 있습니다\n */\nabstract class ExternalPanel<T = any> extends Panel {\n  protected _externalComponent: T;\n\n  /**\n   * @param {object} options An options object<ko>옵션 오브젝트</ko>\n   * @param {HTMLElement} [options.el] A `HTMLElement` panel's referencing<ko>패널이 참조하는 `HTMLElement`</ko>\n   * @param {number} [options.index] An initial index of the panel<ko>패널의 초기 인덱스</ko>\n   * @param {Constants.ALIGN | string | number} [options.align] An initial {@link Flicking#align align} value of the panel<ko>패널의 초기 {@link Flicking#align align}값</ko>\n   * @param {Flicking} [options.flicking] A Flicking instance panel's referencing<ko>패널이 참조하는 {@link Flicking} 인스턴스</ko>\n   */\n  public constructor(options: ExternalPanelOptions<T>) {\n    super(options);\n\n    this._externalComponent = options.externalComponent;\n  }\n}\n\nexport default ExternalPanel;\n","import Component from \"@egjs/component\";\n\nimport Flicking from \"../Flicking\";\n\n/**\n * Decorator that makes the method of flicking available in the framework.\n * @ko 프레임워크에서 플리킹의 메소드를 사용할 수 있게 하는 데코레이터.\n * @memberof eg.Flicking\n * @private\n * @example\n * ```js\n * import Flicking, { withFlickingMethods } from \"@egjs/flicking\";\n *\n * class Flicking extends React.Component<Partial<FlickingProps & FlickingOptions>> {\n *   &#64;withFlickingMethods\n *   private flicking: Flicking;\n * }\n * ```\n */\nconst withFlickingMethods = (prototype: any, flickingName: string) => {\n  [Component.prototype, Flicking.prototype].forEach(proto => {\n    Object.getOwnPropertyNames(proto).filter(name => !prototype[name] && !name.startsWith(\"_\") && name !== \"constructor\")\n      .forEach((name: string) => {\n        const descriptor = Object.getOwnPropertyDescriptor(proto, name)!;\n\n        if (descriptor.value) {\n          // Public Function\n          Object.defineProperty(prototype, name, {\n            value: function(...args) {\n              return descriptor.value.call(this[flickingName], ...args);\n            }\n          });\n        } else {\n          const getterDescriptor: { get?: () => any; set?: (val: any) => void } = {};\n          if (descriptor.get) {\n            getterDescriptor.get = function() {\n              return descriptor.get?.call(this[flickingName]);\n            };\n          }\n          if (descriptor.set) {\n            getterDescriptor.set = function(...args) {\n              return descriptor.set?.call(this[flickingName], ...args);\n            };\n          }\n\n          Object.defineProperty(prototype, name, getterDescriptor);\n        }\n      });\n  });\n};\n\nexport default withFlickingMethods;\n","import { DiffResult } from \"@egjs/list-differ\";\n\nimport Flicking from \"../Flicking\";\nimport Renderer from \"../renderer/Renderer\";\n\nexport default (flicking: Flicking, diffResult: DiffResult<any>, rendered: any[]) => {\n  const renderer = flicking.renderer;\n  const panels = renderer.panels;\n\n  if (diffResult.removed.length > 0) {\n    let endIdx = -1;\n    let prevIdx = -1;\n\n    diffResult.removed.forEach(removedIdx => {\n      if (endIdx < 0) {\n        endIdx = removedIdx;\n      }\n\n      if (prevIdx >= 0 && removedIdx !== prevIdx - 1) {\n        batchRemove(renderer, prevIdx, endIdx + 1);\n\n        endIdx = removedIdx;\n        prevIdx = removedIdx;\n      } else {\n        prevIdx = removedIdx;\n      }\n    });\n\n    batchRemove(renderer, prevIdx, endIdx + 1);\n  }\n\n  diffResult.ordered.forEach(([prevIdx, newIdx]) => {\n    const prevPanel = panels[prevIdx];\n    const indexDiff = newIdx - prevIdx;\n\n    if (indexDiff > 0) {\n      const middlePanels = panels.slice(prevIdx + 1, newIdx + 1);\n\n      prevPanel.increaseIndex(indexDiff);\n      middlePanels.forEach(panel => panel.decreaseIndex(1));\n    } else {\n      const middlePanels = panels.slice(newIdx, prevIdx);\n\n      prevPanel.decreaseIndex(-indexDiff);\n      middlePanels.forEach(panel => panel.increaseIndex(1));\n    }\n    // Update position\n    prevPanel.resize();\n  });\n\n  if (diffResult.ordered.length > 0) {\n    panels.sort((panel1, panel2) => panel1.index - panel2.index);\n  }\n\n  if (diffResult.added.length > 0) {\n    let startIdx = -1;\n    let prevIdx = -1;\n\n    diffResult.added.forEach((addedIdx, idx) => {\n      if (startIdx < 0) {\n        startIdx = idx;\n      }\n\n      if (prevIdx >= 0 && addedIdx !== prevIdx + 1) {\n        batchInsert(renderer, diffResult, rendered, startIdx, idx + 1);\n\n        startIdx = -1;\n        prevIdx = -1;\n      } else {\n        prevIdx = addedIdx;\n      }\n    });\n\n    if (startIdx >= 0) {\n      batchInsert(renderer, diffResult, rendered, startIdx);\n    }\n  }\n};\n\nconst batchInsert = (renderer: Renderer, diffResult: DiffResult<any>, rendered: any[], startIdx: number, endIdx?: number) => {\n  renderer.batchInsert(\n    ...diffResult.added.slice(startIdx, endIdx).map((index, elIdx) => ({ index, elements: [rendered[elIdx + diffResult.prevList.length]] }))\n  );\n};\n\nconst batchRemove = (renderer: Renderer, startIdx: number, endIdx?: number) => {\n  const removed = renderer.panels.slice(startIdx, endIdx);\n\n  renderer.batchRemove({ index: startIdx, deleteCount: removed.length });\n};\n\n","import { DiffResult } from \"@egjs/list-differ\";\n\nimport Flicking from \"../Flicking\";\n\nexport default <T>(flicking: Flicking, diffResult: DiffResult<T>) => {\n  const removedPanels = diffResult.removed.reduce((map, idx) => {\n    map[idx] = true;\n    return map;\n  }, {});\n\n  const maintainedMap = diffResult.maintained.reduce((map, [prev, current]) => {\n    map[prev] = current;\n    return map;\n  }, {});\n\n  return [\n    ...flicking.panels\n      .filter(panel => !removedPanels[panel.index])\n      // Sort panels by position\n      .sort((panel1, panel2) => (panel1.position + panel1.offset) - (panel2.position + panel2.offset))\n      .map(panel => diffResult.list[maintainedMap[panel.index]]),\n    ...diffResult.added.map(idx => diffResult.list[idx])\n  ];\n};\n\n","import { FlickingOptions } from \"../Flicking\";\nimport { ALIGN } from \"../const/external\";\nimport { parseArithmeticExpression } from \"../utils\";\n\nexport default (align: FlickingOptions[\"align\"] = ALIGN.CENTER, horizontal: boolean = true, firstPanelSize?: string) => {\n  const cameraAlign = getCameraAlign(align);\n  const panelAlign = getPanelAlign(align);\n\n  if (panelAlign == null) return \"\";\n\n  const camPosition = `calc(${cameraAlign} - (${firstPanelSize || \"0px\"} * ${panelAlign.percentage}) - ${panelAlign.absolute}px)`;\n\n  return horizontal\n    ? `translate(${camPosition})`\n    : `translate(0, ${camPosition})`;\n};\n\nconst getCameraAlign = (align: FlickingOptions[\"align\"]) => {\n  const alignVal = typeof align === \"object\"\n    ? (align as { camera: string | number }).camera\n    : align;\n\n  return parseAlign(alignVal);\n};\n\nconst getPanelAlign = (align: FlickingOptions[\"align\"]) => {\n  const alignVal = typeof align === \"object\"\n    ? (align as { panel: string | number }).panel\n    : align;\n\n  return parseArithmeticExpression(parseAlign(alignVal));\n};\n\nconst parseAlign = (alignVal: number | string) => {\n  if (typeof alignVal === \"number\") {\n    return `${alignVal}px`;\n  }\n\n  switch (alignVal) {\n    case ALIGN.CENTER:\n      return \"50%\";\n    case ALIGN.NEXT:\n      return \"100%\";\n    case ALIGN.PREV:\n      return \"0%\";\n    default:\n      return alignVal;\n  }\n};\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking from \"./Flicking\";\n\nexport * from \"./exports\";\n\nexport default Flicking;\n"],"names":["CODE","WRONG_TYPE","ELEMENT_NOT_FOUND","VAL_MUST_NOT_NULL","NOT_ATTACHED_TO_FLICKING","WRONG_OPTION","INDEX_OUT_OF_RANGE","POSITION_NOT_REACHABLE","TRANSFORM_NOT_SUPPORTED","STOP_CALLED_BY_USER","ANIMATION_INTERRUPTED","ANIMATION_ALREADY_PLAYING","NOT_ALLOWED_IN_FRAMEWORK","NOT_INITIALIZED","NO_ACTIVE","MESSAGE","wrongVal","correctTypes","map","type","join","selector","val","name","optionName","min","max","position","EVENTS","READY","BEFORE_RESIZE","AFTER_RESIZE","HOLD_START","HOLD_END","MOVE_START","MOVE","MOVE_END","WILL_CHANGE","CHANGED","WILL_RESTORE","RESTORED","SELECT","NEED_PANEL","VISIBLE_CHANGE","REACH_EDGE","PANEL_CHANGE","ALIGN","PREV","CENTER","NEXT","DIRECTION","NONE","MOVE_TYPE","SNAP","FREE_SCROLL","STRICT","getElement","el","parent","targetEl","isString","parentEl","document","queryResult","querySelector","FlickingError","ERROR","nodeType","Node","ELEMENT_NODE","checkExistence","value","nameOnErrMsg","clamp","x","Math","getFlickingAttached","nameToThrowOnError","toArray","iterable","slice","call","parseAlign","align","size","alignPoint","parseArithmeticSize","parseBounce","bounce","parsedBounce","Array","isArray","parsedVal","cssValue","base","parsed","parseArithmeticExpression","percentage","absolute","cssRegex","idx","matchResult","exec","sign","unit","parsedValue","parseFloat","signMultiplier","getDirection","start","end","parseElement","element","elements","forEach","tempDiv","createElement","innerHTML","push","children","firstChild","removeChild","getMinusCompensatedIndex","includes","array","target","array_1","__values","circulatePosition","pos","offset","find","checker","array_2","findIndex","length","getProgress","prev","next","getStyle","window","getComputedStyle","currentStyle","isBetween","circulateIndex","index","setPrototypeOf","Object","obj","proto","__proto__","__extends","message","code","_super","_this","prototype","Error","_el","_width","_height","_padding","left","right","top","bottom","_isBorderBoxSizing","_a","width","height","padding","isBorderBoxSizing","style","newWidth","newHeight","resize","elStyle","clientWidth","clientHeight","paddingLeft","paddingRight","paddingTop","paddingBottom","boxSizing","EVENT","HOLD","CHANGE","RELEASE","ANIMATION_END","FINISH","POSITION_KEY","STATE_TYPE","_delta","_targetPanel","prevState","ctx","flicking","axesEvent","transitTo","delta","AXES","camera","prevPosition","newPosition","circularEnabled","range","lookAt","moveEvent","ComponentEvent","isTrusted","holding","direction","trigger","isCanceled","DISABLED","renderer","panelCount","holdStartEvent","HOLDING","controller","control","animatingContext","moveStartEvent","ANIMATING","onChange","State","inputEvent","horizontal","offsetX","offsetY","DRAGGING","flick","setTo","IDLE","_releaseEvent","releaseEvent","srcEvent","clickedElement","touchEvent","touch","changedTouches","elementFromPoint","clientX","clientY","panels","clickedPanel","panels_1","panel","contains","cameraPosition","clickedPanelPosition","_moveToChangedPosition","destPos","duration","moveToPosition","updateInput","setActive","activePanel","stop","nextStateType","nextState","IdleState","HoldingState","DraggingState","AnimatingState","DisabledState","onEnter","_state","eventType","externalCtx","currentState","onHold","onRelease","onAnimationEnd","onFinish","_dragged","e","preventDefault","stopPropagation","_resetInternalValues","_stateMachine","StateMachine","_axes","state","_animatingContext","axes","circular","axis","_panInput","isEnable","get","_flicking","Axes","deceleration","interruptable","easing","PanInput","viewport","inputType","iOSEdgeSwipeThreshold","scale","releaseOnScroll","connect","key","on","fire","removePreventClickHandler","destroy","enable","disable","controlParams","axm","set","cameraEl","_onAxesHold","_onAxesChange","addEventListener","_preventClickWhenDragged","off","removeEventListener","Promise","reject","startPos","resolve","animate","resetContext","once","_b","newPos","animationFinishHandler","interruptionHandler","_controller","AxesController","_activePanel","animating","init","_progressInPanel","clampToReachablePosition","update","nearestAnchor","findNearestAnchor","removed","canReach","camPos_1","camRangeDiff","rangeDiff","possiblePositions","filter","reduce","nearestPosition","abs","Infinity","_triggerIndexChangeEvent","_animateToPosition","newActivePanel","prevActivePanel","updateAdaptiveHeight","prevIndex","prevPanel","triggeringEvent","event","animateTo","targetPanel","then","render","catch","err","_index","_pos","_panel","_c","count","_count","activeAnchor","findActiveAnchor","anchorAtCamera","snapThreshold","_calcSnapThreshold","posDelta","absPosDelta","snapDelta","targetAnchor","_findSnappedAnchor","threshold","_findAdjacentAnchor","currentPos","clampedPosition","anchorAtPosition","findAnchorIncludePosition","isFinite","anchors","anchorPoints","loopCount","floor","circularIndexOffset","anchorAtPositionIndex","anchor","AnchorPoint","loop","adjacentAnchor","getNextAnchor","getPrevAnchor","isNextDirection","panelSize","alignPos","alignPosition","margin","Control","stopAtEdge","_stopAtEdge","progressInPanel","panelRange","targetPos","_resetIndexRange","cameraRange","currentIndex","prevPanelIndex","nextPanelIndex","nextPanel","prevPos","nextPos","_indexRange","axesRange","indexRange","isOverThreshold","firstAnchor","lastAnchor","shouldBounceToFirst","shouldBounceToLast","transforms","supportedStyle","documentElement","transformName","transforms_1","prefixedTransform","_transform","_align","_position","_alignPos","_offset","_range","_visiblePanels","_anchors","NaN","nearestPanel","panelPos","bounceSize","prevRange","nextRange","nextPosition","viewportEl","firstElementChild","_checkTranslateSupport","_refreshVisiblePanels","_checkNeedPanel","_checkReachEnd","_applyTransform","anchorsIncludingPosition","includePosition","nearest","prevDist","anchorIdx","dist","activeIndex","visibleRange","includeRange","alignVal","adaptive","setSize","unRenderedPanels","rendered","sizeIncludingMargin","_needPanelTriggered","newVisiblePanels","canSee","prevVisiblePanels","added","visiblePanels","needPanelTriggered","cameraSize","needPanelThreshold","cameraPrev","cameraNext","firstPanel","lastPanel","firstPanelPrev","lastPanelNext","wasBetweenRange","isBetweenRange","actualPosition","getPanel","Camera","_circularOffset","_circularEnabled","positionInRange","anchorInRange","visibleInCurrentRange","visibleSize","panelSizeSum","canSetCircularMode","every","updateCircularToggleDirection","_updateCircularOffset","toggled","toggle","some","isToggled","sum","toggledPrev","toggledNext","toggleDirection","_calcPanelAreaSum","viewportSize","panelAreaSize","isBiggerThanViewport","firstPos","lastPos","reachablePanels","shouldPrependBoundAnchor","shouldAppendBoundAnchor","indexOffset_1","newAnchors","splice","nearestPanelAtMin","_findNearestPanel","panelAtMin","panelAtMax","panelIdx","_panels","panelAlign","_getPanelAlign","_collectPanels","panelsPerView","_updatePanelSizeByGrid","_i","items","allPanelsInserted","addedPanels","item","insertingIdx","panelsPushed","panelsInserted","_createPanel","_insertPanelElements","increaseIndex","updatePosition","_updateCameraAndControl","moveToPanel","updateOffset","checkPanelContentsReady","allPanelsRemoved","deleteCount","removingIdx","panelsPulled","panelsRemoved","decreaseIndex","_removePanelElements","resetActive","checkingPanels","resizeOnContentsReady","hasContents","contentsReadyChecker","ImReady","loading","prevProgressInPanel","getProgressInPanel","panelBehind","initialized","updateRange","updateAnchors","readyCount","totalCount","check","resetNeedPanelHistory","renderOnlyVisible","_showOnlyVisiblePanels","markForShow","visibleIndexes","visibles","markForHide","gap","panelSizeObj","firstPanelSizeObj","noPanelStyleOverride","_removed","_loading","_resetInternalStates","_size","_margin","_toggled","_toggleDirection","cameraRangeDiff","progress","camPos","disappearPosNext","disappearPosPrev","checkingRange","cached","offsetWidth","offsetHeight","marginLeft","marginRight","marginTop","marginBottom","_updateAlignPos","includeMargin","moveTo","togglePosition","_togglePosition","prevToggled","camRange","camAlignPosition","camVisibleRange","camVisibleSize","minimumVisible","maximumVisible","shouldBeVisibleAtMin","shouldBeVisibleAtMax","options","_rendered","Panel","wasRenderedPanels","parentElement","_updateRenderingPanels","renderingPanels","_getRenderingPanelsByOrder","_resetPanelElementOrder","cameraElement","fragment","createDocumentFragment","appendChild","_removeAllChildsFromCamera","childNodes","node","TEXT_NODE","cameraChilds","ElementPanel","nextSibling","nextSiblingElement","insertBefore","reversedPanels","__spreadArray","reverse","nextPanelEl","nextElementSibling","sort","a","b","Renderer","root","_d","defaultIndex","_e","_f","_g","bound","_h","_j","_k","_l","_m","_o","preventEventsBeforeInit","_p","_q","_r","pow","_s","_t","moveType","_u","_v","_w","_x","_y","preventClickOnDrag","_z","disableOnInit","_0","_1","autoInit","_2","autoResize","_3","renderExternal","_initialized","_plugins","_defaultIndex","_horizontal","_circular","_bound","_adaptive","_panelsPerView","_noPanelStyleOverride","_resizeOnContentsReady","_needPanelThreshold","_preventEventsBeforeInit","_deceleration","_duration","_easing","_inputType","_moveType","_threshold","_interruptable","_bounce","_iOSEdgeSwipeThreshold","_preventClickOnDrag","_disableOnInit","_renderOnlyVisible","_autoResize","_autoInit","_renderExternal","_viewport","Viewport","_renderer","_createRenderer","_camera","_createCamera","_control","_createControl","bind","prevVal","addPreventClickHandler","originalTrigger","_moveToInitialPanel","disableInput","plugin","includePanelHTML","visiblePanelsOnly","status","panelInfo","html","outerHTML","visibleOffset","batchRemove","batchInsert","panelIndex","newCameraPos","plugins","foundIndex","prevWidth","prevHeight","forceRenderAllPanels","updatePanelSize","updateAlignPos","sizeChanged","insert","moveTypes","keys","moveTypeStr","moveTypeOptions","JSON","stringify","SnapControl","FreeControl","StrictControl","cameraOption","console","warn","CircularCamera","BoundCamera","LinearCamera","rendererOptions","VanillaRenderer","initialPanel","Flicking","Component","_externalComponent","externalComponent","withFlickingMethods","flickingName","getOwnPropertyNames","startsWith","descriptor","getOwnPropertyDescriptor","defineProperty","args","getterDescriptor","diffResult","endIdx_1","prevIdx_1","removedIdx","ordered","__read","prevIdx","newIdx","indexDiff","middlePanels","panel1","panel2","startIdx_1","prevIdx_2","addedIdx","startIdx","endIdx","elIdx","prevList","removedPanels","maintainedMap","maintained","current","list","firstPanelSize","cameraAlign","getCameraAlign","getPanelAlign","camPosition"],"mappings":"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"}