{"version":3,"file":"flicking.pkgd.min.js","sources":["../src/utils.ts","../src/core/FlickingError.ts","../src/const/error.ts","../src/const/external.ts","../src/core/Viewport.ts","../src/control/states/State.ts","../src/const/axes.ts","../src/control/states/IdleState.ts","../src/control/states/HoldingState.ts","../src/control/states/DraggingState.ts","../src/control/states/AnimatingState.ts","../src/control/states/DisabledState.ts","../src/control/StateMachine.ts","../src/control/AxesController.ts","../src/control/Control.ts","../src/control/SnapControl.ts","../src/control/FreeControl.ts","../src/control/StrictControl.ts","../src/core/AnchorPoint.ts","../src/camera/Camera.ts","../src/camera/LinearCamera.ts","../src/camera/CircularCamera.ts","../src/camera/BoundCamera.ts","../src/renderer/RenderingStrategy/RawRenderingStrategy.ts","../src/renderer/Renderer.ts","../src/core/panel/Panel.ts","../src/core/panel/ElementPanel.ts","../src/renderer/VanillaRenderer.ts","../src/renderer/ExternalRenderer.ts","../src/renderer/RenderingStrategy/VisibleRenderingStrategy.ts","../src/Flicking.ts","../src/cfc/sync.ts","../src/cfc/getDefaultCameraTransform.ts","../src/cfc/withFlickingMethods.ts","../src/cfc/getRenderingPanels.ts","../src/index.umd.ts","../src/core/panel/ExternalPanel.ts"],"sourcesContent":["/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking, { FlickingOptions } from \"./Flicking\";\nimport FlickingError from \"./core/FlickingError\";\nimport * as ERROR from \"./const/error\";\nimport { ALIGN, DIRECTION } from \"./const/external\";\nimport { LiteralUnion, Merged, ValueOf } from \"./type/internal\";\nimport { ElementLike } from \"./type/external\";\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport const merge = <From extends object, To extends object>(target: From, ...sources: To[]): Merged<From, To> => {\n  sources.forEach(source => {\n    Object.keys(source).forEach(key => {\n      target[key] = source[key] as unknown;\n    });\n  });\n\n  return target as Merged<From, To>;\n};\n\nexport const getElement = (el: HTMLElement | string | null, parent?: HTMLElement): HTMLElement => {\n  let targetEl: HTMLElement | null = null;\n\n  if (isString(el)) {\n    const parentEl = parent ? parent : document;\n    const queryResult = parentEl.querySelector(el);\n    if (!queryResult) {\n      throw new FlickingError(ERROR.MESSAGE.ELEMENT_NOT_FOUND(el), ERROR.CODE.ELEMENT_NOT_FOUND);\n    }\n    targetEl = queryResult as HTMLElement;\n  } else if (el && el.nodeType === Node.ELEMENT_NODE) {\n    targetEl = el;\n  }\n\n  if (!targetEl) {\n    throw new FlickingError(ERROR.MESSAGE.WRONG_TYPE(el, [\"HTMLElement\", \"string\"]), ERROR.CODE.WRONG_TYPE);\n  }\n\n  return targetEl;\n};\n\nexport const checkExistence = (value: any, nameOnErrMsg: string) => {\n  if (value == null) {\n    throw new FlickingError(ERROR.MESSAGE.VAL_MUST_NOT_NULL(value, nameOnErrMsg), ERROR.CODE.VAL_MUST_NOT_NULL);\n  }\n};\n\nexport const clamp = (x: number, min: number, max: number) => Math.max(Math.min(x, max), min);\n\nexport const getFlickingAttached = (val: Flicking | null, nameToThrowOnError: string): Flicking => {\n  if (!val) {\n    throw new FlickingError(ERROR.MESSAGE.NOT_ATTACHED_TO_FLICKING(nameToThrowOnError), ERROR.CODE.NOT_ATTACHED_TO_FLICKING);\n  }\n\n  return val;\n};\n\nexport const toArray = <T>(iterable: ArrayLike<T>): T[] => [].slice.call(iterable) as T[];\n\nexport const parseAlign = (align: LiteralUnion<ValueOf<typeof ALIGN>> | number, size: number): number => {\n  let alignPoint: number | null;\n  if (isString(align)) {\n    switch (align) {\n      case ALIGN.PREV:\n        alignPoint = 0;\n        break;\n      case ALIGN.CENTER:\n        alignPoint = 0.5 * size;\n        break;\n      case ALIGN.NEXT:\n        alignPoint = size;\n        break;\n      default:\n        alignPoint = parseArithmeticSize(align, size);\n        if (alignPoint == null) {\n          throw new FlickingError(ERROR.MESSAGE.WRONG_OPTION(\"align\", align), ERROR.CODE.WRONG_OPTION);\n        }\n    }\n  } else {\n    alignPoint = align as number;\n  }\n\n  return alignPoint;\n};\n\nexport const parseBounce = (bounce: FlickingOptions[\"bounce\"], size: number): number[] => {\n  let parsedBounce: Array<number | null>;\n\n  if (Array.isArray(bounce)) {\n    parsedBounce = (bounce as string[]).map(val => parseArithmeticSize(val, size));\n  } else {\n    const parsedVal = parseArithmeticSize(bounce, size);\n\n    parsedBounce = [parsedVal, parsedVal];\n  }\n\n  return parsedBounce.map(val => {\n    if (val == null) {\n      throw new FlickingError(ERROR.MESSAGE.WRONG_OPTION(\"bounce\", bounce), ERROR.CODE.WRONG_OPTION);\n    }\n    return val;\n  });\n};\n\nexport const parseArithmeticSize = (cssValue: number | string, base: number): number | null => {\n  const parsed = parseArithmeticExpression(cssValue);\n\n  if (parsed == null) return null;\n\n  return parsed.percentage * base + parsed.absolute;\n};\n\nexport const parseArithmeticExpression = (cssValue: number | string): { percentage: number; absolute: number } | null => {\n  const cssRegex = /(?:(\\+|\\-)\\s*)?(\\d+(?:\\.\\d+)?(%|px)?)/g;\n\n  if (typeof cssValue === \"number\") {\n    return { percentage: 0, absolute: cssValue };\n  }\n\n  const parsed = {\n    percentage: 0,\n    absolute: 0\n  };\n  let idx = 0;\n  let matchResult = cssRegex.exec(cssValue);\n  while (matchResult != null) {\n    let sign = matchResult[1];\n    const value = matchResult[2];\n    const unit = matchResult[3];\n    const parsedValue = parseFloat(value);\n\n    if (idx <= 0) {\n      sign = sign || \"+\";\n    }\n\n    // Return default value for values not in good form\n    if (!sign) {\n      return null;\n    }\n\n    const signMultiplier = sign === \"+\" ? 1 : -1;\n\n    if (unit === \"%\") {\n      parsed.percentage += signMultiplier * (parsedValue / 100);\n    } else {\n      parsed.absolute += signMultiplier * parsedValue;\n    }\n\n    // Match next occurrence\n    ++idx;\n    matchResult = cssRegex.exec(cssValue);\n  }\n\n  // None-matched\n  if (idx === 0) {\n    return null;\n  }\n\n  return parsed;\n};\n\nexport const parseCSSSizeValue = (val: string | number): string => isString(val) ? val : `${val}px`;\n\nexport const getDirection = (start: number, end: number): ValueOf<typeof DIRECTION> => {\n  if (start === end) return DIRECTION.NONE;\n  return start < end ? DIRECTION.NEXT : DIRECTION.PREV;\n};\n\nexport const parseElement = (element: ElementLike | ElementLike[]): HTMLElement[] => {\n  if (!Array.isArray(element)) {\n    element = [element];\n  }\n\n  const elements: HTMLElement[] = [];\n  element.forEach(el => {\n    if (isString(el)) {\n      const tempDiv = document.createElement(\"div\");\n      tempDiv.innerHTML = el;\n\n      elements.push(...toArray(tempDiv.children) as HTMLElement[]);\n      while (tempDiv.firstChild) {\n        tempDiv.removeChild(tempDiv.firstChild);\n      }\n    } else if (el && el.nodeType === Node.ELEMENT_NODE) {\n      elements.push(el);\n    } else {\n      throw new FlickingError(ERROR.MESSAGE.WRONG_TYPE(el, [\"HTMLElement\", \"string\"]), ERROR.CODE.WRONG_TYPE);\n    }\n  });\n\n  return elements;\n};\n\nexport const getMinusCompensatedIndex = (idx: number, max: number) => idx < 0 ? clamp(idx + max, 0, max) : clamp(idx, 0, max);\n\nexport const includes = <T>(array: T[], target: any): target is T => {\n  for (const val of array) {\n    if (val === target) return true;\n  }\n  return false;\n};\n\nexport const isString = (val: any): val is string => typeof val === \"string\";\n\nexport const circulatePosition = (pos: number, min: number, max: number) => {\n  const size = max - min;\n\n  if (pos < min) {\n    const offset = (min - pos) % size;\n    pos = max - offset;\n  } else if (pos > max) {\n    const offset = (pos - max) % size;\n    pos = min + offset;\n  }\n\n  return pos;\n};\n\nexport const find = <T>(array: T[], checker: (val: T) => boolean): T | null => {\n  for (const val of array) {\n    if (checker(val)) {\n      return val;\n    }\n  }\n\n  return null;\n};\n\nexport const findRight = <T>(array: T[], checker: (val: T) => boolean): T | null => {\n  for (let idx = array.length - 1; idx >= 0; idx--) {\n    const val = array[idx];\n    if (checker(val)) {\n      return val;\n    }\n  }\n\n  return null;\n};\n\nexport const findIndex = <T>(array: T[], checker: (val: T) => boolean): number => {\n  for (let idx = 0; idx < array.length; idx++) {\n    if (checker(array[idx])) {\n      return idx;\n    }\n  }\n\n  return -1;\n};\n\nexport const getProgress = (pos: number, prev: number, next: number) => (pos - prev) / (next - prev);\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nexport const getStyle = (el: HTMLElement): CSSStyleDeclaration => window.getComputedStyle(el) || (el as any).currentStyle as CSSStyleDeclaration;\n\nexport const isBetween = (val: number, min: number, max: number) => val >= min && val <= max;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\n/**\n * Special type of known error that {@link Flicking} throws.\n * @ko Flicking 내부에서 알려진 오류 발생시 throw되는 에러\n * @property {number} code Error code<ko>에러 코드</ko>\n * @property {string} message Error message<ko>에러 메시지</ko>\n * @see {@link Constants.ERROR_CODE ERROR_CODE}\n * @example\n * ```ts\n * import Flicking, { FlickingError, ERROR_CODES } from \"@egjs/flicking\";\n * try {\n *   const flicking = new Flicking(\".flicking-viewport\")\n * } catch (e) {\n *   if (e instanceof FlickingError && e.code === ERROR_CODES.ELEMENT_NOT_FOUND) {\n *     console.error(\"Element not found\")\n *   }\n * }\n * ```\n */\nclass FlickingError extends Error {\n  /**\n   * @param message Error message<ko>에러 메시지</ko>\n   * @param code Error code<ko>에러 코드</ko>\n   */\n  public constructor(\n    public message: string,\n    public code: number) {\n    super(message);\n    Object.setPrototypeOf(this, FlickingError.prototype);\n    this.name = \"FlickingError\";\n  }\n}\n\nexport default FlickingError;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n/* eslint-disable @typescript-eslint/restrict-template-expressions */\n\n/**\n * Error codes of {@link FlickingError}. Below are the conditions where each error code occurs.\n * @ko {@link FlickingError}의 에러 코드. 아래는 각각의 에러 코드가 발생하는 조건입니다.\n * @name ERROR_CODE\n * @constant\n * @type object\n * @property {number} WRONG_TYPE Parameter type is wrong<ko>패러미터의 타입이 잘못되었을 경우</ko>\n * @property {number} ELEMENT_NOT_FOUND Element is not found inside page with the given CSS selector<ko>주어진 CSS selector로 페이지 내에서 해당 엘리먼트를 찾지 못했을 경우</ko>\n * @property {number} VAL_MUST_NOT_NULL Expected non-null value, but given `null` or `undefined`<ko>값을 기대했으나, `null`이나 `undefined`를 받은 경우</ko>\n * @property {number} NOT_ATTACHED_TO_FLICKING When Flicking's component is not initialized (i.e. {@link Flicking#init} is not called)<ko>Flicking 내부 컴포넌트가 초기화되지 않은 경우 ({@link Flicking#init}이 호출되지 않은 경우)</ko>\n * @property {number} WRONG_OPTION One of the options is wrong<ko>옵션들 중 잘못된 값이 있을 때</ko>\n * @property {number} INDEX_OUT_OF_RANGE When the given index is out of possible range<ko>인덱스가 주어진 범위를 벗어난 경우</ko>\n * @property {number} POSITION_NOT_REACHABLE When {@link Control#moveToPosition}'s position parameter is out of possible range.<ko>{@link Control#moveToPosition}의 `position` 패러미터가 도달 가능한 범위를 벗어난 경우</ko>\n * @property {number} TRANSFORM_NOT_SUPPORTED CSS `transform` property is not available(<=IE8) <ko>CSS `transform` 속성을 사용할 수 없는 경우(<=IE8)</ko>\n * @property {number} STOP_CALLED_BY_USER When the event's `stop()` is called by user.<ko>사용자에 의해 이벤트의 `stop()`이 호출된 경우</ko>\n * @property {number} ANIMATION_INTERRUPTED When the animation is interrupted by user.<ko>사용자에 의해 애니메이션이 중단된 경우</ko>\n * @property {number} ANIMATION_ALREADY_PLAYING When the animation is already playing.<ko>현재 애니메이션이 이미 진행중인 경우</ko>\n * @property {number} NOT_ALLOWED_IN_FRAMEWORK When the non-allowed method is called from frameworks (React, Angular, Vue...)\n * <ko>프레임워크(React, Angular, Vue ...)에서 사용 불가능한 메소드를 호출했을 경우</ko>\n * @property {number} NOT_INITIALIZED When the {@link Flicking#init} is not called before but is needed<ko>{@link Flicking#init}의 호출이 필요하나, 아직 호출되지 않았을 경우</ko>\n * @property {number} NO_ACTIVE When there're no active panel that flicking has selected. This may be due to the absence of any panels<ko>현재 Flicking이 선택한 패널이 없을 경우. 일반적으로 패널이 하나도 없는 경우에 발생할 수 있습니다</ko>\n */\nexport const CODE = {\n  WRONG_TYPE: 0,\n  ELEMENT_NOT_FOUND: 1,\n  VAL_MUST_NOT_NULL: 2,\n  NOT_ATTACHED_TO_FLICKING: 3,\n  WRONG_OPTION: 4,\n  INDEX_OUT_OF_RANGE: 5,\n  POSITION_NOT_REACHABLE: 6,\n  TRANSFORM_NOT_SUPPORTED: 7,\n  STOP_CALLED_BY_USER: 8,\n  ANIMATION_INTERRUPTED: 9,\n  ANIMATION_ALREADY_PLAYING: 10,\n  NOT_ALLOWED_IN_FRAMEWORK: 11,\n  NOT_INITIALIZED: 12,\n  NO_ACTIVE: 13\n} as const;\n\nexport const MESSAGE = {\n  WRONG_TYPE: (wrongVal: any, correctTypes: string[]) => `${wrongVal}(${typeof wrongVal}) is not a ${correctTypes.map(type => `\"${type}\"`).join(\" or \")}.`,\n  ELEMENT_NOT_FOUND: (selector: string) => `Element with selector \"${selector}\" not found.`,\n  VAL_MUST_NOT_NULL: (val: any, name: string) => `${name} should be provided. Given: ${val}`,\n  NOT_ATTACHED_TO_FLICKING: (name: string) => `${name} is not attached to the Flicking instance. \"init()\" should be called first.`,\n  WRONG_OPTION: (optionName: string, val: any) => `Option \"${optionName}\" is not in correct format, given: ${val}`,\n  INDEX_OUT_OF_RANGE: (val: number, min: number, max: number) => `Index \"${val}\" is out of range: should be between ${min} and ${max}.`,\n  POSITION_NOT_REACHABLE: (position: number) => `Position \"${position}\" is not reachable.`,\n  TRANSFORM_NOT_SUPPORTED: \"Browser does not support CSS transform.\",\n  STOP_CALLED_BY_USER: \"Event stop() is called by user.\",\n  ANIMATION_INTERRUPTED: \"Animation is interrupted by user input.\",\n  ANIMATION_ALREADY_PLAYING: \"Animation is already playing.\",\n  NOT_ALLOWED_IN_FRAMEWORK: \"This behavior is not allowed in the frameworks like React, Vue, or Angular.\",\n  NOT_INITIALIZED: \"Flicking is not initialized yet, call init() first.\",\n  NO_ACTIVE: \"There's no active panel that Flicking has selected. This may be due to the absence of any panels.\"\n} as const;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nexport { CODE as ERROR_CODE } from \"./error\";\n\n/**\n * Event type object with event name strings of {@link Flicking}\n * @ko {@link Flicking}의 이벤트 이름 문자열들을 담은 객체\n * @type {object}\n * @property {\"holdStart\"} HOLD_START holdStart event<ko>holdStart 이벤트</ko>\n * @property {\"holdEnd\"} HOLD_END holdEnd event<ko>holdEnd 이벤트</ko>\n * @property {\"moveStart\"} MOVE_START moveStart event<ko>moveStart 이벤트</ko>\n * @property {\"move\"} MOVE move event<ko>move 이벤트</ko>\n * @property {\"moveEnd\"} MOVE_END moveEnd event<ko>moveEnd 이벤트</ko>\n * @property {\"willChange\"} WILL_CHANGE willChange event<ko>willChange 이벤트</ko>\n * @property {\"changed\"} CHANGED changed event<ko>changed 이벤트</ko>\n * @property {\"willRestore\"} WILL_RESTORE willRestore event<ko>willRestore 이벤트</ko>\n * @property {\"restored\"} RESTORED restored event<ko>restored 이벤트</ko>\n * @property {\"select\"} SELECT select event<ko>select 이벤트</ko>\n * @property {\"needPanel\"} NEED_PANEL needPanel event<ko>needPanel 이벤트</ko>\n * @property {\"panelChange\"} PANEL_CHANGE panelChange event<ko>panelChange 이벤트</ko>\n * @example\n * ```ts\n * import { EVENTS } from \"@egjs/flicking\";\n * EVENTS.MOVE_START; // \"moveStart\"\n * ```\n */\nexport const EVENTS = {\n  READY: \"ready\",\n  BEFORE_RESIZE: \"beforeResize\",\n  AFTER_RESIZE: \"afterResize\",\n  HOLD_START: \"holdStart\",\n  HOLD_END: \"holdEnd\",\n  MOVE_START: \"moveStart\",\n  MOVE: \"move\",\n  MOVE_END: \"moveEnd\",\n  WILL_CHANGE: \"willChange\",\n  CHANGED: \"changed\",\n  WILL_RESTORE: \"willRestore\",\n  RESTORED: \"restored\",\n  SELECT: \"select\",\n  NEED_PANEL: \"needPanel\",\n  VISIBLE_CHANGE: \"visibleChange\",\n  REACH_EDGE: \"reachEdge\",\n  PANEL_CHANGE: \"panelChange\"\n} as const;\n\n/**\n * An object with all possible predefined literal string for the {@link Flicking#align align} option\n * @ko {@link Flicking#align align} 옵션에 사용되는 미리 정의된 리터럴 상수들을 담고 있는 객체\n * @type {object}\n * @property {\"prev\"} PREV left/top align<ko>좌/상 정렬</ko>\n * @property {\"center\"} CENTER center align<ko>중앙 정렬</ko>\n * @property {\"next\"} NEXT right/bottom align<ko>우/하 정렬</ko>\n */\nexport const ALIGN = {\n  PREV: \"prev\",\n  CENTER: \"center\",\n  NEXT: \"next\"\n} as const;\n\n/**\n * An object of directions\n * @ko 방향을 나타내는 값들을 담고 있는 객체\n * @type {object}\n * @property {\"PREV\"} PREV \"left\" when {@link Flicking#horizontal horizontal} is true, and \"top\" when {@link Flicking#horizontal horizontal} is false\n * <ko>{@link Flicking#horizontal horizontal}가 `true`일 경우 왼쪽, {@link Flicking#horizontal horizontal}가 `false`일 경우 위쪽을 의미합니다</ko>\n * @property {\"NEXT\"} NEXT \"right\" when {@link Flicking#horizontal horizontal} is true, and \"bottom\" when {@link Flicking#horizontal horizontal} is false\n * <ko>{@link Flicking#horizontal horizontal}가 `true`일 경우 오른쪽, {@link Flicking#horizontal horizontal}가 `false`일 경우 아래쪽을 의미합니다</ko>\n * @property {null} NONE This value usually means it's the same position<ko>주로 제자리인 경우를 의미합니다</ko>\n */\nexport const DIRECTION = {\n  PREV: \"PREV\",\n  NEXT: \"NEXT\",\n  NONE: null\n} as const;\n\n/**\n * An object with all possible {@link Flicking#moveType moveType}s\n * @ko Flicking이 제공하는 {@link Flicking#moveType moveType}들을 담고 있는 객체\n * @type {object}\n * @property {\"snap\"} SNAP Flicking's {@link Flicking#moveType moveType} that enables {@link SnapControl} as a Flicking's {@link Flicking#control control}\n * <ko>Flicking의 {@link Flicking#control control}을 {@link SnapControl}로 설정하게 하는 {@link Flicking#moveType moveType}</ko>\n * @property {\"freeScroll\"} FREE_SCROLL Flicking's {@link Flicking#moveType moveType} that enables {@link FreeControl} as a Flicking's {@link Flicking#control control}\n * <ko>Flicking의 {@link Flicking#control control}을 {@link FreeControl}로 설정하게 하는 {@link Flicking#moveType moveType}</ko>\n * @property {\"strict\"} STRICT Flicking's {@link Flicking#moveType moveType} that enables {@link StrictControl} as a Flicking's {@link Flicking#control control}\n * <ko>Flicking의 {@link Flicking#control control}을 {@link StrictControl}로 설정하게 하는 {@link Flicking#moveType moveType}</ko>\n */\nexport const MOVE_TYPE = {\n  SNAP: \"snap\",\n  FREE_SCROLL: \"freeScroll\",\n  STRICT: \"strict\"\n} as const;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { getStyle, isString } from \"../utils\";\n\n/**\n * A component that manages viewport size\n * @ko 뷰포트 크기 정보를 담당하는 컴포넌트\n */\nclass Viewport {\n  private _el: HTMLElement;\n  private _width: number;\n  private _height: number;\n  private _isBorderBoxSizing: boolean;\n  private _padding: {\n    left: number;\n    right: number;\n    top: number;\n    bottom: number;\n  };\n\n  /**\n   * A viewport(root) element\n   * @ko 뷰포트(root) 엘리먼트\n   * @type {HTMLElement}\n   * @readonly\n   */\n  public get element() { return this._el; }\n\n  /**\n   * Viewport width, without paddings\n   * @ko 뷰포트 너비\n   * @type {number}\n   * @readonly\n   */\n  public get width() { return this._width - this._padding.left - this._padding.right; }\n  /**\n   * Viewport height, without paddings\n   * @ko 뷰포트 높이\n   * @type {number}\n   * @readonly\n   */\n  public get height() { return this._height - this._padding.top - this._padding.bottom; }\n  /**\n   * Viewport paddings\n   * @ko 뷰포트 CSS padding 값\n   * @type {object}\n   * @property {number} left CSS `padding-left`\n   * @property {number} right CSS `padding-right`\n   * @property {number} top CSS `padding-top`\n   * @property {number} bottom CSS `padding-bottom`\n   * @readonly\n   */\n  public get padding() { return this._padding; }\n\n  /**\n   * @param el A viewport element<ko>뷰포트 엘리먼트</ko>\n   */\n  public constructor(el: HTMLElement) {\n    this._el = el;\n    this._width = 0;\n    this._height = 0;\n    this._padding = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    this._isBorderBoxSizing = false;\n  }\n\n  /**\n   * Change viewport's size.\n   * This will change the actual size of `.flicking-viewport` element by changing its CSS width/height property\n   * @ko 뷰포트 크기를 변경합니다.\n   * `.flicking-viewport` 엘리먼트에 해당 크기의 CSS width/height를 적용합니다\n   * @param {object} [size] New viewport size<ko>새 뷰포트 크기</ko>\n   * @param {number|string} [size.width] CSS string or number(in px)<ko>CSS 문자열 또는 숫자(px)</ko>\n   * @param {number|string} [size.height] CSS string or number(in px)<ko>CSS 문자열 또는 숫자(px)</ko>\n   */\n  public setSize({\n    width,\n    height\n  }: Partial<{\n    width: number | string;\n    height: number | string;\n  }>) {\n    const el = this._el;\n    const padding = this._padding;\n    const isBorderBoxSizing = this._isBorderBoxSizing;\n\n    if (width != null) {\n      if (isString(width)) {\n        el.style.width = width;\n      } else {\n        const newWidth = isBorderBoxSizing\n          ? width + padding.left + padding.right\n          : width;\n        el.style.width = `${newWidth}px`;\n      }\n    }\n    if (height != null) {\n      if (isString(height)) {\n        el.style.height = height;\n      } else {\n        const newHeight = isBorderBoxSizing\n          ? height + padding.top + padding.bottom\n          : height;\n        el.style.height = `${newHeight}px`;\n      }\n    }\n    this.resize();\n  }\n\n  /**\n   * Update width/height to the current viewport element's size\n   * @ko 현재 뷰포트 엘리먼트의 크기로 너비/높이를 업데이트합니다\n   */\n  public resize() {\n    const el = this._el;\n    const elStyle = getStyle(el);\n\n    this._width = el.clientWidth;\n    this._height = el.clientHeight;\n    this._padding = {\n      left: parseFloat(elStyle.paddingLeft),\n      right: parseFloat(elStyle.paddingRight),\n      top: parseFloat(elStyle.paddingTop),\n      bottom: parseFloat(elStyle.paddingBottom)\n    };\n    this._isBorderBoxSizing = elStyle.boxSizing === \"border-box\";\n  }\n}\n\nexport default Viewport;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { OnAnimationEnd, OnChange, OnFinish, OnHold, OnRelease } from \"@egjs/axes\";\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport Flicking from \"../../Flicking\";\nimport { EVENTS } from \"../../const/external\";\nimport * as AXES from \"../../const/axes\";\nimport { circulatePosition, getDirection } from \"../../utils\";\n\nexport enum STATE_TYPE {\n  IDLE,\n  HOLDING,\n  DRAGGING,\n  ANIMATING,\n  DISABLED\n}\n\n/**\n * A component that shows the current status of the user input or the animation\n * @ko 현재 사용자 입력 또는 애니메이션 상태를 나타내는 컴포넌트\n * @internal\n */\nabstract class State {\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {boolean}\n   * @readonly\n   */\n  public abstract readonly holding: boolean;\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {boolean}\n   * @readonly\n   */\n  public abstract readonly animating: boolean;\n\n  /**\n   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} event\n   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} 이벤트 핸들러\n   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>\n   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>\n   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} event of Axes\n   * <ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} 이벤트</ko>\n   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>\n   * @return {void}\n   */\n  public onHold(ctx: {\n    flicking: Flicking;\n    axesEvent: OnHold;\n    transitTo: (nextState: STATE_TYPE) => State;\n  }): void {\n    // DO NOTHING\n  }\n\n  /**\n   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} event\n   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} 이벤트 핸들러\n   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>\n   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>\n   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} event of Axes\n   * <ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} 이벤트</ko>\n   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>\n   * @return {void}\n   */\n  public onChange(ctx: {\n    flicking: Flicking;\n    axesEvent: OnChange;\n    transitTo: (nextState: STATE_TYPE) => State;\n  }): void {\n    // DO NOTHING\n  }\n\n  /**\n   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event\n   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트 핸들러\n   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>\n   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>\n   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of Axes\n   * <ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>\n   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>\n   * @return {void}\n   */\n  public onRelease(ctx: {\n    flicking: Flicking;\n    axesEvent: OnRelease;\n    transitTo: (nextState: STATE_TYPE) => State;\n  }): void {\n    // DO NOTHING\n  }\n\n  /**\n   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} event\n   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} 이벤트 핸들러\n   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>\n   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>\n   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} event of Axes\n   * <ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} 이벤트</ko>\n   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>\n   * @return {void}\n   */\n  public onAnimationEnd(ctx: {\n    flicking: Flicking;\n    axesEvent: OnAnimationEnd;\n    transitTo: (nextState: STATE_TYPE) => State;\n  }): void {\n    // DO NOTHING\n  }\n\n  /**\n   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} event\n   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} 이벤트 핸들러\n   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>\n   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>\n   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} event of Axes<ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} 이벤트</ko>\n   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>\n   * @return {void}\n   */\n  public onFinish(ctx: {\n    flicking: Flicking;\n    axesEvent: OnFinish;\n    transitTo: (nextState: STATE_TYPE) => State;\n  }): void {\n    // DO NOTHING\n  }\n\n  protected _moveToChangedPosition(ctx: Parameters<State[\"onChange\"]>[0]): void {\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    if (!axesEvent.delta[AXES.POSITION_KEY]) {\n      return;\n    }\n\n    const camera = flicking.camera;\n    const prevPosition = camera.position;\n    const position = axesEvent.pos[AXES.POSITION_KEY];\n    const newPosition = flicking.circularEnabled\n      ? circulatePosition(position, camera.range.min, camera.range.max)\n      : position;\n\n    void camera.lookAt(newPosition);\n\n    const moveEvent = new ComponentEvent(EVENTS.MOVE, {\n      isTrusted: axesEvent.isTrusted,\n      holding: this.holding,\n      direction: getDirection(0, axesEvent.delta[AXES.POSITION_KEY]),\n      axesEvent\n    });\n\n    flicking.trigger(moveEvent);\n\n    if (moveEvent.isCanceled()) {\n      // Return to previous position\n      void camera.lookAt(prevPosition);\n      transitTo(STATE_TYPE.DISABLED);\n    }\n  }\n}\n\nexport default State;\n","/**\n * All possible @egjs/axes event keys\n * @internal\n */\nexport const EVENT = {\n  HOLD: \"hold\",\n  CHANGE: \"change\",\n  RELEASE: \"release\",\n  ANIMATION_END: \"animationEnd\",\n  FINISH: \"finish\"\n} as const;\n\n/**\n * An Axis key that Flicking uses\n * @internal\n */\nexport const POSITION_KEY = \"flick\";\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport { EVENTS } from \"../../const/external\";\nimport { getDirection } from \"../../utils\";\n\nimport State, { STATE_TYPE } from \"./State\";\n\n/**\n * A default state when there's no user input and no animation's playing\n * @ko 사용자의 입력이 없고, 애니메이션이 동작하고있지 않은 기본 상태\n * @internal\n */\nclass IdleState extends State {\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {false}\n   * @readonly\n   */\n  public readonly holding = false;\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {false}\n   * @readonly\n   */\n  public readonly animating = false;\n\n  public onHold(ctx: Parameters<State[\"onHold\"]>[0]): void {\n    // Shouldn't do any action until any panels on flicking area\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    if (flicking.renderer.panelCount <= 0) {\n      transitTo(STATE_TYPE.DISABLED);\n      return;\n    }\n\n    const holdStartEvent = new ComponentEvent(EVENTS.HOLD_START, {\n      axesEvent\n    });\n\n    flicking.trigger(holdStartEvent);\n\n    if (holdStartEvent.isCanceled()) {\n      transitTo(STATE_TYPE.DISABLED);\n    } else {\n      transitTo(STATE_TYPE.HOLDING);\n    }\n  }\n\n  // By methods call\n  public onChange(ctx: Parameters<State[\"onChange\"]>[0]): void {\n    const { flicking, axesEvent, transitTo } = ctx;\n    const controller = flicking.control.controller;\n    const animatingContext = controller.animatingContext;\n\n    const moveStartEvent = new ComponentEvent(EVENTS.MOVE_START, {\n      isTrusted: axesEvent.isTrusted,\n      holding: this.holding,\n      direction: getDirection(animatingContext.start, animatingContext.end),\n      axesEvent\n    });\n    flicking.trigger(moveStartEvent);\n\n    if (moveStartEvent.isCanceled()) {\n      transitTo(STATE_TYPE.DISABLED);\n    } else {\n      // Trigger AnimatingState's onChange, to trigger \"move\" event immediately\n      transitTo(STATE_TYPE.ANIMATING).onChange(ctx);\n    }\n  }\n}\n\nexport default IdleState;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { OnRelease } from \"@egjs/axes\";\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport Panel from \"../../core/panel/Panel\";\nimport { EVENTS } from \"../../const/external\";\nimport { getDirection } from \"../../utils\";\n\nimport State, { STATE_TYPE } from \"./State\";\n\n/**\n * A state that activates when user's holding the Flicking area, but not moved a single pixel yet\n * @ko 사용자의 입력이 시작되었으나, 아직 움직이지는 않은 상태\n * @internal\n */\nclass HoldingState extends State {\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {true}\n   * @readonly\n   */\n  public readonly holding = true;\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {false}\n   * @readonly\n   */\n  public readonly animating = false;\n\n  private _releaseEvent: OnRelease | null = null;\n\n  public onChange(ctx: Parameters<State[\"onChange\"]>[0]): void {\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    const inputEvent = axesEvent.inputEvent as { offsetX: number; offsetY: number };\n\n    const offset = flicking.horizontal\n      ? inputEvent.offsetX\n      : inputEvent.offsetY;\n\n    const moveStartEvent = new ComponentEvent(EVENTS.MOVE_START, {\n      isTrusted: axesEvent.isTrusted,\n      holding: this.holding,\n      direction: getDirection(0, -offset),\n      axesEvent\n    });\n    flicking.trigger(moveStartEvent);\n\n    if (moveStartEvent.isCanceled()) {\n      transitTo(STATE_TYPE.DISABLED);\n    } else {\n      // Trigger DraggingState's onChange, to trigger \"move\" event immediately\n      transitTo(STATE_TYPE.DRAGGING).onChange(ctx);\n    }\n  }\n\n  public onRelease(ctx: Parameters<State[\"onRelease\"]>[0]): void {\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    flicking.trigger(new ComponentEvent(EVENTS.HOLD_END, { axesEvent }));\n\n    if (axesEvent.delta.flick !== 0) {\n      // Sometimes \"release\" event on axes triggered before \"change\" event\n      // Especially if user flicked panel fast in really short amount of time\n      // if delta is not zero, that means above case happened.\n\n      // Event flow should be HOLD_START -> MOVE_START -> MOVE -> HOLD_END\n      // At least one move event should be included between holdStart and holdEnd\n      axesEvent.setTo({ flick: flicking.camera.position }, 0);\n      transitTo(STATE_TYPE.IDLE);\n      return;\n    }\n\n    // Can't handle select event here,\n    // As \"finish\" axes event happens\n    this._releaseEvent = axesEvent;\n  }\n\n  public onFinish(ctx: Parameters<State[\"onFinish\"]>[0]): void {\n    const { flicking, transitTo } = ctx;\n\n    // Should transite to IDLE state before select event\n    // As user expects hold is already finished\n    transitTo(STATE_TYPE.IDLE);\n\n    if (!this._releaseEvent) {\n      return;\n    }\n\n    // Handle release event here\n    // To prevent finish event called twice\n    const releaseEvent = this._releaseEvent;\n\n    // Static click\n    /* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access */\n    const srcEvent = releaseEvent.inputEvent.srcEvent;\n\n    let clickedElement: HTMLElement;\n    if (srcEvent.type === \"touchend\") {\n      const touchEvent = srcEvent as TouchEvent;\n      const touch = touchEvent.changedTouches[0];\n      clickedElement = document.elementFromPoint(touch.clientX, touch.clientY) as HTMLElement;\n    } else {\n      clickedElement = srcEvent.target;\n    }\n    /* eslint-enable */\n\n    const panels = flicking.renderer.panels;\n    let clickedPanel: Panel | null = null;\n\n    for (const panel of panels) {\n      if (panel.contains(clickedElement)) {\n        clickedPanel = panel;\n        break;\n      }\n    }\n\n    if (clickedPanel) {\n      const cameraPosition = flicking.camera.position;\n      const clickedPanelPosition = clickedPanel.position;\n\n      flicking.trigger(new ComponentEvent(EVENTS.SELECT, {\n        index: clickedPanel.index,\n        panel: clickedPanel,\n        // Direction to the clicked panel\n        direction: getDirection(cameraPosition, clickedPanelPosition)\n      }));\n    }\n  }\n}\n\nexport default HoldingState;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport { EVENTS } from \"../../const/external\";\nimport * as AXES from \"../../const/axes\";\n\nimport State, { STATE_TYPE } from \"./State\";\n\n/**\n * A state that activates when user's dragging the Flicking area\n * @ko 사용자가 드래깅중인 상태\n * @internal\n */\nclass DraggingState extends State {\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {true}\n   * @readonly\n   */\n  public readonly holding = true;\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {true}\n   * @readonly\n   */\n  public readonly animating = true;\n\n  public onChange(ctx: Parameters<State[\"onChange\"]>[0]): void {\n    this._moveToChangedPosition(ctx);\n  }\n\n  public onRelease(ctx: Parameters<State[\"onRelease\"]>[0]): void {\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    // Update last position to cope with Axes's animating behavior\n    // Axes uses start position when animation start\n    flicking.trigger(new ComponentEvent(EVENTS.HOLD_END, {\n      axesEvent\n    }));\n\n    if (flicking.renderer.panelCount <= 0) {\n      // There're no panels\n      transitTo(STATE_TYPE.IDLE);\n      return;\n    }\n\n    transitTo(STATE_TYPE.ANIMATING);\n\n    const control = flicking.control;\n    const position = axesEvent.destPos[AXES.POSITION_KEY];\n    const duration = Math.max(axesEvent.duration, flicking.duration);\n\n    void control.moveToPosition(position, duration, axesEvent);\n  }\n}\n\nexport default DraggingState;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport { EVENTS } from \"../../const/external\";\nimport { getDirection } from \"../../utils\";\n\nimport State, { STATE_TYPE } from \"./State\";\n\n/**\n * A state that activates when Flicking's animating by user input or method call\n * @ko 사용자 입력이나 메소드 호출에 의해 Flicking의 애니메이션이 동작중인 상태\n * @internal\n */\nclass AnimatingState extends State {\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {false}\n   * @readonly\n   */\n  public readonly holding = false;\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {true}\n   * @readonly\n   */\n  public readonly animating = true;\n\n  public onHold(ctx: Parameters<State[\"onHold\"]>[0]): void {\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    flicking.control.updateInput();\n    const holdStartEvent = new ComponentEvent(EVENTS.HOLD_START, { axesEvent });\n    flicking.trigger(holdStartEvent);\n\n    if (holdStartEvent.isCanceled()) {\n      transitTo(STATE_TYPE.DISABLED);\n    } else {\n      transitTo(STATE_TYPE.DRAGGING);\n    }\n  }\n\n  public onChange(ctx: Parameters<State[\"onChange\"]>[0]): void {\n    this._moveToChangedPosition(ctx);\n  }\n\n  public onFinish(ctx: Parameters<State[\"onFinish\"]>[0]) {\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    transitTo(STATE_TYPE.IDLE);\n\n    const controller = flicking.control.controller;\n    const animatingContext = controller.animatingContext;\n\n    flicking.trigger(new ComponentEvent(EVENTS.MOVE_END, {\n      isTrusted: axesEvent.isTrusted,\n      direction: getDirection(animatingContext.start, animatingContext.end),\n      axesEvent\n    }));\n  }\n}\n\nexport default AnimatingState;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport State, { STATE_TYPE } from \"./State\";\n\n/**\n * A state that activates when Flicking is stopped by event's `stop` method\n * @ko 이벤트의 `stop`호출에 의해 Flicking이 정지된 상태\n * @internal\n */\nclass DisabledState extends State {\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {false}\n   * @readonly\n   */\n  public readonly holding = false;\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {true}\n   * @readonly\n   */\n  public readonly animating = true;\n\n  public onAnimationEnd(ctx: Parameters<State[\"onAnimationEnd\"]>[0]): void {\n    const { transitTo } = ctx;\n\n    transitTo(STATE_TYPE.IDLE);\n  }\n\n  public onChange(ctx: Parameters<State[\"onChange\"]>[0]): void {\n    const { axesEvent, transitTo } = ctx;\n\n    // Can stop Axes's change event\n    axesEvent.stop();\n\n    transitTo(STATE_TYPE.IDLE);\n  }\n\n  public onRelease(ctx: Parameters<State[\"onRelease\"]>[0]): void {\n    const { axesEvent, transitTo } = ctx;\n\n    // This is needed when stopped hold start event\n    if (axesEvent.delta.flick === 0) {\n      transitTo(STATE_TYPE.IDLE);\n    }\n  }\n}\n\nexport default DisabledState;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { AxesEvents } from \"@egjs/axes\";\n\nimport Flicking from \"../Flicking\";\nimport * as AXES from \"../const/axes\";\n\nimport IdleState from \"./states/IdleState\";\nimport HoldingState from \"./states/HoldingState\";\nimport DraggingState from \"./states/DraggingState\";\nimport AnimatingState from \"./states/AnimatingState\";\nimport DisabledState from \"./states/DisabledState\";\nimport State, { STATE_TYPE } from \"./states/State\";\n\n/**\n * @internal\n */\nclass StateMachine {\n  private _state: State;\n\n  public get state(): State { return this._state; }\n\n  public constructor() {\n    this._state = new IdleState();\n  }\n\n  public fire(eventType: keyof AxesEvents, externalCtx: {\n    flicking: Flicking;\n    axesEvent: any;\n  }) {\n    const currentState = this._state;\n    const ctx = { ...externalCtx, transitTo: this.transitTo };\n\n    switch (eventType) {\n      case AXES.EVENT.HOLD:\n        currentState.onHold(ctx);\n        break;\n      case AXES.EVENT.CHANGE:\n        currentState.onChange(ctx);\n        break;\n      case AXES.EVENT.RELEASE:\n        currentState.onRelease(ctx);\n        break;\n      case AXES.EVENT.ANIMATION_END:\n        currentState.onAnimationEnd(ctx);\n        break;\n      case AXES.EVENT.FINISH:\n        currentState.onFinish(ctx);\n        break;\n    }\n  }\n\n  public transitTo = (nextStateType: STATE_TYPE): State => {\n    let nextState: State;\n\n    switch (nextStateType) {\n      case STATE_TYPE.IDLE:\n        nextState = new IdleState();\n        break;\n      case STATE_TYPE.HOLDING:\n        nextState = new HoldingState();\n        break;\n      case STATE_TYPE.DRAGGING:\n        nextState = new DraggingState();\n        break;\n      case STATE_TYPE.ANIMATING:\n        nextState = new AnimatingState();\n        break;\n      case STATE_TYPE.DISABLED:\n        nextState = new DisabledState();\n        break;\n    }\n\n    this._state = nextState;\n\n    return this._state;\n  };\n}\n\nexport default StateMachine;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Axes, { PanInput, AxesEvents, OnRelease } from \"@egjs/axes\";\n\nimport Flicking from \"../Flicking\";\nimport FlickingError from \"../core/FlickingError\";\nimport * as AXES from \"../const/axes\";\nimport * as ERROR from \"../const/error\";\nimport { getFlickingAttached, parseBounce } from \"../utils\";\nimport { ControlParams } from \"../type/external\";\n\nimport StateMachine from \"./StateMachine\";\n\n/**\n * A controller that handles the {@link https://naver.github.io/egjs-axes/ @egjs/axes} events\n * @ko {@link https://naver.github.io/egjs-axes/ @egjs/axes}의 이벤트를 처리하는 컨트롤러 컴포넌트\n * @internal\n */\nclass AxesController {\n  private _flicking: Flicking | null;\n  private _axes: Axes | null;\n  private _panInput: PanInput | null;\n  private _stateMachine: StateMachine;\n\n  private _animatingContext: { start: number; end: number; offset: number };\n  private _dragged: boolean;\n\n  /**\n   * An {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} instance\n   * @ko {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes}의 인스턴스\n   * @type {Axes}\n   * @see https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html\n   * @readonly\n   */\n  public get axes() { return this._axes; }\n  /**\n   * A activated {@link State} that shows the current status of the user input or the animation\n   * @ko 현재 활성화된 {@link State} 인스턴스로 사용자 입력 또는 애니메이션 상태를 나타냅니다\n   * @type {State}\n   */\n  public get state() { return this._stateMachine.state; }\n  /**\n   * A context of the current animation playing\n   * @ko 현재 재생중인 애니메이션 정보\n   * @type {object}\n   * @property {number} start A start position of the animation<ko>애니메이션 시작 지점</ko>\n   * @property {number} end A end position of the animation<ko>애니메이션 끝 지점</ko>\n   * @property {number} offset camera offset<ko>카메라 오프셋</ko>\n   * @readonly\n   */\n  public get animatingContext() { return this._animatingContext; }\n  /**\n   * A current control parameters of the Axes instance\n   * @ko 활성화된 현재 Axes 패러미터들\n   * @type {ControlParams}\n   */\n  public get controlParams(): ControlParams {\n    const axes = this._axes;\n\n    if (!axes) {\n      return {\n        range: { min: 0, max: 0 },\n        position: 0,\n        circular: false\n      };\n    }\n\n    const axis = axes.axis[AXES.POSITION_KEY];\n\n    return {\n      range: { min: axis.range![0], max: axis.range![1] },\n      circular: (axis.circular as boolean[])[0],\n      position: this.position\n    };\n  }\n\n  /**\n   * A Boolean indicating whether the user input is enabled\n   * @ko 현재 사용자 입력이 활성화되었는지를 나타내는 값\n   * @type {boolean}\n   * @readonly\n   */\n  public get enabled() { return this._panInput?.isEnable() ?? false; }\n  /**\n   * Current position value in {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} instance\n   * @ko {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} 인스턴스 내부의 현재 좌표 값\n   * @type {number}\n   * @readonly\n   */\n  public get position() { return this._axes?.get([AXES.POSITION_KEY])[AXES.POSITION_KEY] ?? 0; }\n  /**\n   * Current range value in {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} instance\n   * @ko {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} 인스턴스 내부의 현재 이동 범위 값\n   * @type {number[]}\n   * @readonly\n   */\n  public get range() { return this._axes?.axis[AXES.POSITION_KEY].range ?? [0, 0]; }\n  /**\n   * Actual bounce size(px)\n   * @ko 적용된 bounce 크기(px 단위)\n   * @type {number[]}\n   * @readonly\n   */\n  public get bounce() { return this._axes?.axis[AXES.POSITION_KEY].bounce as number[] | undefined; }\n\n  /** */\n  public constructor() {\n    this._resetInternalValues();\n    this._stateMachine = new StateMachine();\n  }\n\n  /**\n   * Initialize AxesController\n   * @ko AxesController를 초기화합니다\n   * @param {Flicking} flicking An instance of Flicking\n   * @chainable\n   * @return {this}\n   */\n  public init(flicking: Flicking): this {\n    this._flicking = flicking;\n\n    this._axes = new Axes({\n      [AXES.POSITION_KEY]: {\n        range: [0, 0],\n        circular: false,\n        bounce: [0, 0]\n      }\n    }, {\n      deceleration: flicking.deceleration,\n      interruptable: flicking.interruptable,\n      easing: flicking.easing\n    });\n    this._panInput = new PanInput(flicking.viewport.element, {\n      inputType: flicking.inputType,\n      iOSEdgeSwipeThreshold: flicking.iOSEdgeSwipeThreshold,\n      scale: flicking.horizontal ? [-1, 0] : [0, -1],\n      releaseOnScroll: true\n    });\n\n    const axes = this._axes;\n\n    axes.connect(flicking.horizontal ? [AXES.POSITION_KEY, \"\"] : [\"\", AXES.POSITION_KEY], this._panInput);\n\n    for (const key in AXES.EVENT) {\n      const eventType = AXES.EVENT[key] as keyof AxesEvents;\n\n      axes.on(eventType, (e: AxesEvents[typeof eventType]) => {\n        this._stateMachine.fire(eventType, {\n          flicking,\n          axesEvent: e\n        });\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Destroy AxesController and return to initial state\n   * @ko AxesController를 초기 상태로 되돌립니다\n   * @return {void}\n   */\n  public destroy(): void {\n    this.removePreventClickHandler();\n\n    this._axes?.destroy();\n    this._panInput?.destroy();\n\n    this._resetInternalValues();\n  }\n\n  /**\n   * Enable input from the user (mouse/touch)\n   * @ko 사용자의 입력(마우스/터치)를 활성화합니다\n   * @chainable\n   * @return {this}\n   */\n  public enable(): this {\n    this._panInput?.enable();\n\n    return this;\n  }\n\n  /**\n   * Disable input from the user (mouse/touch)\n   * @ko 사용자의 입력(마우스/터치)를 막습니다\n   * @chainable\n   * @return {this}\n   */\n  public disable(): this {\n    this._panInput?.disable();\n\n    return this;\n  }\n\n  /**\n   * Update {@link https://naver.github.io/egjs-axes/ @egjs/axes}'s state\n   * @ko {@link https://naver.github.io/egjs-axes/ @egjs/axes}의 상태를 갱신합니다\n   * @chainable\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link AxesController#init init} is not called before\n   * <ko>{@link AxesController#init init}이 이전에 호출되지 않은 경우</ko>\n   * @return {this}\n   */\n  public update(controlParams: ControlParams): this {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const camera = flicking.camera;\n    const axes = this._axes!;\n    const axis = axes.axis[AXES.POSITION_KEY];\n\n    axis.circular = [controlParams.circular, controlParams.circular];\n    axis.range = [controlParams.range.min, controlParams.range.max];\n    axis.bounce = parseBounce(flicking.bounce, camera.size);\n\n    axes.axm.set({ [AXES.POSITION_KEY]: controlParams.position });\n\n    return this;\n  }\n\n  public addPreventClickHandler() {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const axes = this._axes!;\n    const cameraEl = flicking.camera.element;\n\n    axes.on(AXES.EVENT.HOLD, this._onAxesHold);\n    axes.on(AXES.EVENT.CHANGE, this._onAxesChange);\n    cameraEl.addEventListener(\"click\", this._preventClickWhenDragged, true);\n  }\n\n  public removePreventClickHandler() {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const axes = this._axes!;\n    const cameraEl = flicking.camera.element;\n\n    axes.off(AXES.EVENT.HOLD, this._onAxesHold);\n    axes.off(AXES.EVENT.CHANGE, this._onAxesChange);\n    cameraEl.removeEventListener(\"click\", this._preventClickWhenDragged, true);\n  }\n\n  /**\n   * Run Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#setTo setTo} using the given position\n   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#setTo setTo} 메소드를 주어진 좌표를 이용하여 수행합니다\n   * @param {number} position A position to move<ko>이동할 좌표</ko>\n   * @param {number} duration Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {number} [axesEvent] If provided, it'll use its {@link https://naver#github#io/egjs-axes/release/latest/doc/eg#Axes#html#setTo setTo} method instead<ko>이 값이 주어졌을 경우, 해당 이벤트의 {@link https://naver#github#io/egjs-axes/release/latest/doc/eg#Axes#html#setTo setTo} 메소드를 대신해서 사용합니다.</ko>\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>\n   */\n  public animateTo(position: number, duration: number, axesEvent?: OnRelease): Promise<void> {\n    const axes = this._axes;\n\n    if (!axes) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.NOT_ATTACHED_TO_FLICKING(\"Control\"), ERROR.CODE.NOT_ATTACHED_TO_FLICKING));\n    }\n\n    const startPos = axes.get([AXES.POSITION_KEY])[AXES.POSITION_KEY];\n\n    if (startPos === position) {\n      const flicking = getFlickingAttached(this._flicking, \"Control\");\n\n      return flicking.camera.lookAt(position);\n    }\n\n    this._animatingContext = {\n      start: startPos,\n      end: position,\n      offset: 0\n    };\n\n    const animate = () => {\n      const resetContext = () => {\n        this._animatingContext = { start: 0, end: 0, offset: 0 };\n      };\n\n      axes.once(AXES.EVENT.FINISH, resetContext);\n\n      if (axesEvent) {\n        axesEvent.setTo({ [AXES.POSITION_KEY]: position }, duration);\n      } else {\n        axes.setTo({ [AXES.POSITION_KEY]: position }, duration);\n      }\n    };\n\n    if (duration === 0) {\n      animate();\n      axes.axm.set({ [AXES.POSITION_KEY]: position });\n\n      return Promise.resolve();\n    } else {\n      return new Promise((resolve, reject) => {\n        const animationFinishHandler = () => {\n          axes.off(AXES.EVENT.HOLD, interruptionHandler);\n          resolve();\n        };\n\n        const interruptionHandler = () => {\n          axes.off(AXES.EVENT.FINISH, animationFinishHandler);\n          reject(new FlickingError(ERROR.MESSAGE.ANIMATION_INTERRUPTED, ERROR.CODE.ANIMATION_INTERRUPTED));\n        };\n\n        axes.once(AXES.EVENT.FINISH, animationFinishHandler);\n        axes.once(AXES.EVENT.HOLD, interruptionHandler);\n\n        animate();\n      });\n    }\n  }\n\n  private _resetInternalValues() {\n    this._flicking = null;\n    this._axes = null;\n    this._panInput = null;\n    this._animatingContext = { start: 0, end: 0, offset: 0 };\n    this._dragged = false;\n  }\n\n  private _onAxesHold = () => {\n    this._dragged = false;\n  };\n\n  private _onAxesChange = () => {\n    this._dragged = true;\n  };\n\n  private _preventClickWhenDragged = (e: MouseEvent) => {\n    if (this._dragged) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n\n    this._dragged = false;\n  };\n}\n\nexport default AxesController;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { OnRelease } from \"@egjs/axes\";\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport Flicking from \"../Flicking\";\nimport FlickingError from \"../core/FlickingError\";\nimport Panel from \"../core/panel/Panel\";\nimport AxesController from \"../control/AxesController\";\nimport { DIRECTION, EVENTS } from \"../const/external\";\nimport * as ERROR from \"../const/error\";\nimport { getDirection, getFlickingAttached } from \"../utils\";\nimport { ValueOf } from \"../type/internal\";\n\n/**\n * A component that manages inputs and animation of Flicking\n * @ko Flicking의 입력 장치 & 애니메이션을 담당하는 컴포넌트\n */\nabstract class Control {\n  // Internal States\n  protected _flicking: Flicking | null;\n  protected _controller: AxesController;\n  protected _activePanel: Panel | null;\n\n  /**\n   * A controller that handles the {@link https://naver.github.io/egjs-axes/ @egjs/axes} events\n   * @ko {@link https://naver.github.io/egjs-axes/ @egjs/axes}의 이벤트를 처리하는 컨트롤러 컴포넌트\n   * @type {AxesController}\n   * @readonly\n   */\n  public get controller() { return this._controller; }\n  /**\n   * Index number of the {@link Flicking#currentPanel currentPanel}\n   * @ko {@link Flicking#currentPanel currentPanel}의 인덱스 번호\n   * @type {number}\n   * @default 0\n   * @readonly\n   */\n  public get activeIndex() { return this._activePanel?.index ?? -1; }\n  /**\n   * An active panel\n   * @ko 현재 선택된 패널\n   * @type {Panel | null}\n   * @readonly\n   */\n  public get activePanel() { return this._activePanel; }\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {boolean}\n   * @readonly\n   */\n  public get animating() { return this._controller.state.animating; }\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {boolean}\n   * @readonly\n   */\n  public get holding() { return this._controller.state.holding; }\n\n  /** */\n  public constructor() {\n    this._flicking = null;\n    this._controller = new AxesController();\n    this._activePanel = null;\n  }\n\n  /**\n   * Move {@link Camera} to the given position\n   * @ko {@link Camera}를 주어진 좌표로 이동합니다\n   * @method\n   * @abstract\n   * @memberof Control\n   * @instance\n   * @name moveToPosition\n   * @param {number} position The target position to move<ko>이동할 좌표</ko>\n   * @param {number} duration Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}\n   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>\n   */\n  public abstract moveToPosition(position: number, duration: number, axesEvent?: OnRelease): Promise<void>;\n\n  /**\n   * Initialize Control\n   * @ko Control을 초기화합니다\n   * @param {Flicking} flicking An instance of {@link Flicking}<ko>Flicking의 인스턴스</ko>\n   * @chainable\n   * @return {this}\n   */\n  public init(flicking: Flicking): this {\n    this._flicking = flicking;\n    this._controller.init(flicking);\n\n    return this;\n  }\n\n  /**\n   * Destroy Control and return to initial state\n   * @ko Control을 초기 상태로 되돌립니다\n   * @return {void}\n   */\n  public destroy(): void {\n    this._controller.destroy();\n\n    this._flicking = null;\n    this._activePanel = null;\n  }\n\n  /**\n   * Enable input from the user (mouse/touch)\n   * @ko 사용자의 입력(마우스/터치)를 활성화합니다\n   * @chainable\n   * @return {this}\n   */\n  public enable(): this {\n    this._controller.enable();\n\n    return this;\n  }\n\n  /**\n   * Disable input from the user (mouse/touch)\n   * @ko 사용자의 입력(마우스/터치)를 막습니다\n   * @chainable\n   * @return {this}\n   */\n  public disable(): this {\n    this._controller.disable();\n\n    return this;\n  }\n\n  /**\n   * Update position after resizing\n   * @ko resize 이후에 position을 업데이트합니다\n   * @param {number} progressInPanel Previous camera's progress in active panel before resize<ko>Resize 이전 현재 선택된 패널 내에서의 카메라 progress 값</ko>\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @chainable\n   * @return {Promise<void>}\n   */\n  public async updatePosition(_progressInPanel: number): Promise<void> {   // eslint-disable-line @typescript-eslint/no-unused-vars\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const camera = flicking.camera;\n    const activePanel = this._activePanel;\n\n    if (activePanel) {\n      await camera.lookAt(camera.clampToReachablePosition(activePanel.position));\n    }\n  }\n\n  /**\n   * Update {@link Control#controller controller}'s state\n   * @ko {@link Control#controller controller}의 내부 상태를 갱신합니다\n   * @chainable\n   * @return {this}\n   */\n  public updateInput(): this {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const camera = flicking.camera;\n\n    this._controller.update(camera.controlParams);\n\n    return this;\n  }\n\n  /**\n   * Reset {@link Control#activePanel activePanel} to `null`\n   * @ko {@link Control#activePanel activePanel}을 `null`로 초기화합니다\n   * @chainable\n   * @return {this}\n   */\n  public resetActive(): this {\n    this._activePanel = null;\n\n    return this;\n  }\n\n  /**\n   * Move {@link Camera} to the given panel\n   * @ko {@link Camera}를 해당 패널 위로 이동합니다\n   * @param {Panel} panel The target panel to move<ko>이동할 패널</ko>\n   * @param {object} options An options object<ko>옵션 오브젝트</ko>\n   * @param {number} duration Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}\n   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>\n   * @param {DIRECTION} [direction=DIRECTION.NONE] Direction to move, only available in the {@link Flicking#circular circular} mode<ko>이동할 방향. {@link Flicking#circular circular} 옵션 활성화시에만 사용 가능합니다</ko>\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target panel<ko>해당 패널 도달시에 resolve되는 Promise</ko>\n   */\n  public async moveToPanel(panel: Panel, {\n    duration,\n    direction = DIRECTION.NONE,\n    axesEvent\n  }: {\n    duration: number;\n    direction?: ValueOf<typeof DIRECTION>;\n    axesEvent?: OnRelease;\n  }) {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const camera = flicking.camera;\n\n    let position = panel.position;\n    const nearestAnchor = camera.findNearestAnchor(position);\n\n    if (panel.removed || !nearestAnchor) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.POSITION_NOT_REACHABLE(panel.position), ERROR.CODE.POSITION_NOT_REACHABLE));\n    }\n    if (!camera.canReach(panel)) {\n      // Override position & panel if that panel is not reachable\n      position = nearestAnchor.position;\n      panel = nearestAnchor.panel;\n    } else if (flicking.circularEnabled) {\n      // Circular mode is enabled, find nearest distance to panel\n      const camPos = this._controller.position; // Actual position of the Axes\n      const camRangeDiff = camera.rangeDiff;\n      const possiblePositions = [position, position + camRangeDiff, position - camRangeDiff]\n        .filter(pos => {\n          if (direction === DIRECTION.NONE) return true;\n\n          return direction === DIRECTION.PREV\n            ? pos <= camPos\n            : pos >= camPos;\n        });\n\n      position = possiblePositions.reduce((nearestPosition, pos) => {\n        if (Math.abs(camPos - pos) < Math.abs(camPos - nearestPosition)) {\n          return pos;\n        } else {\n          return nearestPosition;\n        }\n      }, Infinity);\n    }\n\n    this._triggerIndexChangeEvent(panel, panel.position, axesEvent);\n\n    return this._animateToPosition({ position, duration, newActivePanel: panel, axesEvent });\n  }\n\n  protected _triggerIndexChangeEvent(panel: Panel, position: number, axesEvent?: OnRelease): void {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const triggeringEvent = panel !== this._activePanel ? EVENTS.WILL_CHANGE : EVENTS.WILL_RESTORE;\n    const camera = flicking.camera;\n    const activePanel = this._activePanel;\n\n    const event = new ComponentEvent(triggeringEvent, {\n      index: panel.index,\n      panel,\n      isTrusted: axesEvent?.isTrusted || false,\n      direction: getDirection(activePanel?.position ?? camera.position, position)\n    });\n    flicking.trigger(event);\n\n    if (event.isCanceled()) {\n      throw new FlickingError(ERROR.MESSAGE.STOP_CALLED_BY_USER, ERROR.CODE.STOP_CALLED_BY_USER);\n    }\n  }\n\n  protected async _animateToPosition({\n    position,\n    duration,\n    newActivePanel,\n    axesEvent\n  }: {\n    position: number;\n    duration: number;\n    newActivePanel: Panel;\n    axesEvent?: OnRelease;\n  }) {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const currentPanel = this._activePanel;\n    const animate = () => this._controller.animateTo(position, duration, axesEvent);\n    const isTrusted = axesEvent?.isTrusted || false;\n\n    if (duration <= 0) {\n      const animation = animate();\n      this._setActive(newActivePanel, currentPanel, isTrusted);\n      return animation;\n    } else {\n      return animate().then(async () => {\n        this._setActive(newActivePanel, currentPanel, isTrusted);\n        await flicking.renderer.render();\n      }).catch(err => {\n        if (axesEvent && err instanceof FlickingError && err.code === ERROR.CODE.ANIMATION_INTERRUPTED) return;\n        throw err;\n      });\n    }\n  }\n\n  protected _setActive(newActivePanel: Panel, prevActivePanel: Panel | null, isTrusted: boolean) {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n\n    this._activePanel = newActivePanel;\n\n    flicking.camera.updateAdaptiveHeight();\n\n    if (newActivePanel !== prevActivePanel) {\n      flicking.trigger(new ComponentEvent(EVENTS.CHANGED, {\n        index: newActivePanel.index,\n        panel: newActivePanel,\n        prevIndex: prevActivePanel?.index ?? -1,\n        prevPanel: prevActivePanel,\n        isTrusted,\n        direction: prevActivePanel ? getDirection(prevActivePanel.position, newActivePanel.position) : DIRECTION.NONE\n      }));\n    } else {\n      flicking.trigger(new ComponentEvent(EVENTS.RESTORED, {\n        isTrusted\n      }));\n    }\n  }\n}\n\nexport default Control;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { OnRelease } from \"@egjs/axes\";\n\nimport Panel from \"../core/panel/Panel\";\nimport FlickingError from \"../core/FlickingError\";\nimport { getFlickingAttached } from \"../utils\";\nimport * as ERROR from \"../const/error\";\n\nimport Control from \"./Control\";\n\n/**\n * A {@link Control} that uses a release momentum to choose destination panel\n * @ko 입력을 중단한 시점의 가속도에 영향받아 도달할 패널을 계산하는 이동 방식을 사용하는 {@link Control}\n */\nclass SnapControl extends Control {\n  /**\n   * Move {@link Camera} to the given position\n   * @ko {@link Camera}를 주어진 좌표로 이동합니다\n   * @param {number} position The target position to move<ko>이동할 좌표</ko>\n   * @param {number} duration Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}\n   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>\n   */\n  public async moveToPosition(position: number, duration: number, axesEvent?: OnRelease) {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const camera = flicking.camera;\n    const activePanel = this._activePanel;\n\n    const clampedPosition = camera.clampToReachablePosition(position);\n    const anchorAtPosition = camera.findNearestAnchor(clampedPosition);\n\n    if (!anchorAtPosition || !activePanel) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.POSITION_NOT_REACHABLE(position), ERROR.CODE.POSITION_NOT_REACHABLE));\n    }\n\n    const prevPos = activePanel.position;\n\n    const isOverThreshold = Math.abs(position - prevPos) >= flicking.threshold;\n    const adjacentAnchor = (position > prevPos)\n      ? camera.getNextAnchor(anchorAtPosition)\n      : camera.getPrevAnchor(anchorAtPosition);\n\n    let targetPos: number;\n    let targetPanel: Panel;\n\n    if (isOverThreshold && anchorAtPosition.position !== activePanel.position) {\n      // Move to anchor at position\n      targetPanel = anchorAtPosition.panel;\n      targetPos = anchorAtPosition.position;\n    } else if (isOverThreshold && adjacentAnchor) {\n      // Move to adjacent anchor\n      targetPanel = adjacentAnchor.panel;\n      targetPos = adjacentAnchor.position;\n    } else {\n      // Restore to active panel\n      targetPos = camera.clampToReachablePosition(activePanel.position);\n      targetPanel = activePanel;\n    }\n\n    this._triggerIndexChangeEvent(targetPanel, position, axesEvent);\n\n    return this._animateToPosition({\n      position: targetPos,\n      duration,\n      newActivePanel: targetPanel,\n      axesEvent\n    });\n  }\n}\n\nexport default SnapControl;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { OnRelease } from \"@egjs/axes\";\n\nimport FlickingError from \"../core/FlickingError\";\nimport * as ERROR from \"../const/error\";\nimport { getFlickingAttached } from \"../utils\";\n\nimport Control from \"./Control\";\n\n/**\n * An options for the {@link FreeControl}\n * @ko {@link FreeControl} 생성시 사용되는 옵션\n * @interface\n * @property {boolean} stopAtEdge Make scroll animation to stop at the start/end of the scroll area, not going out the bounce area\n * <ko>스크롤 애니메이션을 스크롤 영역의 시작과 끝부분에서 멈추도록 하여, 바운스 영역을 넘어가지 않도록 합니다</ko>\n */\nexport interface FreeControlOptions {\n  stopAtEdge: boolean;\n}\n\n/**\n * A {@link Control} that can be scrolled freely without alignment\n * @ko 패널이 정해진 지점에 정렬되지 않고, 자유롭게 스크롤할 수 있는 이동 방식을 사용하는 {@link Control}\n */\nclass FreeControl extends Control {\n  private _stopAtEdge: FreeControlOptions[\"stopAtEdge\"];\n\n  /**\n   * Make scroll animation to stop at the start/end of the scroll area, not going out the bounce area\n   * @ko 스크롤 애니메이션을 스크롤 영역의 시작과 끝부분에서 멈추도록 하여, 바운스 영역을 넘어가지 않도록 합니다\n   * @type {boolean}\n   * @default true\n   */\n  public get stopAtEdge() { return this._stopAtEdge; }\n\n  public set stopAtEdge(val: FreeControlOptions[\"stopAtEdge\"]) { this._stopAtEdge = val; }\n\n  /** */\n  public constructor({\n    stopAtEdge = true\n  }: Partial<FreeControlOptions> = {}) {\n    super();\n\n    this._stopAtEdge = stopAtEdge;\n  }\n\n  /**\n   * Update position after resizing\n   * @ko resize 이후에 position을 업데이트합니다\n   * @param {number} progressInPanel Previous camera's progress in active panel before resize<ko>Resize 이전 현재 선택된 패널 내에서의 카메라 progress 값</ko>\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @chainable\n   * @return {Promise<void>}\n   */\n  public async updatePosition(progressInPanel: number): Promise<void> {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const camera = flicking.camera;\n    const activePanel = this._activePanel;\n\n    if (activePanel) {\n      const panelRange = activePanel.range;\n      const newPosition = panelRange.min + (panelRange.max - panelRange.min) * progressInPanel;\n\n      await camera.lookAt(camera.clampToReachablePosition(newPosition));\n    }\n  }\n\n  /**\n   * Move {@link Camera} to the given position\n   * @ko {@link Camera}를 주어진 좌표로 이동합니다\n   * @param {number} position The target position to move<ko>이동할 좌표</ko>\n   * @param {number} duration Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}\n   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>\n   */\n  public async moveToPosition(position: number, duration: number, axesEvent?: OnRelease) {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n\n    const camera = flicking.camera;\n    const targetPos = camera.clampToReachablePosition(position);\n\n    const anchorAtPosition = camera.findAnchorIncludePosition(targetPos);\n\n    if (!anchorAtPosition) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.POSITION_NOT_REACHABLE(position), ERROR.CODE.POSITION_NOT_REACHABLE));\n    }\n\n    const targetPanel = anchorAtPosition.panel;\n\n    // Trigger only change event\n    if (targetPanel !== this._activePanel) {\n      this._triggerIndexChangeEvent(targetPanel, position, axesEvent);\n    }\n\n    return this._animateToPosition({ position: this._stopAtEdge ? targetPos : position, duration, newActivePanel: targetPanel, axesEvent });\n  }\n}\n\nexport default FreeControl;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { OnRelease } from \"@egjs/axes\";\n\nimport Panel from \"../core/panel/Panel\";\nimport FlickingError from \"../core/FlickingError\";\nimport { clamp, getFlickingAttached, getMinusCompensatedIndex, isBetween } from \"../utils\";\nimport * as ERROR from \"../const/error\";\n\nimport Control from \"./Control\";\n/**\n * An options for the {@link StrictControl}\n * @ko {@link StrictControl} 생성시 사용되는 옵션\n * @interface\n * @property {number} count Maximum number of panels that can be moved at a time<ko>최대로 움직일 수 있는 패널의 개수</ko>\n */\nexport interface StrictControlOptions {\n  count: number;\n}\n\n/**\n * A {@link Control} that allow you to select the maximum number of panels to move at a time\n * @ko 한번에 최대로 이동할 패널의 개수를 선택 가능한 {@link Control}\n */\nclass StrictControl extends Control {\n  private _count: number;\n  private _indexRange: { min: number; max: number };\n\n  /**\n   * Maximum number of panels that can be moved at a time\n   * @ko 최대로 움직일 수 있는 패널의 개수\n   * @type {number}\n   * @default 1\n   */\n  public get count() { return this._count; }\n\n  public set count(val: StrictControlOptions[\"count\"]) { this._count = val; }\n\n  /** */\n  public constructor({\n    count = 1\n  }: Partial<StrictControlOptions> = {}) {\n    super();\n\n    this._count = count;\n    this._resetIndexRange();\n  }\n\n  /**\n   * Destroy Control and return to initial state\n   * @ko Control을 초기 상태로 되돌립니다\n   * @return {void}\n   */\n  public destroy() {\n    super.destroy();\n\n    this._resetIndexRange();\n  }\n\n  /**\n   * Update {@link Control#controller controller}'s state\n   * @ko {@link Control#controller controller}의 내부 상태를 갱신합니다\n   * @chainable\n   * @return {this}\n   */\n  public updateInput(): this {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const camera = flicking.camera;\n    const renderer = flicking.renderer;\n    const controller = this._controller;\n    const controlParams = camera.controlParams;\n    const count = this._count;\n\n    const activePanel = controller.state.animating\n      ? camera.findNearestAnchor(camera.position)?.panel\n      : this._activePanel;\n\n    if (!activePanel) {\n      controller.update(controlParams);\n      this._resetIndexRange();\n      return this;\n    }\n\n    const cameraRange = controlParams.range;\n    const currentPos = activePanel.position;\n    const currentIndex = activePanel.index;\n    const panelCount = renderer.panelCount;\n\n    let prevPanelIndex = currentIndex - count;\n    let nextPanelIndex = currentIndex + count;\n\n    if (prevPanelIndex < 0) {\n      prevPanelIndex = flicking.circularEnabled\n        ? getMinusCompensatedIndex((prevPanelIndex + 1) % panelCount - 1, panelCount)\n        : clamp(prevPanelIndex, 0, panelCount - 1);\n    }\n    if (nextPanelIndex >= panelCount) {\n      nextPanelIndex = flicking.circularEnabled\n        ? nextPanelIndex % panelCount\n        : clamp(nextPanelIndex, 0, panelCount - 1);\n    }\n\n    const prevPanel = renderer.panels[prevPanelIndex];\n    const nextPanel = renderer.panels[nextPanelIndex];\n\n    let prevPos = Math.max(prevPanel.position, cameraRange.min);\n    let nextPos = Math.min(nextPanel.position, cameraRange.max);\n\n    if (prevPos > currentPos) {\n      prevPos -= camera.rangeDiff;\n    }\n    if (nextPos < currentPos) {\n      nextPos += camera.rangeDiff;\n    }\n\n    controlParams.range = {\n      min: prevPos,\n      max: nextPos\n    };\n\n    if (controlParams.position < prevPos) {\n      controlParams.position += camera.rangeDiff;\n    }\n\n    if (controlParams.position > nextPos) {\n      controlParams.position -= camera.rangeDiff;\n    }\n\n    controlParams.circular = false;\n    controller.update(controlParams);\n\n    this._indexRange = {\n      min: prevPanel.index,\n      max: nextPanel.index\n    };\n\n    return this;\n  }\n\n  /**\n   * Move {@link Camera} to the given position\n   * @ko {@link Camera}를 주어진 좌표로 이동합니다\n   * @param {number} position The target position to move<ko>이동할 좌표</ko>\n   * @param {number} duration Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}\n   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>\n   */\n  public async moveToPosition(position: number, duration: number, axesEvent?: OnRelease) {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const camera = flicking.camera;\n    const activePanel = this._activePanel;\n    const axesRange = this._controller.range;\n    const indexRange = this._indexRange;\n    const cameraRange = camera.range;\n\n    const clampedPosition = clamp(camera.clampToReachablePosition(position), axesRange[0], axesRange[1]);\n    const anchorAtPosition = camera.findAnchorIncludePosition(clampedPosition);\n\n    if (!anchorAtPosition || !activePanel) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.POSITION_NOT_REACHABLE(position), ERROR.CODE.POSITION_NOT_REACHABLE));\n    }\n\n    const prevPos = activePanel.position;\n\n    const isOverThreshold = Math.abs(position - prevPos) >= flicking.threshold;\n    const adjacentAnchor = (position > prevPos)\n      ? camera.getNextAnchor(anchorAtPosition)\n      : camera.getPrevAnchor(anchorAtPosition);\n\n    let targetPos: number;\n    let targetPanel: Panel;\n\n    const anchors = camera.anchorPoints;\n    const firstAnchor = anchors[0];\n    const lastAnchor = anchors[anchors.length - 1];\n\n    const shouldBounceToFirst = position <= cameraRange.min && isBetween(firstAnchor.panel.index, indexRange.min, indexRange.max);\n    const shouldBounceToLast = position >= cameraRange.max && isBetween(lastAnchor.panel.index, indexRange.min, indexRange.max);\n\n    if (shouldBounceToFirst || shouldBounceToLast) {\n      // In bounce area\n      const targetAnchor = position < cameraRange.min ? firstAnchor : lastAnchor;\n\n      targetPanel = targetAnchor.panel;\n      targetPos = targetAnchor.position;\n    } else if (isOverThreshold && anchorAtPosition.position !== activePanel.position) {\n      // Move to anchor at position\n      targetPanel = anchorAtPosition.panel;\n      targetPos = anchorAtPosition.position;\n    } else if (isOverThreshold && adjacentAnchor && isBetween(adjacentAnchor.index, indexRange.min, indexRange.max)) {\n      // Move to adjacent anchor\n      targetPanel = adjacentAnchor.panel;\n      targetPos = adjacentAnchor.position;\n    } else {\n      // Restore to active panel\n      targetPos = camera.clampToReachablePosition(activePanel.position);\n      targetPanel = activePanel;\n    }\n\n    this._triggerIndexChangeEvent(targetPanel, position, axesEvent);\n\n    return this._animateToPosition({\n      position: targetPos,\n      duration,\n      newActivePanel: targetPanel,\n      axesEvent\n    });\n  }\n\n  protected _setActive = (newActivePanel: Panel, prevActivePanel: Panel | null, isTrusted: boolean) => {\n    super._setActive(newActivePanel, prevActivePanel, isTrusted);\n    this.updateInput();\n  };\n\n  private _resetIndexRange() {\n    this._indexRange = { min: 0, max: 0 };\n  }\n}\n\nexport default StrictControl;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Panel from \"./panel/Panel\";\n\n/**\n * A data component that has actual position where the camera should be stopped at\n * @ko 카메라가 정지해야하는 실제 위치를 담고 있는 데이터 컴포넌트\n */\nclass AnchorPoint {\n  private _index: number;\n  private _pos: number;\n  private _panel: Panel;\n\n  /**\n   * Index of AnchorPoint\n   * @ko AnchorPoint의 인덱스\n   * @type {number}\n   * @readonly\n   */\n  public get index() { return this._index; }\n  /**\n   * Position of AnchorPoint\n   * @ko AnchorPoint의 좌표\n   * @type {number}\n   * @readonly\n   */\n  public get position() { return this._pos; }\n  /**\n   * A {@link Panel} instance AnchorPoint is referencing to\n   * @ko AnchorPoint가 참조하고 있는 {@link Panel}\n   * @type {Panel}\n   * @readonly\n   */\n  public get panel() { return this._panel; }\n\n  /**\n   * @param {object} options An options object<ko>옵션 객체</ko>\n   * @param {number} [options.index] Index of AnchorPoint<ko>AnchorPoint의 인덱스</ko>\n   * @param {number} [options.position] Position of AnchorPoint<ko>AnchorPoint의 좌표</ko>\n   * @param {Panel} [options.panel] A {@link Panel} instance AnchorPoint is referencing to<ko>AnchorPoint가 참조하고 있는 {@link Panel}</ko>\n   */\n  public constructor({\n    index,\n    position,\n    panel\n  }: {\n    index: number;\n    position: number;\n    panel: Panel;\n  }) {\n    this._index = index;\n    this._pos = position;\n    this._panel = panel;\n  }\n}\n\nexport default AnchorPoint;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport Flicking, { FlickingOptions } from \"../Flicking\";\nimport FlickingError from \"../core/FlickingError\";\nimport Panel from \"../core/panel/Panel\";\nimport AnchorPoint from \"../core/AnchorPoint\";\nimport * as ERROR from \"../const/error\";\nimport { ALIGN, DIRECTION, EVENTS } from \"../const/external\";\nimport { checkExistence, clamp, getFlickingAttached, getProgress, includes, parseAlign } from \"../utils\";\n\nexport interface CameraOptions {\n  align: FlickingOptions[\"align\"];\n}\n\n/**\n * A component that manages actual movement inside the viewport\n * @ko 뷰포트 내에서의 실제 움직임을 담당하는 컴포넌트\n */\nabstract class Camera {\n  // Options\n  protected _align: FlickingOptions[\"align\"];\n\n  // Internal states\n  protected _flicking: Flicking | null;\n  protected _el: HTMLElement;\n  protected _transform: string;\n  protected _position: number;\n  protected _alignPos: number;\n  protected _offset: number;\n  protected _range: { min: number; max: number };\n  protected _visiblePanels: Panel[];\n  protected _anchors: AnchorPoint[];\n  protected _needPanelTriggered: { prev: boolean; next: boolean };\n\n  // Internal states getter\n  /**\n   * The camera(`.flicking-camera`) element\n   * @ko 카메라(`.flicking-camera`) 엘리먼트\n   * @type {HTMLElement}\n   * @readonly\n   */\n  public get element() { return this._el; }\n  /**\n   * Current position of the camera\n   * @ko Camera의 현재 좌표\n   * @type {number}\n   * @readonly\n   */\n  public get position() { return this._position; }\n  /**\n   * Align position inside the viewport where {@link Panel}'s {@link Panel#alignPosition alignPosition} should be located at\n   * @ko 패널의 정렬 기준 위치. 뷰포트 내에서 {@link Panel}의 {@link Panel#alignPosition alignPosition}이 위치해야 하는 곳입니다\n   * @type {number}\n   * @readonly\n   */\n  public get alignPosition() { return this._alignPos; }\n  /**\n   * Position offset, used for the {@link Flicking#renderOnlyVisible renderOnlyVisible} option\n   * @ko Camera의 좌표 오프셋. {@link Flicking#renderOnlyVisible renderOnlyVisible} 옵션을 위해 사용됩니다.\n   * @type {number}\n   * @default 0\n   * @readonly\n   */\n  public get offset() { return this._offset; }\n  /**\n   * A range that Camera's {@link Camera#position position} can reach\n   * @ko Camera의 {@link Camera#position position}이 도달 가능한 범위\n   * @type {object}\n   * @property {number} min A minimum position<ko>최소 위치</ko>\n   * @property {number} min A maximum position<ko>최대 위치</ko>\n   * @readonly\n   */\n  public get range() { return this._range; }\n  /**\n   * A difference between Camera's minimum and maximum position that can reach\n   * @ko Camera가 도달 가능한 최소/최대 좌표의 차이\n   * @type {number}\n   * @readonly\n   */\n  public get rangeDiff() { return this._range.max - this._range.min; }\n  /**\n   * An array of visible panels from the current position\n   * @ko 현재 보이는 패널들의 배열\n   * @type {Panel[]}\n   * @readonly\n   */\n  public get visiblePanels() { return this._visiblePanels; }\n  /**\n   * A range of the visible area from the current position\n   * @ko 현재 위치에서 보이는 범위\n   * @type {object}\n   * @property {number} min A minimum position<ko>최소 위치</ko>\n   * @property {number} min A maximum position<ko>최대 위치</ko>\n   * @readonly\n   */\n  public get visibleRange() { return { min: this._position - this._alignPos, max: this._position - this._alignPos + this.size }; }\n  /**\n   * An array of {@link AnchorPoint}s that Camera can be stopped at\n   * @ko 카메라가 도달 가능한 {@link AnchorPoint}의 목록\n   * @type {AnchorPoint[]}\n   * @readonly\n   */\n  public get anchorPoints() { return this._anchors; }\n  /**\n   * A current parameters of the Camera for updating {@link AxesController}\n   * @ko {@link AxesController}를 업데이트하기 위한 현재 Camera 패러미터들\n   * @type {ControlParams}\n   * @readonly\n   */\n  public get controlParams() { return { range: this._range, position: this._position, circular: false }; }\n  /**\n   * A Boolean value indicating whether Camera's over the minimum or maximum position reachable\n   * @ko 현재 카메라가 도달 가능한 범위의 최소 혹은 최대점을 넘어섰는지를 나타냅니다\n   * @type {boolean}\n   * @readonly\n   */\n  public get atEdge() { return this._position <= this._range.min || this._position >= this._range.max; }\n  /**\n   * Return the size of the viewport\n   * @ko 뷰포트 크기를 반환합니다\n   * @type {number}\n   * @readonly\n   */\n  public get size() {\n    const flicking = this._flicking;\n    return flicking\n      ? flicking.horizontal\n        ? flicking.viewport.width\n        : flicking.viewport.height\n      : 0;\n  }\n\n  /**\n   * Return the camera's position progress from the first panel to last panel\n   * Range is from 0 to last panel's index\n   * @ko 첫번째 패널로부터 마지막 패널까지의 카메라 위치의 진행도를 반환합니다\n   * 범위는 0부터 마지막 패널의 인덱스까지입니다\n   * @type {number}\n   * @readonly\n   */\n  public get progress() {\n    const flicking = this._flicking;\n    const position = this._position + this._offset;\n    const nearestAnchor = this.findNearestAnchor(this._position);\n\n    if (!flicking || !nearestAnchor) {\n      return NaN;\n    }\n\n    const nearestPanel = nearestAnchor.panel;\n    const panelPos = nearestPanel.position + nearestPanel.offset;\n    const bounceSize = flicking.control.controller.bounce!;\n\n    const { min: prevRange, max: nextRange } = this.range;\n    const rangeDiff = this.rangeDiff;\n\n    if (position === panelPos) {\n      return nearestPanel.index;\n    }\n\n    if (position < panelPos) {\n      const prevPanel = nearestPanel.prev();\n      let prevPosition = prevPanel\n        ? prevPanel.position + prevPanel.offset\n        : prevRange - bounceSize[0];\n\n      // Looped\n      if (prevPosition > panelPos) {\n        prevPosition -= rangeDiff;\n      }\n\n      return nearestPanel.index - 1 + getProgress(position, prevPosition, panelPos);\n    } else {\n      const nextPanel = nearestPanel.next();\n      let nextPosition = nextPanel\n        ? nextPanel.position + nextPanel.offset\n        : nextRange + bounceSize[1];\n\n      // Looped\n      if (nextPosition < panelPos) {\n        nextPosition += rangeDiff;\n      }\n\n      return nearestPanel.index + getProgress(position, panelPos, nextPosition);\n    }\n  }\n\n  // Options Getter\n  /**\n   * A value indicating where the {@link Camera#alignPosition alignPosition} should be located at inside the viewport element\n   * @ko {@link Camera#alignPosition alignPosition}이 뷰포트 엘리먼트 내의 어디에 위치해야 하는지를 나타내는 값\n   * @type {ALIGN | string | number}\n   */\n  public get align() { return this._align; }\n\n  // Options Setter\n  public set align(val: FlickingOptions[\"align\"]) {\n    this._align = val;\n  }\n\n  /** */\n  public constructor({\n    align = ALIGN.CENTER\n  }: Partial<CameraOptions> = {}) {\n    this._flicking = null;\n    this._resetInternalValues();\n\n    // Options\n    this._align = align;\n  }\n\n  /**\n   * Update {@link Camera#range range} of Camera\n   * @ko Camera의 {@link Camera#range range}를 업데이트합니다\n   * @method\n   * @abstract\n   * @memberof Camera\n   * @instance\n   * @name updateRange\n   * @chainable\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @return {this}\n   */\n  public abstract updateRange(): this;\n\n  /**\n   * Initialize Camera\n   * @ko Camera를 초기화합니다\n   * @param {Flicking} flicking An instance of {@link Flicking}<ko>Flicking의 인스턴스</ko>\n   * @chainable\n   * @throws {FlickingError}\n   * {@link ERROR_CODE VAL_MUST_NOT_NULL} If the camera element(`.flicking-camera`) does not exist inside viewport element\n   * <ko>{@link ERROR_CODE VAL_MUST_NOT_NULL} 뷰포트 엘리먼트 내부에 카메라 엘리먼트(`.flicking-camera`)가 존재하지 않을 경우</ko>\n   * @return {this}\n   */\n  public init(flicking: Flicking): this {\n    this._flicking = flicking;\n\n    const viewportEl = flicking.viewport.element;\n\n    checkExistence(viewportEl.firstElementChild, \"First element child of the viewport element\");\n    this._el = viewportEl.firstElementChild as HTMLElement;\n    this._checkTranslateSupport();\n\n    return this;\n  }\n\n  /**\n   * Destroy Camera and return to initial state\n   * @ko Camera를 초기 상태로 되돌립니다\n   * @return {void}\n   */\n  public destroy(): this {\n    this._flicking = null;\n    this._resetInternalValues();\n    return this;\n  }\n\n  /**\n   * Move to the given position and apply CSS transform\n   * @ko 해당 좌표로 이동하고, CSS transform을 적용합니다\n   * @param {number} pos A new position<ko>움직일 위치</ko>\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @return {this}\n   */\n  public async lookAt(pos: number): Promise<void> {\n    const prevPos = this._position;\n\n    this._position = pos;\n    await this._refreshVisiblePanels();\n    this._checkNeedPanel();\n    this._checkReachEnd(prevPos, pos);\n    this._applyTransform();\n  }\n\n  /**\n   * Return a previous {@link AnchorPoint} of given {@link AnchorPoint}\n   * If it does not exist, return `null` instead\n   * @ko 주어진 {@link AnchorPoint}의 이전 {@link AnchorPoint}를 반환합니다\n   * 존재하지 않을 경우 `null`을 반환합니다\n   * @param {AnchorPoint} anchor A reference {@link AnchorPoint}<ko>기준 {@link AnchorPoint}</ko>\n   * @return {AnchorPoint | null} The previous {@link AnchorPoint}<ko>이전 {@link AnchorPoint}</ko>\n   */\n  public getPrevAnchor(anchor: AnchorPoint): AnchorPoint | null {\n    return this._anchors[anchor.index - 1] || null;\n  }\n\n  /**\n   * Return a next {@link AnchorPoint} of given {@link AnchorPoint}\n   * If it does not exist, return `null` instead\n   * @ko 주어진 {@link AnchorPoint}의 다음 {@link AnchorPoint}를 반환합니다\n   * 존재하지 않을 경우 `null`을 반환합니다\n   * @param {AnchorPoint} anchor A reference {@link AnchorPoint}<ko>기준 {@link AnchorPoint}</ko>\n   * @return {AnchorPoint | null} The next {@link AnchorPoint}<ko>다음 {@link AnchorPoint}</ko>\n   */\n  public getNextAnchor(anchor: AnchorPoint): AnchorPoint | null {\n    return this._anchors[anchor.index + 1] || null;\n  }\n\n  /**\n   * Return the camera's position progress in the panel below\n   * Value is from 0 to 1 when the camera's inside panel\n   * Value can be lower than 0 or bigger than 1 when it's in the margin area\n   * @ko 현재 카메라 아래 패널에서의 위치 진행도를 반환합니다\n   * 반환값은 카메라가 패널 내부에 있을 경우 0부터 1까지의 값을 갖습니다\n   * 패널의 margin 영역에 있을 경우 0보다 작거나 1보다 큰 값을 반환할 수 있습니다\n   */\n  public getProgressInPanel(panel: Panel) {\n    const panelRange = panel.range;\n\n    return (this._position - panelRange.min) / (panelRange.max - panelRange.min);\n  }\n\n  /**\n   * Return {@link AnchorPoint} that includes given position\n   * If there's no {@link AnchorPoint} that includes the given position, return `null` instead\n   * @ko 주어진 좌표를 포함하는 {@link AnchorPoint}를 반환합니다\n   * 주어진 좌표를 포함하는 {@link AnchorPoint}가 없을 경우 `null`을 반환합니다\n   * @param {number} position A position to check<ko>확인할 좌표</ko>\n   * @return {AnchorPoint | null} The {@link AnchorPoint} that includes the given position<ko>해당 좌표를 포함하는 {@link AnchorPoint}</ko>\n   */\n  public findAnchorIncludePosition(position: number): AnchorPoint | null {\n    const anchors = this._anchors;\n    const anchorsIncludingPosition = anchors.filter(anchor => anchor.panel.includePosition(position, true));\n\n    return anchorsIncludingPosition.reduce((nearest: AnchorPoint | null, anchor) => {\n      if (!nearest) return anchor;\n\n      return Math.abs(nearest.position - position) < Math.abs(anchor.position - position)\n        ? nearest\n        : anchor;\n    }, null);\n  }\n\n  /**\n   * Return {@link AnchorPoint} nearest to given position\n   * If there're no {@link AnchorPoint}s, return `null` instead\n   * @ko 해당 좌표에서 가장 가까운 {@link AnchorPoint}를 반환합니다\n   * {@link AnchorPoint}가 하나도 없을 경우 `null`을 반환합니다\n   * @param {number} position A position to check<ko>확인할 좌표</ko>\n   * @return {AnchorPoint | null} The {@link AnchorPoint} nearest to the given position<ko>해당 좌표에 가장 인접한 {@link AnchorPoint}</ko>\n   */\n  public findNearestAnchor(position: number): AnchorPoint | null {\n    const anchors = this._anchors;\n\n    if (anchors.length <= 0) return null;\n\n    let prevDist = Infinity;\n    for (let anchorIdx = 0; anchorIdx < anchors.length; anchorIdx++) {\n      const anchor = anchors[anchorIdx];\n      const dist = Math.abs(anchor.position - position);\n\n      if (dist > prevDist) {\n        // Return previous anchor\n        return anchors[anchorIdx - 1];\n      }\n\n      prevDist = dist;\n    }\n\n    // Return last anchor\n    return anchors[anchors.length - 1];\n  }\n\n  /**\n   * Clamp the given position between camera's range\n   * @ko 주어진 좌표를 Camera가 도달 가능한 범위 사이의 값으로 만듭니다\n   * @param {number} position A position to clamp<ko>범위를 제한할 좌표</ko>\n   * @return {number} A clamped position<ko>범위 제한된 좌표</ko>\n   */\n  public clampToReachablePosition(position: number): number {\n    const range = this._range;\n    return clamp(position, range.min, range.max);\n  }\n\n  /**\n   * Check whether the given panel is inside of the Camera's range\n   * @ko 해당 {@link Panel}이 Camera가 도달 가능한 범위 내에 있는지를 반환합니다\n   * @param panel An instance of {@link Panel} to check<ko>확인할 {@link Panel}의 인스턴스</ko>\n   * @return {boolean} Whether the panel's inside Camera's range<ko>도달 가능한 범위 내에 해당 패널이 존재하는지 여부</ko>\n   */\n  public canReach(panel: Panel): boolean {\n    const range = this._range;\n\n    if (panel.removed) return false;\n\n    const panelPos = panel.position;\n\n    return panelPos >= range.min && panelPos <= range.max;\n  }\n\n  /**\n   * Check whether the given panel element is visible at the current position\n   * @ko 현재 좌표에서 해당 패널 엘리먼트를 볼 수 있는지 여부를 반환합니다\n   * @param panel An instance of {@link Panel} to check<ko>확인할 {@link Panel}의 인스턴스</ko>\n   * @return Whether the panel element is visible at the current position<ko>현재 위치에서 해당 패널 엘리먼트가 보이는지 여부</ko>\n   */\n  public canSee(panel: Panel): boolean {\n    const visibleRange = this.visibleRange;\n    // Should not include margin, as we don't declare what the margin is visible as what the panel is visible.\n    return panel.includeRange(visibleRange.min, visibleRange.max, false);\n  }\n\n  /**\n   * Update Camera's {@link Camera#alignPosition alignPosition}\n   * @ko Camera의 {@link Camera#alignPosition alignPosition}을 업데이트합니다\n   * @chainable\n   * @return {this}\n   */\n  public updateAlignPos(): this {\n    const align = this._align;\n\n    const alignVal = typeof align === \"object\"\n      ? (align as { camera: string | number }).camera\n      : align;\n\n    this._alignPos = parseAlign(alignVal, this.size);\n\n    return this;\n  }\n\n  /**\n   * Update Camera's {@link Camera#anchorPoints anchorPoints}\n   * @ko Camera의 {@link Camera#anchorPoints anchorPoints}를 업데이트합니다\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @chainable\n   * @return {this}\n   */\n  public updateAnchors(): this {\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const panels = flicking.renderer.panels;\n\n    this._anchors = panels.map((panel, index) => new AnchorPoint({\n      index,\n      position: panel.position,\n      panel\n    }));\n\n    return this;\n  }\n\n  /**\n   * Update Viewport's height to active panel's height\n   * @ko 현재 선택된 패널의 높이와 동일하도록 뷰포트의 높이를 업데이트합니다\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @chainable\n   * @return {this}\n   */\n  public updateAdaptiveHeight() {\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const activePanel = flicking.control.activePanel;\n\n    if (!flicking.horizontal || !flicking.adaptive || !activePanel) return;\n\n    flicking.viewport.setSize({\n      height: activePanel.height\n    });\n  }\n\n  public updateOffset() {\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const unRenderedPanels = flicking.panels.filter(panel => !panel.rendered);\n    const position = this._position;\n\n    this._offset = unRenderedPanels\n      .filter(panel => panel.position + panel.offset < position)\n      .reduce((offset, panel) => offset + panel.sizeIncludingMargin, 0);\n\n    this._applyTransform();\n  }\n\n  /**\n   * Reset the history of {@link Flicking#event:needPanel needPanel} events so it can be triggered again\n   * @ko 발생한 {@link Flicking#event:needPanel needPanel} 이벤트들을 초기화하여 다시 발생할 수 있도록 합니다\n   * @chainable\n   * @return {this}\n   */\n  public resetNeedPanelHistory(): this {\n    this._needPanelTriggered = { prev: false, next: false };\n    return this;\n  }\n\n  protected _resetInternalValues() {\n    this._position = 0;\n    this._alignPos = 0;\n    this._offset = 0;\n    this._range = { min: 0, max: 0 };\n    this._visiblePanels = [];\n    this._anchors = [];\n    this._needPanelTriggered = { prev: false, next: false };\n  }\n\n  protected async _refreshVisiblePanels() {\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const panels = flicking.renderer.panels;\n\n    const newVisiblePanels = panels.filter(panel => this.canSee(panel));\n    const prevVisiblePanels = this._visiblePanels;\n    this._visiblePanels = newVisiblePanels;\n\n    const added: Panel[] = newVisiblePanels.filter(panel => !includes(prevVisiblePanels, panel));\n    const removed: Panel[] = prevVisiblePanels.filter(panel => !includes(newVisiblePanels, panel));\n\n    if (added.length > 0 || removed.length > 0) {\n      await flicking.renderer.render();\n\n      flicking.trigger(new ComponentEvent(EVENTS.VISIBLE_CHANGE, {\n        added,\n        removed,\n        visiblePanels: newVisiblePanels\n      }));\n    }\n  }\n\n  protected _checkNeedPanel(): void {\n    const needPanelTriggered = this._needPanelTriggered;\n\n    if (needPanelTriggered.prev && needPanelTriggered.next) return;\n\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const panels = flicking.renderer.panels;\n\n    if (panels.length <= 0) {\n      if (!needPanelTriggered.prev) {\n        flicking.trigger(new ComponentEvent(EVENTS.NEED_PANEL, { direction: DIRECTION.PREV }));\n        needPanelTriggered.prev = true;\n      }\n      if (!needPanelTriggered.next) {\n        flicking.trigger(new ComponentEvent(EVENTS.NEED_PANEL, { direction: DIRECTION.NEXT }));\n        needPanelTriggered.next = true;\n      }\n\n      return;\n    }\n\n    const cameraPosition = this._position;\n    const cameraSize = this.size;\n    const cameraRange = this._range;\n    const needPanelThreshold = flicking.needPanelThreshold;\n\n    const cameraPrev = cameraPosition - this._alignPos;\n    const cameraNext = cameraPrev + cameraSize;\n\n    const firstPanel = panels[0];\n    const lastPanel = panels[panels.length - 1];\n\n    if (!needPanelTriggered.prev) {\n      const firstPanelPrev = firstPanel.range.min;\n\n      if (cameraPrev <= (firstPanelPrev + needPanelThreshold) || cameraPosition <= (cameraRange.min + needPanelThreshold)) {\n        flicking.trigger(new ComponentEvent(EVENTS.NEED_PANEL, { direction: DIRECTION.PREV }));\n        needPanelTriggered.prev = true;\n      }\n    }\n\n    if (!needPanelTriggered.next) {\n      const lastPanelNext = lastPanel.range.max;\n\n      if (cameraNext >= (lastPanelNext - needPanelThreshold) || cameraPosition >= (cameraRange.max - needPanelThreshold)) {\n        flicking.trigger(new ComponentEvent(EVENTS.NEED_PANEL, { direction: DIRECTION.NEXT }));\n        needPanelTriggered.next = true;\n      }\n    }\n  }\n\n  protected _checkReachEnd(prevPos: number, newPos: number): void {\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const range = this._range;\n\n    const wasBetweenRange = prevPos > range.min && prevPos < range.max;\n    const isBetweenRange = newPos > range.min && newPos < range.max;\n\n    if (!wasBetweenRange || isBetweenRange) return;\n\n    const direction = newPos <= range.min ? DIRECTION.PREV : DIRECTION.NEXT;\n\n    flicking.trigger(new ComponentEvent(EVENTS.REACH_EDGE, {\n      direction\n    }));\n  }\n\n  protected _applyTransform(): void {\n    const el = this._el;\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n\n    const actualPosition = this._position - this._alignPos - this._offset;\n\n    el.style[this._transform] = flicking.horizontal\n      ? `translate(${-actualPosition}px)`\n      : `translate(0, ${-actualPosition}px)`;\n  }\n\n  protected _checkTranslateSupport = () => {\n    const transforms = [\"webkitTransform\", \"msTransform\", \"MozTransform\", \"OTransform\", \"transform\"];\n\n    const supportedStyle = document.documentElement.style;\n    let transformName = \"\";\n    for (const prefixedTransform of transforms) {\n      if (prefixedTransform in supportedStyle) {\n        transformName = prefixedTransform;\n      }\n    }\n\n    if (!transformName) {\n      throw new FlickingError(ERROR.MESSAGE.TRANSFORM_NOT_SUPPORTED, ERROR.CODE.TRANSFORM_NOT_SUPPORTED);\n    }\n\n    this._transform = transformName;\n  };\n}\n\nexport default Camera;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { getFlickingAttached } from \"../utils\";\n\nimport Camera from \"./Camera\";\n\n/**\n * A {@link Camera} that can move from the position of the first panel to the position of the last panel\n * @ko 첫번째 패널의 좌표로부터 마지막 패널의 좌표로까지 이동할 수 있는 종류의 {@link Camera}\n */\nclass LinearCamera extends Camera {\n  /**\n   * Update {@link Camera#range range} of Camera\n   * @ko Camera의 {@link Camera#range range}를 업데이트합니다\n   * @chainable\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @return {this}\n   */\n  public updateRange() {\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const renderer = flicking.renderer;\n\n    const firstPanel = renderer.getPanel(0);\n    const lastPanel = renderer.getPanel(renderer.panelCount - 1);\n\n    this._range = { min: firstPanel?.position ?? 0, max: lastPanel?.position ?? 0 };\n    return this;\n  }\n}\n\nexport default LinearCamera;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Panel from \"../core/panel/Panel\";\nimport AnchorPoint from \"../core/AnchorPoint\";\nimport { DIRECTION } from \"../const/external\";\nimport { circulatePosition, getFlickingAttached } from \"../utils\";\nimport { ValueOf } from \"../type/internal\";\n\nimport Camera from \"./Camera\";\n\n/**\n * A data of the position that changes order of the panel elements\n * @ko 패널 엘리먼트 순서가 변경되는 좌표의 데이터\n * @interface\n * @property {Panel} panel Toggling panel<ko>순서를 변경할 패널</ko>\n * @property {DIRECTION} direction Toggling position<ko>순서를 변경할 방향</ko>\n * @property {boolean} toggled Whether the panel has toggled its position to `direction`<ko>`direction` 방향으로 패널 위치를 변경했는지 여부를 나타내는 값</ko>\n */\nexport interface TogglePoint {\n  panel: Panel;\n  direction: ValueOf<typeof DIRECTION>;\n  toggled: boolean;\n}\n\n/**\n * A {@link Camera} that connects the last panel and the first panel, enabling continuous loop\n * @ko 첫번째 패널과 마지막 패널이 이어진 상태로, 무한히 회전할 수 있는 종류의 {@link Camera}\n */\nclass CircularCamera extends Camera {\n  private _circularOffset: number = 0;\n  private _circularEnabled: boolean = false;\n\n  public get offset() { return this._offset - this._circularOffset; }\n  public get controlParams() { return { range: this._range, position: this._position, circular: this._circularEnabled }; }\n\n  public getPrevAnchor(anchor: AnchorPoint): AnchorPoint | null {\n    if (!this._circularEnabled || anchor.index !== 0) return super.getPrevAnchor(anchor);\n\n    const anchors = this._anchors;\n    const rangeDiff = this.rangeDiff;\n    const lastAnchor = anchors[anchors.length - 1];\n\n    return new AnchorPoint({\n      index: lastAnchor.index,\n      position: lastAnchor.position - rangeDiff,\n      panel: lastAnchor.panel\n    });\n  }\n\n  public getNextAnchor(anchor: AnchorPoint): AnchorPoint | null {\n    const anchors = this._anchors;\n\n    if (!this._circularEnabled || anchor.index !== anchors.length - 1) return super.getNextAnchor(anchor);\n\n    const rangeDiff = this.rangeDiff;\n    const firstAnchor = anchors[0];\n\n    return new AnchorPoint({\n      index: firstAnchor.index,\n      position: firstAnchor.position + rangeDiff,\n      panel: firstAnchor.panel\n    });\n  }\n\n  public findAnchorIncludePosition(position: number): AnchorPoint | null {\n    if (!this._circularEnabled) return super.findAnchorIncludePosition(position);\n\n    const range = this._range;\n    const positionInRange = circulatePosition(position, range.min, range.max);\n    const anchorInRange = super.findAnchorIncludePosition(positionInRange);\n\n    if (!anchorInRange) return null;\n\n    const rangeDiff = this.rangeDiff;\n\n    if (position < range.min) {\n      const loopCount = -Math.floor((range.min - position) / rangeDiff) - 1;\n\n      return new AnchorPoint({\n        index: anchorInRange.index,\n        position: anchorInRange.position + rangeDiff * loopCount,\n        panel: anchorInRange.panel\n      });\n    } else if (position > range.max) {\n      const loopCount = Math.floor((position - range.max) / rangeDiff) + 1;\n\n      return new AnchorPoint({\n        index: anchorInRange.index,\n        position: anchorInRange.position + rangeDiff * loopCount,\n        panel: anchorInRange.panel\n      });\n    }\n\n    return anchorInRange;\n  }\n\n  public clampToReachablePosition(position: number): number {\n    // Basically all position is reachable for circular camera\n    return this._circularEnabled\n      ? position\n      : super.clampToReachablePosition(position);\n  }\n\n  public canReach(panel: Panel): boolean {\n    if (panel.removed) return false;\n\n    return this._circularEnabled\n      // Always reachable on circular mode\n      ? true\n      : super.canReach(panel);\n  }\n\n  public canSee(panel: Panel): boolean {\n    const range = this._range;\n    const rangeDiff = this.rangeDiff;\n    const visibleRange = this.visibleRange;\n    const visibleInCurrentRange = super.canSee(panel);\n\n    if (!this._circularEnabled) {\n      return visibleInCurrentRange;\n    }\n\n    // Check looped visible area for circular case\n    if (visibleRange.min < range.min) {\n      return visibleInCurrentRange || panel.includeRange(visibleRange.min + rangeDiff, visibleRange.max + rangeDiff, false);\n    } else if (visibleRange.max > range.max) {\n      return visibleInCurrentRange || panel.includeRange(visibleRange.min - rangeDiff, visibleRange.max - rangeDiff, false);\n    }\n\n    return visibleInCurrentRange;\n  }\n\n  /**\n   * Update {@link Camera#range range} of Camera\n   * @ko Camera의 {@link Camera#range range}를 업데이트합니다\n   * @chainable\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @return {this}\n   */\n  public updateRange() {\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const renderer = flicking.renderer;\n\n    const panels = renderer.panels;\n    if (panels.length <= 0) {\n      this._resetInternalValues();\n      return this;\n    }\n\n    const firstPanel = panels[0]!;\n    const lastPanel = panels[panels.length - 1]!;\n    const firstPanelPrev = firstPanel.range.min - firstPanel.margin.prev;\n    const lastPanelNext = lastPanel.range.max + lastPanel.margin.next;\n\n    const visibleSize = this.size;\n    const panelSizeSum = lastPanelNext - firstPanelPrev;\n\n    const canSetCircularMode = panels\n      .every(panel => panelSizeSum - panel.size >= visibleSize);\n    this._circularEnabled = canSetCircularMode;\n\n    if (canSetCircularMode) {\n      this._range = { min: firstPanelPrev, max: lastPanelNext };\n\n      panels.forEach(panel => panel.updateCircularToggleDirection());\n    } else {\n      this._range = { min: firstPanel.position, max: lastPanel.position };\n    }\n\n    this._updateCircularOffset();\n\n    return this;\n  }\n\n  public async lookAt(pos: number) {\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const prevPos = this._position;\n\n    if (pos === prevPos) return await super.lookAt(pos);\n\n    const panels = flicking.renderer.panels;\n    const toggled = panels.map(panel => panel.toggle(prevPos, pos));\n\n    this._position = pos;\n\n    if (toggled.some(isToggled => isToggled)) {\n      this._updateCircularOffset();\n      await flicking.renderer.render();\n    }\n\n    return await super.lookAt(pos);\n  }\n\n  protected _applyTransform(): void {\n    const el = this._el;\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n\n    const actualPosition = this._position - this._alignPos - this._offset + this._circularOffset;\n\n    el.style[this._transform] = flicking.horizontal\n      ? `translate(${-actualPosition}px)`\n      : `translate(0, ${-actualPosition}px)`;\n  }\n\n  protected _resetInternalValues() {\n    super._resetInternalValues();\n    this._circularOffset = 0;\n    this._circularEnabled = false;\n  }\n\n  private _calcPanelAreaSum(panels: Panel[]) {\n    return panels.reduce((sum: number, panel: Panel) => sum + panel.sizeIncludingMargin, 0);\n  }\n\n  private _updateCircularOffset() {\n    if (!this._circularEnabled) {\n      this._circularOffset = 0;\n      return;\n    }\n\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const toggledPrev: Panel[] = [];\n    const toggledNext: Panel[] = [];\n\n    flicking.panels\n      .filter(panel => panel.toggled)\n      .forEach(panel => {\n        if (panel.toggleDirection === DIRECTION.PREV) {\n          toggledPrev.push(panel);\n        } else {\n          toggledNext.push(panel);\n        }\n      });\n\n    this._circularOffset = this._calcPanelAreaSum(toggledPrev) - this._calcPanelAreaSum(toggledNext);\n  }\n}\n\nexport default CircularCamera;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Panel from \"../core/panel/Panel\";\nimport AnchorPoint from \"../core/AnchorPoint\";\nimport { getFlickingAttached } from \"../utils\";\n\nimport Camera from \"./Camera\";\n\n/**\n * A {@link Camera} that set range not to go out of the first/last panel, so it won't show empty spaces before/after the first/last panel\n * @ko 첫번째와 마지막 패널 밖으로 넘어가지 못하도록 범위를 설정하여, 첫번째/마지막 패널 전/후의 빈 공간을 보이지 않도록 하는 종류의 {@link Camera}\n */\nclass BoundCamera extends Camera {\n  /**\n   * Update {@link Camera#range range} of Camera\n   * @ko Camera의 {@link Camera#range range}를 업데이트합니다\n   * @chainable\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @return {this}\n   */\n  public updateRange() {\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const renderer = flicking.renderer;\n    const alignPos = this._alignPos;\n\n    const firstPanel = renderer.getPanel(0);\n    const lastPanel = renderer.getPanel(renderer.panelCount - 1);\n\n    if (!firstPanel || !lastPanel) {\n      this._range = { min: 0, max: 0 };\n      return this;\n    }\n\n    const viewportSize = this.size;\n    const firstPanelPrev = firstPanel.range.min;\n    const lastPanelNext = lastPanel.range.max;\n    const panelAreaSize = lastPanelNext - firstPanelPrev;\n    const canSetBoundMode = viewportSize < panelAreaSize;\n\n    if (canSetBoundMode) {\n      this._range = { min: firstPanelPrev + alignPos, max: lastPanelNext - viewportSize + alignPos };\n    } else {\n      this._range = { min: firstPanel.position, max: lastPanel.position };\n    }\n\n    return this;\n  }\n\n  public updateAnchors(): this {\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const panels = flicking.renderer.panels;\n\n    if (panels.length <= 0) {\n      this._anchors = [];\n      return this;\n    }\n\n    const range = this._range;\n    const reachablePanels = panels.filter(panel => this.canReach(panel));\n\n    if (reachablePanels.length > 0) {\n      const shouldPrependBoundAnchor = reachablePanels[0].position !== range.min;\n      const shouldAppendBoundAnchor = reachablePanels[reachablePanels.length - 1].position !== range.max;\n      const indexOffset = shouldPrependBoundAnchor ? 1 : 0;\n\n      const newAnchors = reachablePanels.map((panel, idx) => new AnchorPoint({\n        index: idx + indexOffset,\n        position: panel.position,\n        panel\n      }));\n\n      if (shouldPrependBoundAnchor) {\n        newAnchors.splice(0, 0, new AnchorPoint({\n          index: 0,\n          position: range.min,\n          panel: panels[reachablePanels[0].index - 1]\n        }));\n      }\n\n      if (shouldAppendBoundAnchor) {\n        newAnchors.push(new AnchorPoint({\n          index: newAnchors.length,\n          position: range.max,\n          panel: panels[reachablePanels[reachablePanels.length - 1].index + 1]\n        }));\n      }\n\n      this._anchors = newAnchors;\n    } else if (range.min !== range.max) {\n      // There're more than 2 panels\n      const nearestPanelAtMin = this._findNearestPanel(range.min, panels);\n      const panelAtMin = nearestPanelAtMin.index === panels.length - 1\n        ? nearestPanelAtMin.prev()!\n        : nearestPanelAtMin;\n      const panelAtMax = panelAtMin.next()!;\n\n      this._anchors = [\n        new AnchorPoint({\n          index: 0,\n          position: range.min,\n          panel: panelAtMin\n        }),\n        new AnchorPoint({\n          index: 1,\n          position: range.max,\n          panel: panelAtMax\n        })\n      ];\n    } else {\n      this._anchors = [new AnchorPoint({\n        index: 0,\n        position: range.min,\n        panel: this._findNearestPanel(range.min, panels)\n      })];\n    }\n\n    return this;\n  }\n\n  private _findNearestPanel(pos: number, panels: Panel[]): Panel {\n    let prevDist = Infinity;\n    for (let panelIdx = 0; panelIdx < panels.length; panelIdx++) {\n      const panel = panels[panelIdx];\n      const dist = Math.abs(panel.position - pos);\n\n      if (dist > prevDist) {\n        // Return previous anchor\n        return panels[panelIdx - 1];\n      }\n\n      prevDist = dist;\n    }\n\n    // Return last anchor\n    return panels[panels.length - 1];\n  }\n}\n\nexport default BoundCamera;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking from \"../../Flicking\";\n\nimport RenderingStrategy from \"./RenderingStrategy\";\n\nclass RawRenderingStrategy implements RenderingStrategy {\n  public updateRenderingPanels(flicking: Flicking) {\n    // RawRenderingStrategy always renders all panel elements\n    flicking.panels.forEach(panel => panel.markForShow());\n  }\n}\n\nexport default RawRenderingStrategy;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport Flicking, { FlickingOptions } from \"../Flicking\";\nimport Panel, { PanelOptions } from \"../core/panel/Panel\";\nimport { ALIGN, EVENTS } from \"../const/external\";\nimport { getFlickingAttached, getMinusCompensatedIndex, includes } from \"../utils\";\n\nimport RenderingStrategy from \"./RenderingStrategy/RenderingStrategy\";\nimport RawRenderingStrategy from \"./RenderingStrategy/RawRenderingStrategy\";\n\nexport interface RendererOptions {\n  align: FlickingOptions[\"align\"];\n  strategy: RenderingStrategy;\n}\n\n/**\n * A component that manages {@link Panel} and its elements\n * @ko {@link Panel}과 그 엘리먼트들을 관리하는 컴포넌트\n */\nabstract class Renderer {\n  // Internal States\n  protected _flicking: Flicking | null;\n  protected _panels: Panel[];\n  protected _renderingStrategy: RenderingStrategy;\n\n  // Options\n  protected _align: RendererOptions[\"align\"];\n\n  // Internal states Getter\n  /**\n   * Array of panels\n   * @ko 전체 패널들의 배열\n   * @type {Panel[]}\n   * @readonly\n   * @see Panel\n   */\n  public get panels() { return this._panels; }\n  /**\n   * Count of panels\n   * @ko 전체 패널의 개수\n   * @type {number}\n   * @readonly\n   */\n  public get panelCount() { return this._panels.length; }\n\n  // Options Getter\n  /**\n   * A {@link Panel}'s {@link Panel#align align} value that applied to all panels\n   * @ko {@link Panel}에 공통적으로 적용할 {@link Panel#align align} 값\n   * @type {Constants.ALIGN | string | number}\n   */\n  public get align() { return this._align; }\n\n  // Options Setter\n  public set align(val: RendererOptions[\"align\"]) {\n    this._align = val;\n\n    const panelAlign = this._getPanelAlign();\n    this._panels.forEach(panel => { panel.align = panelAlign; });\n  }\n\n  /**\n   * @param {object} options An options object<ko>옵션 오브젝트</ko>\n   * @param {Constants.ALIGN | string | number} [options.align] An {@link Flicking#align align} value that will be applied to all panels<ko>전체 패널에 적용될 {@link Flicking#align align} 값</ko>\n   */\n  public constructor({\n    align = ALIGN.CENTER,\n    strategy = new RawRenderingStrategy()\n  }: Partial<RendererOptions> = {}) {\n    this._align = align;\n    this._flicking = null;\n    this._renderingStrategy = strategy;\n    this._panels = [];\n  }\n\n  /**\n   * Render panel elements inside the camera element\n   * @ko 패널 엘리먼트들을 카메라 엘리먼트 내부에 렌더링합니다\n   * @method\n   * @abstract\n   * @memberof Renderer\n   * @instance\n   * @name render\n   * @chainable\n   * @return {this}\n   */\n  public abstract render(): Promise<void>;\n  public abstract forceRenderAllPanels(): Promise<void>;\n\n  protected abstract _collectPanels(): void;\n  protected abstract _createPanel(el: any, options: PanelOptions): Panel;\n  protected abstract _insertPanelElements(panels: Panel[], nextSibling: Panel | null): void;\n  protected abstract _removePanelElements(panels: Panel[]): void;\n\n  /**\n   * Initialize Renderer\n   * @ko Renderer를 초기화합니다\n   * @param {Flicking} flicking An instance of {@link Flicking}<ko>Flicking의 인스턴스</ko>\n   * @chainable\n   * @return {this}\n   */\n  public init(flicking: Flicking): this {\n    this._flicking = flicking;\n    this._collectPanels();\n\n    return this;\n  }\n\n  /**\n   * Destroy Renderer and return to initial state\n   * @ko Renderer를 초기 상태로 되돌립니다\n   * @return {void}\n   */\n  public destroy(): void {\n    this._flicking = null;\n    this._panels = [];\n  }\n\n  /**\n   * Return the {@link Panel} at the given index. `null` if it doesn't exists.\n   * @ko 주어진 인덱스에 해당하는 {@link Panel}을 반환합니다. 주어진 인덱스에 해당하는 패널이 존재하지 않을 경우 `null`을 반환합니다.\n   * @return {Panel | null} Panel at the given index<ko>주어진 인덱스에 해당하는 패널</ko>\n   * @see Panel\n   */\n  public getPanel(index: number): Panel | null {\n    return this._panels[index] || null;\n  }\n\n  /**\n   * Update all panel sizes\n   * @ko 모든 패널의 크기를 업데이트합니다\n   * @chainable\n   * @return {this}\n   */\n  public updatePanelSize(): this {\n    this._panels.forEach(panel => panel.resize());\n    return this;\n  }\n\n  /**\n   * Insert new panels at given index\n   * This will increase index of panels after by the number of panels added\n   * @ko 주어진 인덱스에 새로운 패널들을 추가합니다\n   * 해당 인덱스보다 같거나 큰 인덱스를 가진 기존 패널들은 추가한 패널의 개수만큼 인덱스가 증가합니다.\n   * @param {number} index Index to insert new panels at<ko>새로 패널들을 추가할 인덱스</ko>\n   * @param {any[]} elements An array of element or framework component with element in it<ko>엘리먼트의 배열 혹은 프레임워크에서 엘리먼트를 포함한 컴포넌트들의 배열</ko>\n   * @return {Panel[]} An array of prepended panels<ko>추가된 패널들의 배열</ko>\n   */\n  public batchInsert(...items: Array<{\n    index: number;\n    elements: any[];\n  }>): Panel[] {\n    const panels = this._panels;\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n\n    const { control } = flicking;\n    const align = this._getPanelAlign();\n\n    const allPanelsInserted = items.reduce((addedPanels, item) => {\n      const insertingIdx = getMinusCompensatedIndex(item.index, panels.length);\n      const panelsPushed = panels.slice(insertingIdx);\n      const panelsInserted = item.elements.map(el => this._createPanel(el, { index: insertingIdx, align, flicking }));\n\n      panels.splice(insertingIdx, 0, ...panelsInserted);\n\n      // Resize the newly added panels\n      panelsInserted.forEach(panel => panel.resize());\n\n      const insertedSize = this._getPanelSizeSum(panelsInserted);\n\n      // Update panel indexes & positions\n      panelsPushed.forEach(panel => {\n        panel.increaseIndex(panelsInserted.length);\n        panel.increasePosition(insertedSize);\n      });\n\n      // Insert the actual elements as camera element's children\n      this._insertPanelElements(panelsInserted, panelsPushed[0] ?? null);\n\n      return [...addedPanels, ...panelsInserted];\n    }, []);\n\n    if (allPanelsInserted.length <= 0) return [];\n\n    // Update camera & control\n    this._updateCameraAndControl();\n\n    void this.render();\n\n    // Move to the first panel added if no panels existed\n    // FIXME: fix for animating case\n    if (allPanelsInserted.length > 0 && !control.animating) {\n      void control.moveToPanel(control.activePanel || allPanelsInserted[0], {\n        duration: 0\n      }).catch(() => void 0);\n    }\n\n    flicking.camera.updateOffset();\n\n    flicking.trigger(new ComponentEvent(EVENTS.PANEL_CHANGE, {\n      added: allPanelsInserted,\n      removed: []\n    }));\n\n    return allPanelsInserted;\n  }\n\n  /**\n   * Remove the panel at the given index\n   * This will decrease index of panels after by the number of panels removed\n   * @ko 주어진 인덱스의 패널을 제거합니다\n   * 해당 인덱스보다 큰 인덱스를 가진 기존 패널들은 제거한 패널의 개수만큼 인덱스가 감소합니다\n   * @param {number} index Index of panel to remove<ko>제거할 패널의 인덱스</ko>\n   * @param {number} [deleteCount=1] Number of panels to remove from index<ko>`index` 이후로 제거할 패널의 개수</ko>\n   * @return An array of removed panels<ko>제거된 패널들의 배열</ko>\n   */\n  public batchRemove(...items: Array<{ index: number; deleteCount: number }>): Panel[] {\n    const panels = this._panels;\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n\n    const { camera, control } = flicking;\n    const activePanel = control.activePanel;\n    const activeIndex = control.activeIndex;\n\n    const allPanelsRemoved = items.reduce((removed, item) => {\n      const { index, deleteCount } = item;\n      const removingIdx = getMinusCompensatedIndex(index, panels.length);\n\n      const panelsPulled = panels.slice(removingIdx + deleteCount);\n      const panelsRemoved = panels.splice(removingIdx, deleteCount);\n\n      if (panelsRemoved.length <= 0) return [];\n\n      // Update panel indexes & positions\n      const removedSize = this._getPanelSizeSum(panelsRemoved);\n      panelsPulled.forEach(panel => {\n        panel.decreaseIndex(panelsRemoved.length);\n        panel.decreasePosition(removedSize);\n      });\n\n      this._removePanelElements(panelsRemoved);\n\n      // Remove panel elements\n      panelsRemoved.forEach(panel => panel.destroy());\n\n      // Update camera & control\n      this._updateCameraAndControl();\n\n      if (includes(panelsRemoved, activePanel)) {\n        control.resetActive();\n      }\n\n      return [...removed, ...panelsRemoved];\n    }, []);\n\n    void this.render();\n\n    // FIXME: fix for animating case\n    if (allPanelsRemoved.length > 0 && !control.animating) {\n      const targetPanel = includes(allPanelsRemoved, activePanel)\n        ? (panels[activeIndex] || panels[panels.length - 1])\n        : activePanel;\n\n      if (targetPanel) {\n        void control.moveToPanel(targetPanel, {\n          duration: 0\n        }).catch(() => void 0);\n      } else {\n        // All panels removed\n        void camera.lookAt(0);\n      }\n    }\n\n    flicking.camera.updateOffset();\n\n    flicking.trigger(new ComponentEvent(EVENTS.PANEL_CHANGE, {\n      added: [],\n      removed: allPanelsRemoved\n    }));\n\n    return allPanelsRemoved;\n  }\n\n  protected _getPanelAlign() {\n    const align = this._align;\n\n    return typeof align === \"object\"\n      ? (align as { panel: string | number }).panel\n      : align;\n  }\n\n  protected _getPanelSizeSum(panels: Panel[]): number {\n    const firstPanel = panels[0];\n    const lastPanel = panels[panels.length - 1];\n\n    const marginDiff = lastPanel.margin.next - firstPanel.margin.prev;\n\n    return (lastPanel.range.max - firstPanel.range.min) + marginDiff;\n  }\n\n  protected _updateCameraAndControl() {\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n    const { camera, control } = flicking;\n\n    camera.updateRange();\n    camera.updateAnchors();\n    camera.resetNeedPanelHistory();\n    control.updateInput();\n  }\n}\n\nexport default Renderer;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking from \"../../Flicking\";\nimport { getProgress, getStyle, parseAlign } from \"../../utils\";\nimport { ALIGN, DIRECTION } from \"../../const/external\";\nimport { LiteralUnion, ValueOf } from \"../../type/internal\";\n\nexport interface PanelOptions {\n  index: number;\n  align: LiteralUnion<ValueOf<typeof ALIGN>> | number;\n  flicking: Flicking;\n}\n\nabstract class Panel {\n  // Internal States\n  protected _flicking: Flicking;\n  protected _index: number;\n  protected _pos: number;\n  protected _size: number;\n  protected _height: number;\n  protected _margin: { prev: number; next: number };\n  protected _alignPos: number; // Actual align pos\n  protected _removed: boolean;\n  protected _toggleDirection: ValueOf<typeof DIRECTION>;\n  protected _toggled: boolean;\n  protected _togglePosition: number;\n\n  // Options\n  protected _align: PanelOptions[\"align\"];\n\n  // Internal States Getter\n  /**\n   * `HTMLElement` that panel's referencing\n   * @ko 패널이 참조하고 있는 `HTMLElement`\n   * @type {HTMLElement}\n   * @readonly\n   */\n  abstract get element(): HTMLElement;\n  /**\n   * Index of the panel\n   * @ko 패널의 인덱스\n   * @type {number}\n   * @readonly\n   */\n  public get index() { return this._index; }\n  /**\n   * Position of the panel, including {@link Panel#alignPosition alignPosition}\n   * @ko 패널의 현재 좌표, {@link Panel#alignPosition alignPosition}을 포함하고 있습니다\n   * @type {number}\n   * @readonly\n   */\n  public get position() { return this._pos + this._alignPos; }\n  /**\n   * Cached size of the panel element\n   * This is equal to {@link Panel#element element}'s `offsetWidth` if {@link Flicking#horizontal horizontal} is `true`, and `offsetHeight` else\n   * @ko 패널 엘리먼트의 캐시된 크기\n   * 이 값은 {@link Flicking#horizontal horizontal}이 `true`일 경우 {@link Panel#element element}의 `offsetWidth`와 동일하고, `false`일 경우 `offsetHeight`와 동일합니다\n   * @type {number}\n   * @readonly\n   */\n  public get size() { return this._size; }\n  /**\n   * Panel's size including CSS `margin`\n   * This value includes {@link Panel#element element}'s margin left/right if {@link Flicking#horizontal horizontal} is `true`, and margin top/bottom else\n   * @ko CSS `margin`을 포함한 패널의 크기\n   * 이 값은 {@link Flicking#horizontal horizontal}이 `true`일 경우 margin left/right을 포함하고, `false`일 경우 margin top/bottom을 포함합니다\n   * @type {number}\n   * @readonly\n   */\n  public get sizeIncludingMargin() { return this._size + this._margin.prev + this._margin.next; }\n  /**\n   * Height of the panel element\n   * @ko 패널 엘리먼트의 높이\n   * @type {number}\n   * @readonly\n   */\n  public get height() { return this._height; }\n  /**\n   * Cached CSS `margin` value of the panel element\n   * @ko 패널 엘리먼트의 CSS `margin` 값\n   * @type {object}\n   * @property {number} prev CSS `margin-left` when the {@link Flicking#horizontal horizontal} is `true`, and `margin-top` else\n   * <ko>{@link Flicking#horizontal horizontal}이 `true`일 경우 `margin-left`, `false`일 경우 `margin-top`에 해당하는 값</ko>\n   * @property {number} next CSS `margin-right` when the {@link Flicking#horizontal horizontal} is `true`, and `margin-bottom` else\n   * <ko>{@link Flicking#horizontal horizontal}이 `true`일 경우 `margin-right`, `false`일 경우 `margin-bottom`에 해당하는 값</ko>\n   * @readonly\n   */\n  public get margin() { return this._margin; }\n  /**\n   * Align position inside the panel where {@link Camera}'s {@link Camera#alignPosition alignPosition} inside viewport should be located at\n   * @ko 패널의 정렬 기준 위치. {@link Camera}의 뷰포트 내에서의 {@link Camera#alignPosition alignPosition}이 위치해야 하는 곳입니다\n   * @type {number}\n   * @readonly\n   */\n  public get alignPosition() { return this._alignPos; }\n  /**\n   * A value indicating whether the panel's {@link Flicking#remove remove}d\n   * @ko 패널이 {@link Flicking#remove remove}되었는지 여부를 나타내는 값\n   * @type {boolean}\n   * @readonly\n   */\n  public get removed() { return this._removed; }\n  /**\n   * A value indicating whether the panel's element is being rendered on the screen\n   * @ko 패널의 엘리먼트가 화면상에 렌더링되고있는지 여부를 나타내는 값\n   * @type {boolean}\n   * @readonly\n   */\n  public abstract get rendered();\n  /**\n   * Panel element's range of the bounding box\n   * @ko 패널 엘리먼트의 Bounding box 범위\n   * @type {object}\n   * @property {number} [min] Bounding box's left({@link Flicking#horizontal horizontal}: true) / top({@link Flicking#horizontal horizontal}: false)\n   * @property {number} [max] Bounding box's right({@link Flicking#horizontal horizontal}: true) / bottom({@link Flicking#horizontal horizontal}: false)\n   * @readonly\n   */\n  public get range() { return { min: this._pos, max: this._pos + this._size }; }\n  /**\n   * A value indicating whether the panel's position is toggled by circular behavior\n   * @ko 패널의 위치가 circular 동작에 의해 토글되었는지 여부를 나타내는 값\n   * @type {boolean}\n   * @readonly\n   */\n  public get toggled() { return this._toggled; }\n  /**\n   * A direction where the panel's position is toggled\n   * @ko 패널의 위치가 circular 동작에 의해 토글되는 방향\n   * @type {DIRECTION}\n   * @readonly\n   */\n  public get toggleDirection() { return this._toggleDirection; }\n  /**\n   * Actual position offset determined by {@link Panel#order}\n   * @ko {@link Panel#order}에 의한 실제 위치 변경값\n   * @type {number}\n   * @readonly\n   */\n  public get offset() {\n    const toggleDirection = this._toggleDirection;\n    const cameraRangeDiff = this._flicking.camera.rangeDiff;\n\n    return toggleDirection === DIRECTION.NONE || !this._toggled\n      ? 0\n      : toggleDirection === DIRECTION.PREV\n        ? -cameraRangeDiff\n        : cameraRangeDiff;\n  }\n\n  /**\n   * Progress of movement between previous or next panel relative to current panel\n   * @ko 이 패널로부터 이전/다음 패널으로의 이동 진행률\n   * @type {number}\n   * @readonly\n   */\n  public get progress() {\n    const flicking = this._flicking;\n\n    return this.index - flicking.camera.progress;\n  }\n\n  /**\n   * Progress of movement between points that panel is completely invisible outside of viewport(prev direction: -1, selected point: 0, next direction: 1)\n   * @ko 현재 패널이 뷰포트 영역 밖으로 완전히 사라지는 지점을 기준으로 하는 진행도(prev방향: -1, 선택 지점: 0, next방향: 1)\n   * @type {number}\n   * @readonly\n   */\n  public get outsetProgress() {\n    const position = this.position + this.offset;\n    const alignPosition = this._alignPos;\n    const camera = this._flicking.camera;\n    const camPos = camera.position;\n\n    if (camPos === position) {\n      return 0;\n    }\n\n    if (camPos < position) {\n      const disappearPosNext = position + (camera.size - camera.alignPosition) + alignPosition;\n\n      return -getProgress(camPos, position, disappearPosNext);\n    } else {\n      const disappearPosPrev = position - (camera.alignPosition + this._size - alignPosition);\n\n      return 1 - getProgress(camPos, disappearPosPrev, position);\n    }\n  }\n\n  /**\n   * Percentage of area where panel is visible in the viewport\n   * @ko 뷰포트 안에서 패널이 보이는 영역의 비율\n   * @type {number}\n   * @readonly\n   */\n  public get visibleRatio() {\n    const range = this.range;\n    const size = this._size;\n    const offset = this.offset;\n    const visibleRange = this._flicking.camera.visibleRange;\n\n    const checkingRange = {\n      min: range.min + offset,\n      max: range.max + offset\n    };\n\n    if (checkingRange.max <= visibleRange.min || checkingRange.min >= visibleRange.max) {\n      return 0;\n    }\n\n    let visibleSize = size;\n\n    if (visibleRange.min > checkingRange.min) {\n      visibleSize -= visibleRange.min - checkingRange.min;\n    }\n    if (visibleRange.max < checkingRange.max) {\n      visibleSize -= checkingRange.max - visibleRange.max;\n    }\n\n    return visibleSize / size;\n  }\n\n  // Options Getter\n  /**\n   * A value indicating where the {@link Panel#alignPosition alignPosition} should be located at inside the panel element\n   * @ko {@link Panel#alignPosition alignPosition}이 패널 내의 어디에 위치해야 하는지를 나타내는 값\n   * @type {Constants.ALIGN | string | number}\n   */\n  public get align() { return this._align; }\n\n  // Options Getter\n  public set align(val: PanelOptions[\"align\"]) { this._align = val; }\n\n  /**\n   * @param {object} options An options object<ko>옵션 오브젝트</ko>\n   * @param {number} [options.index] An initial index of the panel<ko>패널의 초기 인덱스</ko>\n   * @param {Constants.ALIGN | string | number} [options.align] An initial {@link Flicking#align align} value of the panel<ko>패널의 초기 {@link Flicking#align align}값</ko>\n   * @param {Flicking} [options.flicking] A Flicking instance panel's referencing<ko>패널이 참조하는 {@link Flicking} 인스턴스</ko>\n   */\n  public constructor({\n    index,\n    align,\n    flicking\n  }: PanelOptions) {\n    this._index = index;\n    this._flicking = flicking;\n\n    this._align = align;\n\n    this._removed = false;\n    this._resetInternalStates();\n  }\n\n  /**\n   * Mark panel element to be appended on the camera element\n   * @internal\n   */\n  public abstract markForShow();\n\n  /**\n   * Mark panel element to be removed from the camera element\n   * @internal\n   */\n  public abstract markForHide();\n\n  /**\n   * Update size of the panel\n   * @ko 패널의 크기를 갱신합니다\n   * @chainable\n   * @return {this}\n   */\n  public resize(): this {\n    const el = this.element;\n    const elStyle = getStyle(el);\n    const flicking = this._flicking;\n    const horizontal = flicking.horizontal;\n    const prevPanel = flicking.renderer.panels[this._index - 1];\n\n    this._size = horizontal ? el.offsetWidth : el.offsetHeight;\n\n    this._margin = horizontal\n      ? {\n        prev: parseFloat(elStyle.marginLeft || \"0\"),\n        next: parseFloat(elStyle.marginRight || \"0\")\n      } : {\n        prev: parseFloat(elStyle.marginTop || \"0\"),\n        next: parseFloat(elStyle.marginBottom || \"0\")\n      };\n\n    this._pos = prevPanel\n      ? prevPanel.range.max + prevPanel.margin.next + this._margin.prev\n      : this._margin.prev;\n\n    this._height = horizontal ? el.offsetHeight : this._size;\n\n    this._updateAlignPos();\n\n    return this;\n  }\n\n  /**\n   * Check whether the given element is inside of this panel's {@link Panel#element element}\n   * @ko 해당 엘리먼트가 이 패널의 {@link Panel#element element} 내에 포함되어 있는지를 반환합니다\n   * @param {HTMLElement} element The HTMLElement to check<ko>확인하고자 하는 HTMLElement</ko>\n   * @return {boolean} A Boolean value indicating the element is inside of this panel {@link Panel#element element}<ko>패널의 {@link Panel#element element}내에 해당 엘리먼트 포함 여부</ko>\n   */\n  public contains(element: HTMLElement): boolean {\n    return !!this.element?.contains(element);\n  }\n\n  /**\n   * Reset internal state and set {@link Panel#removed removed} to `true`\n   * @ko 내부 상태를 초기화하고 {@link Panel#removed removed}를 `true`로 설정합니다.\n   * @return {void}\n   */\n  public destroy(): void {\n    this._resetInternalStates();\n    this._removed = true;\n  }\n\n  /**\n   * Check whether the given position is inside of this panel's {@link Panel#range range}\n   * @ko 주어진 좌표가 현재 패널의 {@link Panel#range range}내에 속해있는지를 반환합니다.\n   * @param {number} pos A position to check<ko>확인하고자 하는 좌표</ko>\n   * @param {boolean} [includeMargin=false] Include {@link Panel#margin margin} to the range<ko>패널 영역에 {@link Panel#margin margin}값을 포함시킵니다</ko>\n   * @return {boolean} A Boolean value indicating whether the given position is included in the panel range<ko>해당 좌표가 패널 영역 내에 속해있는지 여부</ko>\n   */\n  public includePosition(pos: number, includeMargin: boolean = false): boolean {\n    return this.includeRange(pos, pos, includeMargin);\n  }\n\n  /**\n   * Check whether the given range is fully included in this panel's area\n   * @ko 주어진 범위가 이 패널 내부에 완전히 포함되는지를 반환합니다\n   * @param {number} min Minimum value of the range to check<ko>확인하고자 하는 최소 범위</ko>\n   * @param {number} max Maximum value of the range to check<ko>확인하고자 하는 최대 범위</ko>\n   * @param {boolean} [includeMargin=false] Include {@link Panel#margin margin} to the range<ko>패널 영역에 {@link Panel#margin margin}값을 포함시킵니다</ko>\n   * @returns {boolean} A Boolean value indicating whether the given range is fully included in the panel range<ko>해당 범위가 패널 영역 내에 완전히 속해있는지 여부</ko>\n   */\n  public includeRange(min: number, max: number, includeMargin: boolean = false): boolean {\n    const margin = this._margin;\n    const panelRange = this.range;\n\n    if (includeMargin) {\n      panelRange.min -= margin.prev;\n      panelRange.max += margin.next;\n    }\n\n    return max >= panelRange.min && min <= panelRange.max;\n  }\n\n  /**\n   * Move {@link Camera} to this panel\n   * @ko {@link Camera}를 이 패널로 이동합니다\n   * @param {number} [duration] Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>\n   * @returns {Promise<void>} A Promise which will be resolved after reaching the panel<ko>패널 도달시에 resolve되는 Promise</ko>\n   */\n  public focus(duration?: number) {\n    return this._flicking.moveTo(this._index, duration);\n  }\n\n  /**\n   * Get previous(`index - 1`) panel. When the previous panel does not exist, this will return `null` instead\n   * If the {@link Flicking#circularEnabled circular} is enabled, this will return the last panel if called from the first panel\n   * @ko 이전(`index - 1`) 패널을 반환합니다. 이전 패널이 없을 경우 `null`을 반환합니다\n   * {@link Flicking#circularEnabled circular} 모드가 활성화되었을 때 첫번째 패널에서 이 메소드를 호출할 경우 마지막 패널을 반환합니다\n   * @returns {Panel | null} The previous panel<ko>이전 패널</ko>\n   */\n  public prev(): Panel | null {\n    const index = this._index;\n    const flicking = this._flicking;\n    const renderer = flicking.renderer;\n    const panelCount = renderer.panelCount;\n\n    if (panelCount === 1) return null;\n\n    return flicking.circularEnabled\n      ? renderer.getPanel(index === 0 ? panelCount - 1 : index - 1)\n      : renderer.getPanel(index - 1);\n  }\n\n  /**\n   * Get next(`index + 1`) panel. When the next panel does not exist, this will return `null` instead\n   * If the {@link Flicking#circularEnabled circular} is enabled, this will return the first panel if called from the last panel\n   * @ko 다음(`index + 1`) 패널을 반환합니다. 다음 패널이 없을 경우 `null`을 반환합니다\n   * {@link Flicking#circularEnabled circular} 모드가 활성화되었을 때 마지막 패널에서 이 메소드를 호출할 경우 첫번째 패널을 반환합니다\n   * @returns {Panel | null} The previous panel<ko>다음 패널</ko>\n   */\n  public next(): Panel | null {\n    const index = this._index;\n    const flicking = this._flicking;\n    const renderer = flicking.renderer;\n    const panelCount = renderer.panelCount;\n\n    if (panelCount === 1) return null;\n\n    return flicking.circularEnabled\n      ? renderer.getPanel(index === panelCount - 1 ? 0 : index + 1)\n      : renderer.getPanel(index + 1);\n  }\n\n  /**\n   * Increase panel's index by the given value\n   * @ko 패널의 인덱스를 주어진 값만큼 증가시킵니다\n   * @internal\n   * @chainable\n   * @param val An integer greater than or equal to 0<ko>0보다 같거나 큰 정수</ko>\n   * @returns {this}\n   */\n  public increaseIndex(val: number): this {\n    this._index += Math.max(val, 0);\n    return this;\n  }\n\n  /**\n   * Decrease panel's index by the given value\n   * @ko 패널의 인덱스를 주어진 값만큼 감소시킵니다\n   * @internal\n   * @chainable\n   * @param val An integer greater than or equal to 0<ko>0보다 같거나 큰 정수</ko>\n   * @returns {this}\n   */\n  public decreaseIndex(val: number): this {\n    this._index -= Math.max(val, 0);\n    return this;\n  }\n\n  /**\n   * Increase panel's position by the given value\n   * @ko 패널의 위치를 주어진 값만큼 증가시킵니다\n   * @internal\n   * @chainable\n   * @param val An integer greater than or equal to 0<ko>0보다 같거나 큰 정수</ko>\n   * @returns {this}\n   */\n  public increasePosition(val: number): this {\n    this._moveBy(Math.max(val, 0));\n    return this;\n  }\n\n  /**\n   * Decrease panel's position by the given value\n   * @ko 패널의위치를 주어진 값만큼 감소시킵니다\n   * @internal\n   * @chainable\n   * @param val An integer greater than or equal to 0<ko>0보다 같거나 큰 정수</ko>\n   * @returns {this}\n   */\n  public decreasePosition(val: number): this {\n    this._moveBy(-Math.max(val, 0));\n    return this;\n  }\n\n  /**\n   * @internal\n   * @return {boolean} toggled\n   */\n  public toggle(prevPos: number, newPos: number): boolean {\n    const toggleDirection = this._toggleDirection;\n    const togglePosition = this._togglePosition;\n\n    if (toggleDirection === DIRECTION.NONE || newPos === prevPos) return false;\n\n    const prevToggled = this._toggled;\n\n    if (newPos > prevPos) {\n      if (togglePosition >= prevPos && togglePosition <= newPos) {\n        this._toggled = toggleDirection === DIRECTION.NEXT;\n      }\n    } else {\n      if (togglePosition <= prevPos && togglePosition >= newPos) {\n        this._toggled = toggleDirection !== DIRECTION.NEXT;\n      }\n    }\n\n    return prevToggled !== this._toggled;\n  }\n\n  /**\n   * @internal\n   */\n  public updateCircularToggleDirection(): this {\n    const flicking = this._flicking;\n\n    if (!flicking.circularEnabled) {\n      this._toggleDirection = DIRECTION.NONE;\n      this._toggled = false;\n      return this;\n    }\n\n    const camera = flicking.camera;\n    const camRange = camera.range;\n    const camAlignPosition = camera.alignPosition;\n    const camVisibleRange = camera.visibleRange;\n    const camVisibleSize = camVisibleRange.max - camVisibleRange.min;\n\n    const minimumVisible = camRange.min - camAlignPosition;\n    const maximumVisible = camRange.max - camAlignPosition + camVisibleSize;\n\n    const shouldBeVisibleAtMin = this.includeRange(maximumVisible - camVisibleSize, maximumVisible, false);\n    const shouldBeVisibleAtMax = this.includeRange(minimumVisible, minimumVisible + camVisibleSize, false);\n\n    this._toggled = false;\n    if (shouldBeVisibleAtMin) {\n      this._toggleDirection = DIRECTION.PREV;\n      this._togglePosition = this.range.max + camRange.min - camRange.max + camAlignPosition;\n      this.toggle(Infinity, camera.position);\n    } else if (shouldBeVisibleAtMax) {\n      this._toggleDirection = DIRECTION.NEXT;\n      this._togglePosition = this.range.min + camRange.max - camVisibleSize + camAlignPosition;\n      this.toggle(-Infinity, camera.position);\n    } else {\n      this._toggleDirection = DIRECTION.NONE;\n      this._togglePosition = 0;\n    }\n\n    return this;\n  }\n\n  private _moveBy(val: number): this {\n    this._pos += val;\n\n    return this;\n  }\n\n  private _updateAlignPos() {\n    this._alignPos = parseAlign(this._align, this._size);\n  }\n\n  private _resetInternalStates() {\n    this._size = 0;\n    this._pos = 0;\n    this._margin = { prev: 0, next: 0 };\n    this._height = 0;\n    this._alignPos = 0;\n    this._toggled = false;\n    this._togglePosition = 0;\n    this._toggleDirection = DIRECTION.NONE;\n  }\n}\n\nexport default Panel;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Panel, { PanelOptions } from \"./Panel\";\n\nexport interface ElementPanelOptions extends PanelOptions {\n  el: HTMLElement;\n}\n\n/**\n * An slide data component that holds information of a single HTMLElement\n * @ko 슬라이드 데이터 컴포넌트로, 단일 HTMLElement의 정보를 갖고 있습니다\n */\nclass ElementPanel extends Panel {\n  private _el: HTMLElement;\n  private _rendered: boolean;\n\n  /**\n   * `HTMLElement` that panel's referencing\n   * @ko 패널이 참조하고 있는 `HTMLElement`\n   * @type {HTMLElement}\n   * @readonly\n   */\n  public get element() { return this._el; }\n\n  public get rendered() { return this._rendered; }\n\n  /**\n   * @param {object} options An options object<ko>옵션 오브젝트</ko>\n   * @param {HTMLElement} [options.el] A `HTMLElement` panel's referencing<ko>패널이 참조하는 `HTMLElement`</ko>\n   * @param {number} [options.index] An initial index of the panel<ko>패널의 초기 인덱스</ko>\n   * @param {Constants.ALIGN | string | number} [options.align] An initial {@link Flicking#align align} value of the panel<ko>패널의 초기 {@link Flicking#align align}값</ko>\n   * @param {Flicking} [options.flicking] A Flicking instance panel's referencing<ko>패널이 참조하는 {@link Flicking} 인스턴스</ko>\n   */\n  public constructor(options: ElementPanelOptions) {\n    super(options);\n\n    this._el = options.el;\n    this._rendered = true;\n  }\n\n  public markForShow() {\n    this._rendered = true;\n  }\n\n  public markForHide() {\n    this._rendered = false;\n  }\n}\n\nexport default ElementPanel;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { getFlickingAttached, toArray } from \"../utils\";\nimport Panel, { PanelOptions } from \"../core/panel/Panel\";\nimport ElementPanel from \"../core/panel/ElementPanel\";\n\nimport Renderer from \"./Renderer\";\n\n/**\n *\n */\nclass VanillaRenderer extends Renderer {\n  // eslint-disable-next-line @typescript-eslint/require-await\n  public async render() {\n    const strategy = this._renderingStrategy;\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n    const cameraEl = flicking.camera.element;\n    const wasRenderedPanels = this._panels.filter(panel => panel.element.parentElement === cameraEl);\n\n    strategy.updateRenderingPanels(flicking);\n    const renderingPanels = this._getRenderingPanelsByOrder();\n\n    this._removePanelElements(wasRenderedPanels.filter(panel => !panel.rendered));\n    this._insertPanelElements(renderingPanels.filter(panel => panel.element.parentElement !== cameraEl), null);\n    this._resetPanelElementOrder(renderingPanels);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  public async forceRenderAllPanels() {\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n    const camera = flicking.camera;\n    const cameraElement = camera.element;\n    const fragment = document.createDocumentFragment();\n\n    this._panels.forEach(panel => fragment.appendChild(panel.element));\n\n    this._removeAllChildsFromCamera();\n\n    cameraElement.appendChild(fragment);\n  }\n\n  protected _collectPanels() {\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n\n    const cameraElement = flicking.camera.element;\n\n    // Remove all text nodes in the camera element\n    toArray(cameraElement.childNodes).forEach(node => {\n      if (node.nodeType === Node.TEXT_NODE) {\n        cameraElement.removeChild(node);\n      }\n    });\n\n    const align = this._getPanelAlign();\n    const cameraChilds = toArray(cameraElement.children);\n\n    this._panels = cameraChilds.map(\n      (el: HTMLElement, index: number) => new ElementPanel({ flicking, el, index, align })\n    );\n  }\n\n  protected _createPanel(el: HTMLElement, options: PanelOptions): ElementPanel {\n    return new ElementPanel({ el, ...options });\n  }\n\n  protected _insertPanelElements(panels: Panel[], nextSibling: Panel | null) {\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n    const camera = flicking.camera;\n    const cameraElement = camera.element;\n    const nextSiblingElement = nextSibling?.element || null;\n    const fragment = document.createDocumentFragment();\n\n    panels.forEach(panel => fragment.appendChild(panel.element));\n    cameraElement.insertBefore(fragment, nextSiblingElement);\n\n    return this;\n  }\n\n  protected _removePanelElements(panels: Panel[]): this {\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n    const cameraElement = flicking.camera.element;\n\n    panels.forEach(panel => {\n      cameraElement.removeChild(panel.element);\n    });\n\n    return this;\n  }\n\n  private _resetPanelElementOrder(panels: Panel[]) {\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n    const cameraEl = flicking.camera.element;\n\n    // We're using reversed panels here as last panel should be the last element of camera element\n    const reversedPanels = [...panels].reverse();\n    reversedPanels.forEach((panel, idx) => {\n      const nextPanel = reversedPanels[idx - 1];\n      const nextPanelEl = nextPanel ? nextPanel.element : null;\n\n      if (panel.element.nextElementSibling !== nextPanelEl) {\n        cameraEl.insertBefore(panel.element, nextPanelEl);\n      }\n    });\n  }\n\n  private _removeAllChildsFromCamera() {\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n    const cameraElement = flicking.camera.element;\n\n    // Remove other elements\n    while (cameraElement.firstChild) {\n      cameraElement.removeChild(cameraElement.firstChild);\n    }\n  }\n\n  private _getRenderingPanelsByOrder(): Panel[] {\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n    const panels = flicking.renderer.panels;\n\n    return panels.filter(panel => panel.rendered)\n      .sort((a, b) => (a.position + a.offset) - (b.position + b.offset));\n  }\n}\n\nexport default VanillaRenderer;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Panel from \"../core/panel/Panel\";\n\nimport Renderer from \"./Renderer\";\n\n/**\n *\n */\nabstract class ExternalRenderer extends Renderer {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  protected _insertPanelElements(panels: Panel[], nextSibling: Panel | null): void {\n    // DO NOTHING\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  protected _removePanelElements(panels: Panel[]): void {\n    // DO NOTHING\n  }\n}\n\nexport default ExternalRenderer;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking from \"../../Flicking\";\n\nimport RenderingStrategy from \"./RenderingStrategy\";\n\nclass VisibleRenderingStrategy implements RenderingStrategy {\n  public updateRenderingPanels(flicking: Flicking) {\n    const panels = flicking.renderer.panels;\n    const camera = flicking.camera;\n\n    const visibleIndexes = camera.visiblePanels.reduce((visibles, panel) => {\n      visibles[panel.index] = true;\n      return visibles;\n    }, {});\n\n    panels.forEach(panel => {\n      if (panel.index in visibleIndexes) {\n        panel.markForShow();\n      } else if (!flicking.holding) {\n        // During the input sequence,\n        // Do not remove panel elements as it won't trigger touchend event.\n        panel.markForHide();\n      }\n    });\n\n    camera.updateOffset();\n  }\n}\n\nexport default VisibleRenderingStrategy;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Component, { ComponentEvent } from \"@egjs/component\";\n\nimport FlickingError from \"./core/FlickingError\";\nimport Viewport from \"./core/Viewport\";\nimport { Panel } from \"./core/panel\";\nimport { Control, SnapControl, FreeControl, StrictControl, FreeControlOptions, StrictControlOptions } from \"./control\";\nimport { BoundCamera, Camera, CircularCamera, LinearCamera } from \"./camera\";\nimport { Renderer, VanillaRenderer, ExternalRenderer, RawRenderingStrategy, VisibleRenderingStrategy } from \"./renderer\";\nimport { EVENTS, ALIGN, MOVE_TYPE, DIRECTION } from \"./const/external\";\nimport * as ERROR from \"./const/error\";\nimport { findIndex, getElement, includes, parseElement } from \"./utils\";\nimport { HoldStartEvent, HoldEndEvent, MoveStartEvent, SelectEvent, MoveEvent, MoveEndEvent, WillChangeEvent, WillRestoreEvent, NeedPanelEvent, VisibleChangeEvent, ReachEdgeEvent, ReadyEvent, AfterResizeEvent, BeforeResizeEvent, ChangedEvent, RestoredEvent, PanelChangeEvent } from \"./type/event\";\nimport { LiteralUnion, ValueOf } from \"./type/internal\";\nimport { ElementLike, Plugin, Status, MoveTypeOptions } from \"./type/external\";\n\n/**\n * @interface\n */\nexport interface FlickingEvents {\n  [EVENTS.READY]: ReadyEvent;\n  [EVENTS.BEFORE_RESIZE]: BeforeResizeEvent;\n  [EVENTS.AFTER_RESIZE]: AfterResizeEvent;\n  [EVENTS.HOLD_START]: HoldStartEvent;\n  [EVENTS.HOLD_END]: HoldEndEvent;\n  [EVENTS.MOVE_START]: MoveStartEvent;\n  [EVENTS.MOVE]: MoveEvent;\n  [EVENTS.MOVE_END]: MoveEndEvent;\n  [EVENTS.WILL_CHANGE]: WillChangeEvent;\n  [EVENTS.CHANGED]: ChangedEvent;\n  [EVENTS.WILL_RESTORE]: WillRestoreEvent;\n  [EVENTS.RESTORED]: RestoredEvent;\n  [EVENTS.SELECT]: SelectEvent;\n  [EVENTS.NEED_PANEL]: NeedPanelEvent;\n  [EVENTS.VISIBLE_CHANGE]: VisibleChangeEvent;\n  [EVENTS.REACH_EDGE]: ReachEdgeEvent;\n  [EVENTS.PANEL_CHANGE]: PanelChangeEvent;\n}\n\n/**\n * @interface\n */\nexport interface FlickingOptions {\n  // UI / LAYOUT\n  align: LiteralUnion<ValueOf<typeof ALIGN>> | number | { panel: number | string; camera: number | string };\n  defaultIndex: number;\n  horizontal: boolean;\n  circular: boolean;\n  bound: boolean;\n  adaptive: boolean;\n  // EVENT\n  needPanelThreshold: number;\n  preventEventsBeforeInit: boolean;\n  // ANIMATION\n  deceleration: number;\n  duration: number;\n  easing: (x: number) => number;\n  // INPUT\n  inputType: string[];\n  moveType: ValueOf<typeof MOVE_TYPE> | MoveTypeOptions<ValueOf<typeof MOVE_TYPE>>;\n  threshold: number;\n  interruptable: boolean;\n  bounce: number | string | [number | string, number | string];\n  iOSEdgeSwipeThreshold: number;\n  preventClickOnDrag: boolean;\n  disableOnInit: boolean;\n  // PERFORMANCE\n  renderOnlyVisible: boolean;\n  // OTHERS\n  autoInit: boolean;\n  autoResize: boolean;\n  renderExternal: {\n    renderer: typeof ExternalRenderer;\n    rendererOptions: {[key: string]: any};\n  } | null;\n}\n\n/**\n * @extends Component\n * @support {\"ie\": \"9+(with polyfill)\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\", \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"4.X+\"}\n * @requires {@link https://github.com/naver/egjs-component|@egjs/component}\n * @requires {@link https://github.com/naver/egjs-axes|@egjs/axes}\n */\nclass Flicking extends Component<FlickingEvents> {\n  /**\n   * Version info string\n   * @ko 버전정보 문자열\n   * @type {string}\n   * @readonly\n   * @example\n   * ```ts\n   * Flicking.VERSION;  // ex) 4.0.0\n   * ```\n   */\n  public static VERSION = \"#__VERSION__#\";\n\n  // Core components\n  private _viewport: Viewport;\n  private _camera: Camera;\n  private _control: Control;\n  private _renderer: Renderer;\n\n  // Options\n  private _align: FlickingOptions[\"align\"];\n  private _defaultIndex: FlickingOptions[\"defaultIndex\"];\n  private _horizontal: FlickingOptions[\"horizontal\"];\n  private _circular: FlickingOptions[\"circular\"];\n  private _bound: FlickingOptions[\"bound\"];\n  private _adaptive: FlickingOptions[\"adaptive\"];\n  private _needPanelThreshold: FlickingOptions[\"needPanelThreshold\"];\n  private _preventEventsBeforeInit: FlickingOptions[\"preventEventsBeforeInit\"];\n  private _deceleration: FlickingOptions[\"deceleration\"];\n  private _duration: FlickingOptions[\"duration\"];\n  private _easing: FlickingOptions[\"easing\"];\n  private _inputType: FlickingOptions[\"inputType\"];\n  private _moveType: FlickingOptions[\"moveType\"];\n  private _threshold: FlickingOptions[\"threshold\"];\n  private _interruptable: FlickingOptions[\"interruptable\"];\n  private _bounce: FlickingOptions[\"bounce\"];\n  private _iOSEdgeSwipeThreshold: FlickingOptions[\"iOSEdgeSwipeThreshold\"];\n  private _preventClickOnDrag: FlickingOptions[\"preventClickOnDrag\"];\n  private _disableOnInit: FlickingOptions[\"disableOnInit\"];\n  private _renderOnlyVisible: FlickingOptions[\"renderOnlyVisible\"];\n  private _autoResize: FlickingOptions[\"autoResize\"];\n  private _autoInit: FlickingOptions[\"autoInit\"];\n  private _renderExternal: FlickingOptions[\"renderExternal\"];\n\n  // Internal State\n  private _initialized: boolean;\n  private _plugins: Plugin[];\n\n  // Components\n  /**\n   * {@link Control} instance of the Flicking\n   * @ko 현재 Flicking에 활성화된 {@link Control} 인스턴스\n   * @type {Control}\n   * @default SnapControl\n   * @readonly\n   * @see Control\n   * @see SnapControl\n   * @see FreeControl\n   */\n  public get control() { return this._control; }\n  /**\n   * {@link Camera} instance of the Flicking\n   * @ko 현재 Flicking에 활성화된 {@link Camera} 인스턴스\n   * @type {Camera}\n   * @default LinearCamera\n   * @readonly\n   * @see Camera\n   * @see LinearCamera\n   * @see BoundCamera\n   * @see CircularCamera\n   */\n  public get camera() { return this._camera; }\n  /**\n   * {@link Renderer} instance of the Flicking\n   * @ko 현재 Flicking에 활성화된 {@link Renderer} 인스턴스\n   * @type {Renderer}\n   * @default VanillaRenderer\n   * @readonly\n   * @see Renderer\n   * @see VanillaRenderer\n   * @see ExternalRenderer\n   */\n  public get renderer() { return this._renderer; }\n  /**\n   * A component that manages viewport size\n   * @ko 뷰포트 크기 정보를 담당하는 컴포넌트\n   * @type {Viewport}\n   * @readonly\n   * @see Viewport\n   */\n  public get viewport() { return this._viewport; }\n  // Internal States\n  /**\n   * Whether Flicking's {@link Flicking#init init()} is called.\n   * This is `true` when {@link Flicking#init init()} is called, and is `false` after calling {@link Flicking#destroy destroy()}.\n   * @ko Flicking의 {@link Flicking#init init()}이 호출되었는지를 나타내는 멤버 변수.\n   * 이 값은 {@link Flicking#init init()}이 호출되었으면 `true`로 변하고, {@link Flicking#destroy destroy()}호출 이후에 다시 `false`로 변경됩니다.\n   * @type {boolean}\n   * @default false\n   * @readonly\n   */\n  public get initialized() { return this._initialized; }\n  /**\n   * Whether the `circular` option is enabled.\n   * The {@link Flicking#circular circular} option can't be enabled when sum of the panel sizes are too small.\n   * @ko {@link Flicking#circular circular} 옵션이 활성화되었는지 여부를 나타내는 멤버 변수.\n   * {@link Flicking#circular circular} 옵션은 패널의 크기의 합이 충분하지 않을 경우 비활성화됩니다.\n   * @type {boolean}\n   * @default false\n   * @readonly\n   */\n  public get circularEnabled() { return this._camera.controlParams.circular; }\n  /**\n   * Index number of the {@link Flicking#currentPanel currentPanel}\n   * @ko {@link Flicking#currentPanel currentPanel}의 인덱스 번호\n   * @type {number}\n   * @default 0\n   * @readonly\n   */\n  public get index() { return this._control.activeIndex; }\n  /**\n   * The root(`.flicking-viewport`) element\n   * @ko root(`.flicking-viewport`) 엘리먼트\n   * @type {HTMLElement}\n   * @readonly\n   */\n  public get element() { return this._viewport.element; }\n  /**\n   * Currently active panel\n   * @ko 현재 선택된 패널\n   * @type {Panel}\n   * @readonly\n   * @see Panel\n   */\n  public get currentPanel() { return this._control.activePanel; }\n  /**\n   * Array of panels\n   * @ko 전체 패널들의 배열\n   * @type {Panel[]}\n   * @readonly\n   * @see Panel\n   */\n  public get panels() { return this._renderer.panels; }\n  /**\n   * Count of panels\n   * @ko 전체 패널의 개수\n   * @type {number}\n   * @readonly\n   */\n  public get panelCount() { return this._renderer.panelCount; }\n  /**\n   * Array of panels that is visible at the current position\n   * @ko 현재 보이는 패널의 배열\n   * @type {Panel[]}\n   * @readonly\n   * @see Panel\n   */\n  public get visiblePanels() { return this._camera.visiblePanels; }\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {boolean}\n   * @readonly\n   */\n  public get animating() { return this._control.animating; }\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {boolean}\n   * @readonly\n   */\n  public get holding() { return this._control.holding; }\n  /**\n   * A current list of activated plugins\n   * @ko 현재 활성화된 플러그인 목록\n   * @type {Plugin[]}\n   * @readonly\n   */\n  public get activePlugins() { return this._plugins; }\n\n  // Options Getter\n  // UI / LAYOUT\n  /**\n   * Align position of the panels within viewport. You can set different values each for the panel and camera\n   * @ko 뷰포트 내에서 패널 정렬방식을 설정하는 옵션. 카메라와 패널 개별로 옵션을 설정할 수도 있습니다\n   * @type {ALIGN | string | number | { panel: string | number, camera: string | number }}\n   * @property {ALIGN | string | number} panel The align value for each {@link Panel}s<ko>개개의 {@link Panel}에 적용할 값</ko>\n   * @property {ALIGN | string | number} camera The align value for {@link Camera}<ko>{@link Camera}에 적용할 값</ko>\n   * @default \"center\"\n   * @example\n   * ```ts\n   * const possibleOptions = [\n   *   // Literal strings\n   *   \"prev\", \"center\", \"next\",\n   *   // % values, applied to both panel & camera\n   *   \"0%\", \"25%\", \"42%\",\n   *   // px values, arithmetic calculation with (+/-) is also allowed.\n   *   \"0px\", \"100px\", \"50% - 25px\",\n   *   // numbers, same to number + px (\"0px\", \"100px\")\n   *   0, 100, 1000,\n   *   // Setting a different value for panel & camera\n   *   { panel: \"10%\", camera: \"25%\" }\n   * ];\n   *\n   * possibleOptions.forEach(align => {\n   *   new Flicking(\"#el\", { align });\n   * });\n   * ```\n   */\n  public get align() { return this._align; }\n  /**\n   * Index of the panel to move when Flicking's {@link Flicking#init init()} is called. A zero-based integer\n   * @ko Flicking의 {@link Flicking#init init()}이 호출될 때 이동할 디폴트 패널의 인덱스로, 0부터 시작하는 정수입니다\n   * @type {number}\n   * @default 0\n   */\n  public get defaultIndex() { return this._defaultIndex; }\n  /**\n   * Direction of panel movement (true: horizontal, false: vertical)\n   * @ko 패널 이동 방향 (true: 가로방향, false: 세로방향)\n   * @type {boolean}\n   * @default true\n   */\n  public get horizontal() { return this._horizontal; }\n  /**\n   * Enables circular(continuous loop) mode, which connects first/last panel for continuous scrolling.\n   * @ko 순환 모드를 활성화합니다. 순환 모드에서는 양 끝의 패널이 서로 연결되어 끊김없는 스크롤이 가능합니다.\n   * @type {boolean}\n   * @default false\n   */\n  public get circular() { return this._circular; }\n  /**\n   * Prevent the view(camera element) from going out of the first/last panel, so it won't show empty spaces before/after the first/last panel\n   * Only can be enabled when `circular=false`\n   * @ko 뷰(카메라 엘리먼트)가 첫번째와 마지막 패널 밖으로 넘어가지 못하게 하여, 첫번째/마지막 패널 전/후의 빈 공간을 보이지 않도록 하는 옵션입니다\n   * `circular=false`인 경우에만 사용할 수 있습니다\n   * @type {boolean}\n   * @default false\n   */\n  public get bound() { return this._bound; }\n  /**\n   * Update height of the viewport element after movement same to the height of the panel below. This can be only enabled when `horizontal=true`\n   * @ko 이동한 후 뷰포트 엘리먼트의 크기를 현재 패널의 높이와 동일하게 설정합니다. `horizontal=true`인 경우에만 사용할 수 있습니다.\n   * @type {boolean}\n   * @default false\n   */\n  public get adaptive() { return this._adaptive; }\n  // EVENTS\n  /**\n   * A Threshold from viewport edge before triggering `needPanel` event\n   * @ko `needPanel`이벤트가 발생하기 위한 뷰포트 끝으로부터의 최대 거리\n   * @type {number}\n   * @default 0\n   */\n  public get needPanelThreshold() { return this._needPanelThreshold; }\n  /**\n   * When enabled, events are not triggered before `ready` when initializing\n   * @ko 활성화할 경우 초기화시 `ready` 이벤트 이전의 이벤트가 발생하지 않습니다.\n   * @type {boolean}\n   * @default true\n   */\n  public get preventEventsBeforeInit() { return this._preventEventsBeforeInit; }\n  // ANIMATION\n  /**\n   * Deceleration value for panel movement animation which is triggered by user input. A higher value means a shorter animation time\n   * @ko 사용자의 동작으로 가속도가 적용된 패널 이동 애니메이션의 감속도. 값이 높을수록 애니메이션 실행 시간이 짧아집니다\n   * @type {number}\n   * @default 0.0075\n   */\n  public get deceleration() { return this._deceleration; }\n  /**\n   * An easing function applied to the panel movement animation. Default value is `easeOutCubic`\n   * @ko 패널 이동 애니메이션에 적용할 easing 함수. 기본값은 `easeOutCubic`이다\n   * @type {function}\n   * @default x => 1 - Math.pow(1 - x, 3)\n   * @see Easing Functions Cheat Sheet {@link http://easings.net/} <ko>이징 함수 Cheat Sheet {@link http://easings.net/}</ko>\n   */\n  public get easing() { return this._easing; }\n  /**\n   * Default duration of the animation (ms)\n   * @ko 디폴트 애니메이션 재생 시간 (ms)\n   * @type {number}\n   * @default 500\n   */\n  public get duration() { return this._duration; }\n  // INPUT\n  /**\n   * Types of input devices to enable\n   * @ko 활성화할 입력 장치 종류\n   * @type {string[]}\n   * @default [\"touch\", \"mouse\"]\n   * @see {@link https://naver.github.io/egjs-axes/release/latest/doc/global.html#PanInputOption Possible values (PanInputOption#inputType)}\n   * <ko>{@link https://naver.github.io/egjs-axes/release/latest/doc/global.html#PanInputOption 가능한 값들 (PanInputOption#inputType)}</ko>\n   */\n  public get inputType() { return this._inputType; }\n  /**\n   * Movement style by user input. This will change instance type of {@link Flicking#control}\n   * You can use the values of the constant {@link MOVE_TYPE}\n   * @ko 사용자 입력에 의한 이동 방식. 이 값에 따라 {@link Flicking#control}의 인스턴스 타입이 결정됩니다\n   * 상수 {@link MOVE_TYPE}에 정의된 값들을 이용할 수 있습니다\n   * @type {MOVE_TYPE | Pair<string, object>}\n   * @default \"snap\"\n   * @example\n   * |moveType|control|options|\n   * |:---:|:---:|:---:|\n   * |\"snap\"|{@link SnapControl}||\n   * |\"freeScroll\"|{@link FreeControl}|{@link FreeControlOptions}|\n   *\n   * ```ts\n   * import Flicking, { MOVE_TYPE } from \"@egjs/flicking\";\n   *\n   * const flicking = new Flicking({\n   *   moveType: MOVE_TYPE.SNAP\n   * });\n   * ```\n   *\n   * ```ts\n   * const flicking = new Flicking({\n   *   // If you want more specific settings for the moveType\n   *   // [moveType, options for that moveType]\n   *   // In this case, it's [\"freeScroll\", FreeControlOptions]\n   *   moveType: [MOVE_TYPE.FREE_SCROLL, { stopAtEdge: true }]\n   * });\n   * ```\n   */\n  public get moveType() { return this._moveType; }\n  /**\n   * Movement threshold to change panel (unit: px). It should be dragged above the threshold to change the current panel.\n   * @ko 패널 변경을 위한 이동 임계값 (단위: px). 주어진 값 이상으로 스크롤해야만 패널 변경이 가능하다.\n   * @type {number}\n   * @default 40\n   */\n  public get threshold() { return this._threshold; }\n  /**\n   * Set animation to be interruptable by click/touch.\n   * @ko 사용자의 클릭/터치로 인해 애니메이션을 도중에 멈출 수 있도록 설정합니다.\n   * @type {boolean}\n   * @default true\n   */\n  public get interruptable() { return this._interruptable; }\n  /**\n   * The size value of the bounce area. Only can be enabled when `circular=false`.\n   * You can set different bounce value for prev/next direction by using array.\n   * `number` for px value, and `string` for px, and % value relative to viewport size.\n   * You have to call {@link Control#updateInput} after changing this to take effect.\n   * @ko Flicking이 최대 영역을 넘어서 갈 수 있는 최대 크기. `circular=false`인 경우에만 사용할 수 있습니다.\n   * 배열을 통해 prev/next 방향에 대해 서로 다른 바운스 값을 지정할 수 있습니다.\n   * `number`를 통해 px값을, `stirng`을 통해 px 혹은 뷰포트 크기 대비 %값을 사용할 수 있습니다.\n   * 이 값을 변경시 {@link Control#updateInput}를 호출해야 합니다.\n   * @type {string | number | Array<string | number>}\n   * @default \"20%\"\n   * @example\n   * ```ts\n   * const possibleOptions = [\n   *   // % values, relative to viewport element(\".flicking-viewport\")'s size\n   *   \"0%\", \"25%\", \"42%\",\n   *   // px values, arithmetic calculation with (+/-) is also allowed.\n   *   \"0px\", \"100px\", \"50% - 25px\",\n   *   // numbers, same to number + px (\"0px\", \"100px\")\n   *   0, 100, 1000\n   * ];\n   * ```\n   *\n   * @example\n   * ```ts\n   * const flicking = new Flicking(\"#el\", { bounce: \"20%\" });\n   *\n   * flicking.bounce = \"100%\";\n   * flicking.control.updateInput(); // Call this to update!\n   * ```\n   */\n  public get bounce() { return this._bounce; }\n  /**\n   * Size of the area from the right edge in iOS safari (in px) which enables swipe-back or swipe-forward\n   * @ko iOS Safari에서 swipe를 통한 뒤로가기/앞으로가기를 활성화하는 오른쪽 끝으로부터의 영역의 크기 (px)\n   * @type {number}\n   * @default 30\n   */\n  public get iOSEdgeSwipeThreshold() { return this._iOSEdgeSwipeThreshold; }\n  /**\n   * Automatically prevent `click` event if the user has dragged at least a single pixel on the viewport element\n   * @ko 사용자가 뷰포트 영역을 1픽셀이라도 드래그했을 경우 자동으로 {@link https://developer.mozilla.org/ko/docs/Web/API/Element/click_event click} 이벤트를 취소합니다\n   * @type {boolean}\n   * @default true\n   */\n  public get preventClickOnDrag() { return this._preventClickOnDrag; }\n  /**\n   * Automatically call {@link Flicking#disableInput disableInput()} on initialization\n   * @ko Flicking init시에 {@link Flicking#disableInput disableInput()}을 바로 호출합니다\n   * @type {boolean}\n   * @default false\n   */\n  public get disableOnInit() { return this._disableOnInit; }\n  // PERFORMANCE\n  /**\n   * Whether to render visible panels only. This can dramatically increase performance when there're many panels.\n   * @ko 보이는 패널만 렌더링할지 여부를 설정합니다. 패널이 많을 경우에 퍼포먼스를 크게 향상시킬 수 있습니다.\n   * @type {boolean}\n   * @default false\n   */\n  public get renderOnlyVisible() { return this._renderOnlyVisible; }\n  // OTHERS\n  /**\n   * Call {@link Flicking#init init()} automatically when creating Flicking's instance\n   * @ko Flicking 인스턴스를 생성할 때 자동으로 {@link Flicking#init init()}를 호출합니다\n   * @type {boolean}\n   * @default true\n   * @readonly\n   */\n  public get autoInit() { return this._autoInit; }\n  /**\n   * Attach Flicking's {@link Flicking#resize resize} method to window's resize event.\n   * Flicking will automatically call {@link Flicking#resize resize} window size and orientation change.\n   * @ko Flicking의 {@link Flicking#resize resize} 메소드를 window의 resize 이벤트 핸들러로 등록합니다.\n   * 설정시 window 창 크기 및 orientation 변경에 의해 자동으로 {@link Flicking#resize resize}를 호출합니다.\n   * @type {boolean}\n   * @default true\n   */\n  public get autoResize() { return this._autoResize; }\n  /**\n   * This is an option for the frameworks(React, Vue, Angular, ...). Don't set it as it's automatically managed by Flicking.\n   * @ko 프레임워크(React, Vue, Angular, ...)에서만 사용하는 옵션으로, 자동으로 설정되므로 따로 사용하실 필요 없습니다!\n   * @type {boolean}\n   * @default false\n   * @internal\n   * @readonly\n   */\n  public get renderExternal() { return this._renderExternal; }\n\n  // Options Setter\n  // UI / LAYOUT\n  public set align(val: FlickingOptions[\"align\"]) {\n    this._align = val;\n    this._renderer.align = val;\n    this._camera.align = val;\n  }\n\n  public set defaultIndex(val: FlickingOptions[\"defaultIndex\"]) { this._defaultIndex = val; }\n  public set horizontal(val: FlickingOptions[\"horizontal\"]) { this._horizontal = val; }\n  public set circular(val: FlickingOptions[\"circular\"]) { this._circular = val; }\n  public set bound(val: FlickingOptions[\"bound\"]) { this._bound = val; }\n  public set adaptive(val: FlickingOptions[\"adaptive\"]) { this._adaptive = val; }\n  // EVENTS\n  public set needPanelThreshold(val: FlickingOptions[\"needPanelThreshold\"]) { this._needPanelThreshold = val; }\n  public set preventEventsBeforeInit(val: FlickingOptions[\"preventEventsBeforeInit\"]) { this._preventEventsBeforeInit = val; }\n  // ANIMATION\n  public set deceleration(val: FlickingOptions[\"deceleration\"]) { this._deceleration = val; }\n  public set easing(val: FlickingOptions[\"easing\"]) { this._easing = val; }\n  public set duration(val: FlickingOptions[\"duration\"]) { this._duration = val; }\n  // INPUT\n  public set inputType(val: FlickingOptions[\"inputType\"]) { this._inputType = val; }\n  public set moveType(val: FlickingOptions[\"moveType\"]) { this._moveType = val; }\n  public set threshold(val: FlickingOptions[\"threshold\"]) { this._threshold = val; }\n  public set interruptable(val: FlickingOptions[\"interruptable\"]) { this._interruptable = val; }\n  public set bounce(val: FlickingOptions[\"bounce\"]) { this._bounce = val; }\n  public set iOSEdgeSwipeThreshold(val: FlickingOptions[\"iOSEdgeSwipeThreshold\"]) { this._iOSEdgeSwipeThreshold = val; }\n  public set preventClickOnDrag(val: FlickingOptions[\"preventClickOnDrag\"]) {\n    const prevVal = this._preventClickOnDrag;\n\n    if (val === prevVal) return;\n\n    const controller = this._control.controller;\n\n    if (val) {\n      controller.addPreventClickHandler();\n    } else {\n      controller.removePreventClickHandler();\n    }\n\n    this._preventClickOnDrag = val;\n  }\n\n  public set disableOnInit(val: FlickingOptions[\"disableOnInit\"]) { this._disableOnInit = val; }\n  // PERFORMANCE\n  public set renderOnlyVisible(val: FlickingOptions[\"renderOnlyVisible\"]) { this._renderOnlyVisible = val; }\n  // OTHERS\n  public set autoResize(val: FlickingOptions[\"autoResize\"]) { this._autoResize = val; }\n\n  /**\n   * @param root A root HTMLElement to initialize Flicking on it. When it's a typeof `string`, it should be a css selector string\n   * <ko>Flicking을 초기화할 HTMLElement로, `string` 타입으로 지정시 css 선택자 문자열을 지정해야 합니다.</ko>\n   * @param {object} [options={}] An options object for Flicking.<ko>Flicking에 적용할 옵션 오브젝트</ko>\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE WRONG_TYPE}|When the root is not either string or HTMLElement|\n   * |{@link ERROR_CODE ELEMENT_NOT_FOUND}|When the element with given CSS selector does not exist|\n   * <ko>\n   *\n   * |code|조건|\n   * |---|---|\n   * |{@link ERROR_CODE WRONG_TYPE}|루트 엘리먼트가 string이나 HTMLElement가 아닐 경우|\n   * |{@link ERROR_CODE ELEMENT_NOT_FOUND}|주어진 CSS selector로 엘리먼트를 찾지 못했을 경우|\n   *\n   * </ko>\n   * @example\n   * ```ts\n   * import Flicking from \"@egjs/flicking\";\n   *\n   * // Creating new instance of Flicking with HTMLElement\n   * const flicking = new Flicking(document.querySelector(\".flicking-viewport\"), { circular: true });\n   *\n   * // Creating new instance of Flicking with CSS selector\n   * const flicking2 = new Flicking(\".flicking-viewport\", { circular: true });\n   * ```\n   */\n  public constructor(root: HTMLElement | string, {\n    align = ALIGN.CENTER,\n    defaultIndex = 0,\n    horizontal = true,\n    circular = false,\n    bound = false,\n    adaptive = false,\n    needPanelThreshold = 0,\n    preventEventsBeforeInit = true,\n    deceleration = 0.0075,\n    duration = 500,\n    easing = x => 1 - Math.pow(1 - x, 3),\n    inputType = [\"mouse\", \"touch\"],\n    moveType = \"snap\",\n    threshold = 40,\n    interruptable = true,\n    bounce = \"20%\",\n    iOSEdgeSwipeThreshold = 30,\n    preventClickOnDrag = true,\n    disableOnInit = false,\n    renderOnlyVisible = false,\n    autoInit = true,\n    autoResize = true,\n    renderExternal = null\n  }: Partial<FlickingOptions> = {}) {\n    super();\n\n    // Internal states\n    this._initialized = false;\n    this._plugins = [];\n\n    // Bind options\n    this._align = align;\n    this._defaultIndex = defaultIndex;\n    this._horizontal = horizontal;\n    this._circular = circular;\n    this._bound = bound;\n    this._adaptive = adaptive;\n    this._needPanelThreshold = needPanelThreshold;\n    this._preventEventsBeforeInit = preventEventsBeforeInit;\n    this._deceleration = deceleration;\n    this._duration = duration;\n    this._easing = easing;\n    this._inputType = inputType;\n    this._moveType = moveType;\n    this._threshold = threshold;\n    this._interruptable = interruptable;\n    this._bounce = bounce;\n    this._iOSEdgeSwipeThreshold = iOSEdgeSwipeThreshold;\n    this._preventClickOnDrag = preventClickOnDrag;\n    this._disableOnInit = disableOnInit;\n    this._renderOnlyVisible = renderOnlyVisible;\n    this._autoResize = autoResize;\n    this._autoInit = autoInit;\n    this._renderExternal = renderExternal;\n\n    // Create core components\n    this._viewport = new Viewport(getElement(root));\n    this._renderer = this._createRenderer();\n    this._camera = this._createCamera();\n    this._control = this._createControl();\n\n    this.resize = this.resize.bind(this);\n\n    if (this._autoInit) {\n      void this.init();\n    }\n  }\n\n  /**\n   * Initialize Flicking and move to the default index\n   * This is automatically called on Flicking's constructor when `autoInit` is true(default)\n   * @ko Flicking을 초기화하고, 디폴트 인덱스로 이동합니다\n   * 이 메소드는 `autoInit` 옵션이 true(default)일 경우 Flicking이 생성될 때 자동으로 호출됩니다\n   * @fires Flicking#ready\n   * @return {this}\n   */\n  public async init(): Promise<void> {\n    if (this._initialized) return;\n\n    const camera = this._camera;\n    const renderer = this._renderer;\n    const control = this._control;\n    const originalTrigger = this.trigger;\n    const preventEventsBeforeInit = this._preventEventsBeforeInit;\n\n    camera.init(this);\n    renderer.init(this);\n    control.init(this);\n\n    if (preventEventsBeforeInit) {\n      this.trigger = () => this;\n    }\n\n    await this.resize();\n\n    // Look at initial panel\n    this._moveToInitialPanel();\n\n    if (this._autoResize) {\n      window.addEventListener(\"resize\", this.resize);\n    }\n    if (this._preventClickOnDrag) {\n      control.controller.addPreventClickHandler();\n    }\n    if (this._disableOnInit) {\n      this.disableInput();\n    }\n\n    this._plugins.forEach(plugin => plugin.init(this));\n\n    // Done initializing & emit ready event\n    this._initialized = true;\n    if (preventEventsBeforeInit) {\n      this.trigger = originalTrigger;\n    }\n    this.trigger(new ComponentEvent(EVENTS.READY));\n\n    return;\n  }\n\n  /**\n   * Destroy Flicking and remove all event handlers\n   * @ko Flicking과 하위 컴포넌트들을 초기 상태로 되돌리고, 부착된 모든 이벤트 핸들러를 제거합니다\n   * @return {void}\n   */\n  public destroy(): void {\n    if (!this._initialized) return;\n\n    this.off();\n    window.removeEventListener(\"resize\", this.resize);\n\n    this._control.destroy();\n    this._camera.destroy();\n    this._renderer.destroy();\n\n    this._plugins.forEach(plugin => plugin.destroy());\n\n    this._initialized = false;\n  }\n\n  /**\n   * Move to the previous panel (current index - 1)\n   * @ko 이전 패널로 이동합니다 (현재 인덱스 - 1)\n   * @param {number} [duration={@link Flicking#duration options.duration}] Duration of the panel movement animation (unit: ms)<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>\n   * @async\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|When the previous panel does not exist|\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|When the animation is already playing|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the any of the event's `stop()` is called|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|이전 패널이 존재하지 않을 경우|\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|애니메이션이 이미 진행중인 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the previous panel<ko>이전 패널 도달시에 resolve되는 Promise</ko>\n   */\n  public prev(duration: number = this._duration): Promise<void> {\n    return this.moveTo(this._control.activePanel?.prev()?.index ?? -1, duration, DIRECTION.PREV);\n  }\n\n  /**\n   * Move to the next panel (current index + 1)\n   * @ko 다음 패널로 이동합니다 (현재 인덱스 + 1)\n   * @param {number} [duration={@link Flicking#duration options.duration}] Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>\n   * @async\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|When the next panel does not exist|\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|When the animation is already playing|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the any of the event's `stop()` is called|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|다음 패널이 존재하지 않을 경우|\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|애니메이션이 이미 진행중인 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the next panel<ko>다음 패널 도달시에 resolve되는 Promise</ko>\n   */\n  public next(duration: number = this._duration) {\n    return this.moveTo(this._control.activePanel?.next()?.index ?? this._renderer.panelCount, duration, DIRECTION.NEXT);\n  }\n\n  /**\n   * Move to the panel with given index\n   * @ko 주어진 인덱스에 해당하는 패널로 이동합니다\n   * @param {number} index The index of the panel to move<ko>이동할 패널의 인덱스</ko>\n   * @param {number} [duration={@link Flicking#duration options.duration}] Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {DIRECTION} [direction=DIRECTION.NONE] Direction to move, only available in the {@link Flicking#circular circular} mode<ko>이동할 방향. {@link Flicking#circular circular} 옵션 활성화시에만 사용 가능합니다</ko>\n   * @async\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|When the root is not either string or HTMLElement|\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|When the animation is already playing|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the any of the event's `stop()` is called|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|해당 인덱스를 가진 패널이 존재하지 않을 경우|\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|애니메이션이 이미 진행중인 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target panel<ko>해당 패널 도달시에 resolve되는 Promise</ko>\n   */\n  public moveTo(index: number, duration: number = this._duration, direction: ValueOf<typeof DIRECTION> = DIRECTION.NONE) {\n    const renderer = this._renderer;\n    const panelCount = renderer.panelCount;\n\n    const panel = renderer.getPanel(index);\n\n    if (!panel) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.INDEX_OUT_OF_RANGE(index, 0, panelCount - 1), ERROR.CODE.INDEX_OUT_OF_RANGE));\n    }\n\n    if (this._control.animating) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.ANIMATION_ALREADY_PLAYING, ERROR.CODE.ANIMATION_ALREADY_PLAYING));\n    }\n\n    return this._control.moveToPanel(panel, {\n      duration,\n      direction\n    });\n  }\n\n  /**\n   * Return the {@link Panel} at the given index. `null` if it doesn't exists.\n   * @ko 주어진 인덱스에 해당하는 {@link Panel}을 반환합니다. 주어진 인덱스에 해당하는 패널이 존재하지 않을 경우 `null`을 반환합니다.\n   * @return {Panel | null} Panel at the given index<ko>주어진 인덱스에 해당하는 패널</ko>\n   * @see Panel\n   * @example\n   * ```ts\n   * const panel = flicking.getPanel(0);\n   * // Which is a shorthand to...\n   * const samePanel = flicking.panels[0];\n   * ```\n   */\n  public getPanel(index: number): Panel | null {\n    return this._renderer.getPanel(index);\n  }\n\n  /**\n   * Enable input from the user (mouse/touch)\n   * @ko 사용자의 입력(마우스/터치)를 활성화합니다\n   * @return {this}\n   */\n  public enableInput(): this {\n    this._control.enable();\n    return this;\n  }\n\n  /**\n   * Disable input from the user (mouse/touch)\n   * @ko 사용자의 입력(마우스/터치)를 막습니다\n   * @return {this}\n   */\n  public disableInput(): this {\n    this._control.disable();\n    return this;\n  }\n\n  /**\n   * Get current flicking status. You can restore current state by giving returned value to {@link Flicking#setStatus setStatus()}\n   * @ko 현재 상태를 반환합니다. 반환받은 값을 {@link Flicking#setStatus setStatus()} 메소드의 인자로 지정하면 현재 상태를 복원할 수 있습니다\n   * @param {object} options Status retrieving options<ko>Status 반환 옵션</ko>\n   * @param {boolean} [options.index=true] Include current panel index to the returning status. Camera will automatically move to the given index when the {@link Flicking#setStatus setStatus} is called<ko>현재 패널 인덱스를 반환값에 포함시킵니다. {@link Flicking#setStatus setStatus} 호출시 자동으로 해당 인덱스로 카메라를 움직입니다</ko>\n   * @param {boolean} [options.position=true] Include camera position to the returning status. This works only when the {@link Flicking#moveType moveType} is `freeScroll`<ko>카메라의 현재 위치를 반환값에 포함시킵니다. 이 옵션은 {@link Flicking#moveType moveType}이 `freeScroll`일 경우에만 동작합니다</ko>\n   * @param {boolean} [options.includePanelHTML=false] Include panel's `outerHTML` to the returning status<ko>패널의 `outerHTML`을 반환값에 포함시킵니다</ko>\n   * @param {boolean} [options.visiblePanelsOnly=false] Include only {@link Flicking#visiblePanel visiblePanel}'s HTML. This option is available only when the `includePanelHTML` is true\n   * <ko>현재 보이는 패널({@link Flicking#visiblePanel visiblePanel})의 HTML만 반환합니다. `includePanelHTML`이 `true`일 경우에만 동작합니다.</ko>\n   * @return {Partial<Status>} An object with current status value information<ko>현재 상태값 정보를 가진 객체.</ko>\n   */\n  public getStatus({\n    index = true,\n    position = true,\n    includePanelHTML = false,\n    visiblePanelsOnly = false\n  }: Partial<{\n    index: boolean;\n    position: boolean;\n    includePanelHTML: boolean;\n    visiblePanelsOnly: boolean;\n  }> = {}): Status {\n    const camera = this._camera;\n    const panels = visiblePanelsOnly ? this.visiblePanels : this.panels;\n\n    const status: Status = {\n      panels: panels.map(panel => {\n        const panelInfo: Status[\"panels\"][0] = { index: panel.index };\n\n        if (includePanelHTML) {\n          panelInfo.html = panel.element.outerHTML;\n        }\n\n        return panelInfo;\n      })\n    };\n\n    if (index) {\n      status.index = this.index;\n    }\n    if (position) {\n      const nearestAnchor = camera.findNearestAnchor(camera.position);\n\n      if (nearestAnchor) {\n        status.position = {\n          panel: nearestAnchor.panel.index,\n          progressInPanel: camera.getProgressInPanel(nearestAnchor.panel)\n        };\n      }\n\n    }\n\n    if (visiblePanelsOnly) {\n      const visiblePanels = this.visiblePanels;\n\n      status.visibleOffset = visiblePanels[0]?.index ?? 0;\n    }\n\n    return status;\n  }\n\n  /**\n   * Restore to the state of the given {@link Status}\n   * @ko 주어진 {@link Status}의 상태로 복원합니다\n   * @param {Partial<Status>} status Status value to be restored. You should use the return value of the {@link Flicking#getStatus getStatus()} method<ko>복원할 상태 값. {@link Flicking#getStatus getStatus()} 메서드의 반환값을 지정하면 됩니다</ko>\n   * @return {void}\n   */\n  public setStatus(status: Status): void {\n    if (!this._initialized) {\n      throw new FlickingError(ERROR.MESSAGE.NOT_INITIALIZED, ERROR.CODE.NOT_INITIALIZED);\n    }\n\n    const {\n      index,\n      position,\n      visibleOffset,\n      panels\n    } = status;\n\n    const renderer = this._renderer;\n    const control = this._control;\n\n    // Can't add/remove panels on external rendering\n    if (panels[0]?.html && !this._renderExternal) {\n      renderer.batchRemove({ index: 0, deleteCount: this.panels.length });\n      renderer.batchInsert({ index: 0, elements: parseElement(panels.map(panel => panel.html!)) });\n    }\n\n    if (index) {\n      const panelIndex = visibleOffset\n        ? index - visibleOffset\n        : index;\n\n      void this.moveTo(panelIndex, 0).catch(() => void 0);\n    }\n\n    if (position && this._moveType === MOVE_TYPE.FREE_SCROLL) {\n      const { panel, progressInPanel } = position;\n      const panelIndex = visibleOffset\n        ? panel - visibleOffset\n        : panel;\n      const panelRange = renderer.panels[panelIndex].range;\n      const newCameraPos = panelRange.min + (panelRange.max - panelRange.min) * progressInPanel;\n\n      void control.moveToPosition(newCameraPos, 0).catch(() => void 0);\n    }\n  }\n\n  /**\n   * Add plugins that can have different effects on Flicking\n   * @ko 플리킹에 다양한 효과를 부여할 수 있는 플러그인을 추가합니다\n   * @param {...Plugin} plugins The plugin(s) to add<ko>추가할 플러그인(들)</ko>\n   * @return {this}\n   * @see https://github.com/naver/egjs-flicking-plugins\n   */\n  public addPlugins(...plugins: Plugin[]) {\n    if (this._initialized) {\n      plugins.forEach(item => item.init(this));\n    }\n\n    this._plugins.push(...plugins);\n\n    return this;\n  }\n\n  /**\n   * Remove plugins from Flicking.\n   * @ko 플리킹으로부터 플러그인들을 제거합니다.\n   * @param {...Plugin} plugin The plugin(s) to remove.<ko>제거 플러그인(들).</ko>\n   * @return {this}\n   * @see https://github.com/naver/egjs-flicking-plugins\n   */\n  public removePlugins(...plugins: Plugin[]) {\n    plugins.forEach(item => {\n      const foundIndex = findIndex(this._plugins, val => val === item);\n\n      if (foundIndex >= 0) {\n        item.destroy();\n        this._plugins.splice(foundIndex, 1);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Update viewport/panel sizes\n   * @ko 패널 및 뷰포트의 크기를 갱신합니다\n   * @method\n   * @fires Flicking#beforeResize\n   * @fires Flicking#afterResize\n   * @return {this}\n   */\n  public async resize(): Promise<void> {\n    const viewport = this._viewport;\n    const renderer = this._renderer;\n    const camera = this._camera;\n    const control = this._control;\n\n    const activePanel = control.activePanel;\n    const prevWidth = viewport.width;\n    const prevHeight = viewport.height;\n    const prevProgressInPanel = activePanel\n      ? camera.getProgressInPanel(activePanel)\n      : 0;\n\n    this.trigger(new ComponentEvent(EVENTS.BEFORE_RESIZE, {\n      width: prevWidth,\n      height: prevHeight,\n      element: viewport.element\n    }));\n\n    viewport.resize();\n    await renderer.forceRenderAllPanels(); // Render all panel elements, to update sizes\n    renderer.updatePanelSize();\n    await renderer.render();\n    camera.updateAlignPos();\n    camera.updateRange();\n    camera.updateAnchors();\n\n    if (control.animating) {\n      // TODO:\n    } else {\n      await control.updatePosition(prevProgressInPanel);\n      control.updateInput();\n    }\n\n    const newWidth = viewport.width;\n    const newHeight = viewport.height;\n    const sizeChanged = newWidth !== prevWidth || newHeight !== prevHeight;\n\n    this.trigger(new ComponentEvent(EVENTS.AFTER_RESIZE, {\n      width: viewport.width,\n      height: viewport.height,\n      prev: {\n        width: prevWidth,\n        height: prevHeight\n      },\n      sizeChanged,\n      element: viewport.element\n    }));\n  }\n\n  /**\n   * Add new panels after the last panel\n   * @ko 패널 목록의 제일 끝에 새로운 패널들을 추가합니다\n   * @param {ElementLike | ElementLike[]} element A new HTMLElement, a outerHTML of element, or an array of both\n   * <ko>새로운 HTMLElement, 혹은 엘리먼트의 outerHTML, 혹은 그것들의 배열</ko>\n   * @return {Panel[]} An array of appended panels<ko>추가된 패널들의 배열</ko>\n   * @see Panel\n   * @see ElementLike\n   * @throws {FlickingError} {@link ERROR_CODE ERROR_CODE.NOT_ALLOWED_IN_FRAMEWORK} if called on frameworks (React, Angular, Vue...)\n   * @example\n   * ```ts\n   * const flicking = new Flicking(\"#flick\");\n   * // These are possible parameters\n   * flicking.append(document.createElement(\"div\"));\n   * flicking.append(\"\\<div\\>Panel\\</div\\>\");\n   * flicking.append([\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]);\n   * // Even this is possible\n   * flicking.append(\"\\<div\\>Panel 1\\</div\\>\\<div\\>Panel 2\\</div\\>\");\n   * ```\n   */\n  public append(element: ElementLike | ElementLike[]): Panel[] {\n    return this.insert(this._renderer.panelCount, element);\n  }\n\n  /**\n   * Add new panels before the first panel\n   * This will increase index of panels after by the number of panels added\n   * @ko 패널 목록의 제일 앞(index 0)에 새로운 패널들을 추가합니다\n   * 추가한 패널의 개수만큼 기존 패널들의 인덱스가 증가합니다.\n   * @param {ElementLike | ElementLike[]} element A new HTMLElement, a outerHTML of element, or an array of both\n   * <ko>새로운 HTMLElement, 혹은 엘리먼트의 outerHTML, 혹은 그것들의 배열</ko>\n   * @return {Panel[]} An array of prepended panels<ko>추가된 패널들의 배열</ko>\n   * @see Panel\n   * @see ElementLike\n   * @throws {FlickingError} {@link ERROR_CODE ERROR_CODE.NOT_ALLOWED_IN_FRAMEWORK} if called on frameworks (React, Angular, Vue...)\n   * @example\n   * ```ts\n   * const flicking = new eg.Flicking(\"#flick\");\n   * flicking.prepend(document.createElement(\"div\"));\n   * flicking.prepend(\"\\<div\\>Panel\\</div\\>\");\n   * flicking.prepend([\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]);\n   * // Even this is possible\n   * flicking.prepend(\"\\<div\\>Panel 1\\</div\\>\\<div\\>Panel 2\\</div\\>\");\n   * ```\n   */\n  public prepend(element: ElementLike | ElementLike[]): Panel[] {\n    return this.insert(0, element);\n  }\n\n  /**\n   * Insert new panels at given index\n   * This will increase index of panels after by the number of panels added\n   * @ko 주어진 인덱스에 새로운 패널들을 추가합니다\n   * 해당 인덱스보다 같거나 큰 인덱스를 가진 기존 패널들은 추가한 패널의 개수만큼 인덱스가 증가합니다.\n   * @param {number} index Index to insert new panels at<ko>새로 패널들을 추가할 인덱스</ko>\n   * @param {ElementLike | ElementLike[]} element A new HTMLElement, a outerHTML of element, or an array of both\n   * <ko>새로운 HTMLElement, 혹은 엘리먼트의 outerHTML, 혹은 그것들의 배열</ko>\n   * @return {Panel[]} An array of prepended panels<ko>추가된 패널들의 배열</ko>\n   * @throws {FlickingError} {@link ERROR_CODE ERROR_CODE.NOT_ALLOWED_IN_FRAMEWORK} if called on frameworks (React, Angular, Vue...)\n   * @example\n   * ```ts\n   * const flicking = new eg.Flicking(\"#flick\");\n   * flicking.insert(0, document.createElement(\"div\"));\n   * flicking.insert(2, \"\\<div\\>Panel\\</div\\>\");\n   * flicking.insert(1, [\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]);\n   * // Even this is possible\n   * flicking.insert(3, \"\\<div\\>Panel 1\\</div\\>\\<div\\>Panel 2\\</div\\>\");\n   * ```\n   */\n  public insert(index: number, element: ElementLike | ElementLike[]): Panel[] {\n    if (this._renderExternal) {\n      throw new FlickingError(ERROR.MESSAGE.NOT_ALLOWED_IN_FRAMEWORK, ERROR.CODE.NOT_ALLOWED_IN_FRAMEWORK);\n    }\n\n    return this._renderer.batchInsert({ index, elements: parseElement(element) });\n  }\n\n  /**\n   * Remove the panel at the given index\n   * This will decrease index of panels after by the number of panels removed\n   * @ko 주어진 인덱스의 패널을 제거합니다\n   * 해당 인덱스보다 큰 인덱스를 가진 기존 패널들은 제거한 패널의 개수만큼 인덱스가 감소합니다\n   * @param {number} index Index of panel to remove<ko>제거할 패널의 인덱스</ko>\n   * @param {number} [deleteCount=1] Number of panels to remove from index<ko>`index` 이후로 제거할 패널의 개수</ko>\n   * @return {Panel[]} An array of removed panels<ko>제거된 패널들의 배열</ko>\n   */\n  public remove(index: number, deleteCount: number = 1): Panel[] {\n    if (this._renderExternal) {\n      throw new FlickingError(ERROR.MESSAGE.NOT_ALLOWED_IN_FRAMEWORK, ERROR.CODE.NOT_ALLOWED_IN_FRAMEWORK);\n    }\n\n    return this._renderer.batchRemove({ index, deleteCount });\n  }\n\n  private _createControl(): Control {\n    const moveType = this._moveType;\n    const moveTypes = Object.keys(MOVE_TYPE).map(key => MOVE_TYPE[key] as ValueOf<typeof MOVE_TYPE>);\n\n    const moveTypeStr = Array.isArray(moveType)\n      ? moveType[0]\n      : moveType;\n\n    const moveTypeOptions = Array.isArray(moveType)\n      ? moveType[1] ?? {}\n      : {};\n\n    if (!includes(moveTypes, moveTypeStr)) {\n      throw new FlickingError(ERROR.MESSAGE.WRONG_OPTION(\"moveType\", JSON.stringify(moveType)), ERROR.CODE.WRONG_OPTION);\n    }\n\n    switch (moveTypeStr) {\n      case MOVE_TYPE.SNAP:\n        return new SnapControl();\n      case MOVE_TYPE.FREE_SCROLL:\n        return new FreeControl(moveTypeOptions as FreeControlOptions);\n      case MOVE_TYPE.STRICT:\n        return new StrictControl(moveTypeOptions as StrictControlOptions);\n    }\n  }\n\n  private _createCamera(): Camera {\n    const cameraOption = { align: this._align };\n\n    if (this._circular) {\n      if (this._bound) {\n        // eslint-disable-next-line no-console\n        console.warn(\"\\\"circular\\\" and \\\"bound\\\" option cannot be used together, ignoring bound.\");\n      }\n      return new CircularCamera(cameraOption);\n    } else if (this._bound) {\n      return new BoundCamera(cameraOption);\n    } else {\n      return new LinearCamera(cameraOption);\n    }\n  }\n\n  private _createRenderer(): Renderer {\n    const renderingStrategy = this._renderOnlyVisible\n      ? new VisibleRenderingStrategy()\n      : new RawRenderingStrategy();\n\n    const rendererOptions = {\n      align: this._align,\n      strategy: renderingStrategy\n    };\n\n    const renderExternal = this._renderExternal;\n\n    return renderExternal\n      ? new (renderExternal.renderer as any)({ ...rendererOptions, ...renderExternal.rendererOptions })\n      : new VanillaRenderer(rendererOptions);\n  }\n\n  private _moveToInitialPanel(): void {\n    const renderer = this._renderer;\n    const control = this._control;\n    const initialPanel = renderer.getPanel(this._defaultIndex) || renderer.getPanel(0);\n\n    if (!initialPanel) return;\n\n    void control.moveToPanel(initialPanel, {\n      duration: 0\n    });\n  }\n}\n\nexport default Flicking;\n","import { DiffResult } from \"@egjs/list-differ\";\n\nimport Flicking from \"../Flicking\";\nimport Renderer from \"../renderer/Renderer\";\n\nexport default (flicking: Flicking, diffResult: DiffResult<any>, rendered: any[]) => {\n  const renderer = flicking.renderer;\n\n  if (diffResult.removed.length > 0) {\n    let startIdx = -1;\n    let prevIdx = -1;\n\n    diffResult.removed.forEach((removedIdx, idx) => {\n      if (startIdx < 0) {\n        startIdx = idx;\n      }\n\n      if (prevIdx >= 0 && removedIdx !== prevIdx + 1) {\n        batchRemove(renderer, diffResult, startIdx, idx + 1);\n\n        startIdx = -1;\n        prevIdx = -1;\n      } else {\n        prevIdx = removedIdx;\n      }\n    });\n\n    if (startIdx >= 0) {\n      batchRemove(renderer, diffResult, startIdx);\n    }\n  }\n\n  diffResult.ordered.forEach(([prevIdx, newIdx]) => {\n    const prevPanel = renderer.panels[prevIdx];\n    const indexDiff = newIdx - prevIdx;\n\n    if (indexDiff > 0) {\n      prevPanel.increaseIndex(indexDiff);\n    } else {\n      prevPanel.decreaseIndex(-indexDiff);\n    }\n    // Update position\n    prevPanel.resize();\n  });\n\n  if (diffResult.added.length > 0) {\n    let startIdx = -1;\n    let prevIdx = -1;\n\n    diffResult.added.forEach((addedIdx, idx) => {\n      if (startIdx < 0) {\n        startIdx = idx;\n      }\n\n      if (prevIdx >= 0 && addedIdx !== prevIdx + 1) {\n        batchInsert(renderer, diffResult, rendered, startIdx, idx + 1);\n\n        startIdx = -1;\n        prevIdx = -1;\n      } else {\n        prevIdx = addedIdx;\n      }\n    });\n\n    if (startIdx >= 0) {\n      batchInsert(renderer, diffResult, rendered, startIdx);\n    }\n  }\n};\n\nconst batchInsert = (renderer: Renderer, diffResult: DiffResult<any>, rendered: any[], startIdx: number, endIdx?: number) => {\n  renderer.batchInsert(\n    ...diffResult.added.slice(startIdx, endIdx).map((index, elIdx) => ({ index, elements: [rendered[elIdx + diffResult.prevList.length]] }))\n  );\n};\n\nconst batchRemove = (renderer: Renderer, diffResult: DiffResult<any>, startIdx: number, endIdx?: number) => {\n  const removed = diffResult.removed.slice(startIdx, endIdx);\n\n  renderer.batchRemove({ index: startIdx, deleteCount: removed.length });\n};\n\n","import { FlickingOptions } from \"../Flicking\";\nimport { ALIGN } from \"../const/external\";\nimport { parseArithmeticExpression } from \"../utils\";\n\nexport default (align: FlickingOptions[\"align\"] = ALIGN.CENTER, horizontal: boolean = true, firstPanelSize?: string) => {\n  const cameraAlign = getCameraAlign(align);\n  const panelAlign = getPanelAlign(align);\n\n  if (panelAlign == null) return \"\";\n\n  const camPosition = `calc(${cameraAlign} - (${firstPanelSize || \"0px\"} * ${panelAlign.percentage}) - ${panelAlign.absolute}px)`;\n\n  return horizontal\n    ? `translate(${camPosition})`\n    : `translate(0, ${camPosition})`;\n};\n\nconst getCameraAlign = (align: FlickingOptions[\"align\"]) => {\n  const alignVal = typeof align === \"object\"\n    ? (align as { camera: string | number }).camera\n    : align;\n\n  return parseAlign(alignVal);\n};\n\nconst getPanelAlign = (align: FlickingOptions[\"align\"]) => {\n  const alignVal = typeof align === \"object\"\n    ? (align as { panel: string | number }).panel\n    : align;\n\n  return parseArithmeticExpression(parseAlign(alignVal));\n};\n\nconst parseAlign = (alignVal: number | string) => {\n  if (typeof alignVal === \"number\") {\n    return `${alignVal}px`;\n  }\n\n  switch (alignVal) {\n    case ALIGN.CENTER:\n      return \"50%\";\n    case ALIGN.NEXT:\n      return \"100%\";\n    case ALIGN.PREV:\n      return \"0%\";\n    default:\n      return alignVal;\n  }\n};\n","import Component from \"@egjs/component\";\n\nimport Flicking from \"../Flicking\";\n\n/**\n * Decorator that makes the method of flicking available in the framework.\n * @ko 프레임워크에서 플리킹의 메소드를 사용할 수 있게 하는 데코레이터.\n * @memberof eg.Flicking\n * @private\n * @example\n * ```js\n * import Flicking, { withFlickingMethods } from \"@egjs/flicking\";\n *\n * class Flicking extends React.Component<Partial<FlickingProps & FlickingOptions>> {\n *   &#64;withFlickingMethods\n *   private flicking: Flicking;\n * }\n * ```\n */\nconst withFlickingMethods = (prototype: any, flickingName: string) => {\n  [Component.prototype, Flicking.prototype].forEach(proto => {\n    Object.getOwnPropertyNames(proto).filter(name => !prototype[name] && !name.startsWith(\"_\") && name !== \"constructor\")\n      .forEach((name: string) => {\n        const descriptor = Object.getOwnPropertyDescriptor(proto, name)!;\n\n        if (descriptor.value) {\n          // Public Function\n          Object.defineProperty(prototype, name, {\n            value: function(...args) {\n              return descriptor.value.call(this[flickingName], ...args);\n            }\n          });\n        } else {\n          const getterDescriptor: { get?: () => any; set?: (val: any) => void } = {};\n          if (descriptor.get) {\n            getterDescriptor.get = function() {\n              return descriptor.get?.call(this[flickingName]);\n            };\n          }\n          if (descriptor.set) {\n            getterDescriptor.set = function(...args) {\n              return descriptor.set?.call(this[flickingName], ...args);\n            };\n          }\n\n          Object.defineProperty(prototype, name, getterDescriptor);\n        }\n      });\n  });\n};\n\nexport default withFlickingMethods;\n","import { DiffResult } from \"@egjs/list-differ\";\n\nimport Flicking from \"../Flicking\";\n\nexport default <T>(flicking: Flicking, diffResult: DiffResult<T>) => {\n  const removedPanels = diffResult.removed.reduce((map, idx) => {\n    map[idx] = true;\n    return map;\n  }, {});\n\n  return [\n    ...flicking.panels\n      .filter(panel => !removedPanels[panel.index])\n      // Sort panels by position\n      .sort((panel1, panel2) => (panel1.position + panel1.offset) - (panel2.position + panel2.offset))\n      .map(panel => diffResult.prevList[panel.index]),\n    ...diffResult.added.map(idx => diffResult.list[idx])\n  ];\n};\n\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking from \"./Flicking\";\nimport * as Core from \"./core\";\nimport * as Camera from \"./camera\";\nimport * as Control from \"./control\";\nimport * as Renderer from \"./renderer\";\nimport * as Constants from \"./const/external\";\nimport * as CFC from \"./cfc\";\nimport { merge } from \"./utils\";\n\nmerge(Flicking, Core);\nmerge(Flicking, Camera);\nmerge(Flicking, Control);\nmerge(Flicking, Renderer);\nmerge(Flicking, Constants);\nmerge(Flicking, CFC);\n\nexport default Flicking;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Panel, { PanelOptions } from \"./Panel\";\n\nexport interface ExternalPanelOptions<T> extends PanelOptions {\n  externalComponent: T;\n}\n\n/**\n * An slide data component that holds information of a single HTMLElement\n * @ko 슬라이드 데이터 컴포넌트로, 단일 HTMLElement의 정보를 갖고 있습니다\n */\nabstract class ExternalPanel<T = any> extends Panel {\n  protected _externalComponent: T;\n\n  /**\n   * @param {object} options An options object<ko>옵션 오브젝트</ko>\n   * @param {HTMLElement} [options.el] A `HTMLElement` panel's referencing<ko>패널이 참조하는 `HTMLElement`</ko>\n   * @param {number} [options.index] An initial index of the panel<ko>패널의 초기 인덱스</ko>\n   * @param {Constants.ALIGN | string | number} [options.align] An initial {@link Flicking#align align} value of the panel<ko>패널의 초기 {@link Flicking#align align}값</ko>\n   * @param {Flicking} [options.flicking] A Flicking instance panel's referencing<ko>패널이 참조하는 {@link Flicking} 인스턴스</ko>\n   */\n  public constructor(options: ExternalPanelOptions<T>) {\n    super(options);\n\n    this._externalComponent = options.externalComponent;\n  }\n}\n\nexport default ExternalPanel;\n"],"names":["merge","target","_i","sources","forEach","source","Object","keys","key","clamp","x","min","max","Math","getFlickingAttached","val","nameToThrowOnError","FlickingError","ERROR","NOT_ATTACHED_TO_FLICKING","toArray","iterable","slice","call","parseAlign","align","size","alignPoint","isString","ALIGN","PREV","CENTER","NEXT","parseArithmeticSize","WRONG_OPTION","getDirection","start","end","DIRECTION","NONE","parseElement","element","Array","isArray","elements","el","tempDiv","document","createElement","innerHTML","push","children","firstChild","removeChild","nodeType","Node","ELEMENT_NODE","WRONG_TYPE","getMinusCompensatedIndex","idx","includes","array","array_1","__values","circulatePosition","pos","getProgress","prev","next","getStyle","window","getComputedStyle","currentStyle","isBetween","message","code","_super","_this","setPrototypeOf","prototype","name","__extends","Error","CODE","ELEMENT_NOT_FOUND","VAL_MUST_NOT_NULL","INDEX_OUT_OF_RANGE","POSITION_NOT_REACHABLE","TRANSFORM_NOT_SUPPORTED","STOP_CALLED_BY_USER","ANIMATION_INTERRUPTED","ANIMATION_ALREADY_PLAYING","NOT_ALLOWED_IN_FRAMEWORK","NOT_INITIALIZED","NO_ACTIVE","MESSAGE","wrongVal","correctTypes","map","type","join","selector","optionName","position","EVENTS","READY","BEFORE_RESIZE","AFTER_RESIZE","HOLD_START","HOLD_END","MOVE_START","MOVE","MOVE_END","WILL_CHANGE","CHANGED","WILL_RESTORE","RESTORED","SELECT","NEED_PANEL","VISIBLE_CHANGE","REACH_EDGE","PANEL_CHANGE","MOVE_TYPE","SNAP","FREE_SCROLL","STRICT","cssValue","base","parsed","parseArithmeticExpression","percentage","absolute","cssRegex","matchResult","exec","sign","value","unit","parsedValue","parseFloat","signMultiplier","_el","_width","_height","_padding","left","right","top","bottom","_isBorderBoxSizing","this","_a","width","height","padding","isBorderBoxSizing","style","newWidth","newHeight","resize","elStyle","clientWidth","clientHeight","paddingLeft","paddingRight","paddingTop","paddingBottom","boxSizing","STATE_TYPE","EVENT","HOLD","CHANGE","RELEASE","ANIMATION_END","FINISH","POSITION_KEY","ctx","camera","prevPosition","flicking","axesEvent","transitTo","delta","AXES","newPosition","circularEnabled","range","lookAt","moveEvent","ComponentEvent","isTrusted","holding","direction","trigger","isCanceled","DISABLED","renderer","panelCount","holdStartEvent","HOLDING","animatingContext","control","controller","moveStartEvent","ANIMATING","onChange","State","inputEvent","offset","horizontal","offsetX","offsetY","DRAGGING","flick","setTo","IDLE","_releaseEvent","clickedElement","srcEvent","touch","changedTouches","elementFromPoint","clientX","clientY","cameraPosition","clickedPanelPosition","panels","clickedPanel","panels_1","panel","contains","index","_moveToChangedPosition","destPos","duration","moveToPosition","updateInput","stop","nextStateType","nextState","IdleState","HoldingState","DraggingState","AnimatingState","DisabledState","_state","eventType","externalCtx","currentState","onHold","onRelease","onAnimationEnd","onFinish","_dragged","e","preventDefault","stopPropagation","_resetInternalValues","_stateMachine","StateMachine","_axes","state","_animatingContext","axes","circular","axis","_panInput","isEnable","get","bounce","_flicking","Axes","deceleration","interruptable","easing","PanInput","viewport","inputType","iOSEdgeSwipeThreshold","scale","releaseOnScroll","connect","on","fire","removePreventClickHandler","destroy","enable","disable","controlParams","parsedVal","axm","set","cameraEl","_onAxesHold","_onAxesChange","addEventListener","_preventClickWhenDragged","off","removeEventListener","Promise","reject","startPos","animate","once","resolve","animationFinishHandler","interruptionHandler","_controller","AxesController","_activePanel","animating","init","_progressInPanel","activePanel","clampToReachablePosition","update","_b","nearestAnchor","findNearestAnchor","removed","canReach","camPos_1","camRangeDiff","rangeDiff","filter","reduce","nearestPosition","abs","Infinity","_triggerIndexChangeEvent","_animateToPosition","newActivePanel","triggeringEvent","event","currentPanel","animateTo","animation","_setActive","then","render","catch","err","prevActivePanel","updateAdaptiveHeight","prevIndex","prevPanel","clampedPosition","anchorAtPosition","prevPos","isOverThreshold","threshold","adjacentAnchor","getNextAnchor","getPrevAnchor","targetPanel","targetPos","Control","_c","stopAtEdge","_stopAtEdge","progressInPanel","panelRange","findAnchorIncludePosition","count","_count","_resetIndexRange","cameraRange","currentPos","currentIndex","prevPanelIndex","nextPanelIndex","nextPanel","nextPos","_indexRange","axesRange","indexRange","anchors","anchorPoints","firstAnchor","lastAnchor","length","shouldBounceToFirst","shouldBounceToLast","targetAnchor","_index","_pos","_panel","supportedStyle","documentElement","transformName","transforms_1","prefixedTransform","_transform","_align","_position","_alignPos","_offset","_range","_visiblePanels","_anchors","NaN","nearestPanel","panelPos","bounceSize","prevRange","nextRange","nextPosition","viewportEl","nameOnErrMsg","checkExistence","firstElementChild","_checkTranslateSupport","_refreshVisiblePanels","_checkNeedPanel","_checkReachEnd","_applyTransform","anchor","includePosition","nearest","prevDist","anchorIdx","dist","visibleRange","includeRange","alignVal","AnchorPoint","adaptive","setSize","unRenderedPanels","rendered","sizeIncludingMargin","_needPanelTriggered","newVisiblePanels","canSee","prevVisiblePanels","added","visiblePanels","needPanelTriggered","cameraSize","needPanelThreshold","cameraPrev","cameraNext","firstPanel","lastPanel","newPos","wasBetweenRange","isBetweenRange","actualPosition","getPanel","Camera","_circularOffset","_circularEnabled","positionInRange","anchorInRange","loopCount","floor","visibleInCurrentRange","firstPanelPrev","margin","lastPanelNext","visibleSize","panelSizeSum","canSetCircularMode","every","updateCircularToggleDirection","_updateCircularOffset","toggled","toggle","some","isToggled","sum","toggledPrev","toggledNext","toggleDirection","_calcPanelAreaSum","alignPos","viewportSize","shouldPrependBoundAnchor","shouldAppendBoundAnchor","indexOffset_1","panelAtMin","reachablePanels","newAnchors","splice","panelAtMax","nearestPanelAtMin","_findNearestPanel","panelIdx","markForShow","_d","strategy","RawRenderingStrategy","_renderingStrategy","_panels","panelAlign","_getPanelAlign","_collectPanels","items","allPanelsInserted","addedPanels","item","insertingIdx","panelsPushed","panelsInserted","_createPanel","insertedSize","_getPanelSizeSum","increaseIndex","increasePosition","_insertPanelElements","_updateCameraAndControl","moveToPanel","updateOffset","activeIndex","allPanelsRemoved","deleteCount","removingIdx","panelsPulled","panelsRemoved","removedSize","decreaseIndex","decreasePosition","_removePanelElements","resetActive","marginDiff","updateRange","updateAnchors","resetNeedPanelHistory","_removed","_resetInternalStates","_size","_margin","_toggled","_toggleDirection","cameraRangeDiff","progress","alignPosition","camPos","disappearPosNext","disappearPosPrev","checkingRange","offsetWidth","offsetHeight","marginLeft","marginRight","marginTop","marginBottom","_updateAlignPos","includeMargin","moveTo","_moveBy","togglePosition","_togglePosition","prevToggled","camRange","camAlignPosition","camVisibleRange","camVisibleSize","minimumVisible","maximumVisible","shouldBeVisibleAtMin","shouldBeVisibleAtMax","options","_rendered","Panel","wasRenderedPanels","parentElement","updateRenderingPanels","renderingPanels","_getRenderingPanelsByOrder","_resetPanelElementOrder","cameraElement","fragment","createDocumentFragment","appendChild","_removeAllChildsFromCamera","childNodes","node","TEXT_NODE","cameraChilds","ElementPanel","nextSibling","nextSiblingElement","insertBefore","reversedPanels","__spreadArray","reverse","nextPanelEl","nextElementSibling","sort","a","b","Renderer","visibleIndexes","visibles","markForHide","root","defaultIndex","_e","_f","_g","bound","_h","_j","_k","preventEventsBeforeInit","_l","_m","_o","pow","_p","_q","moveType","_r","_s","_t","_u","_v","preventClickOnDrag","_w","disableOnInit","_x","renderOnlyVisible","_y","autoInit","_z","autoResize","_0","renderExternal","_initialized","_plugins","_defaultIndex","_horizontal","_circular","_bound","_adaptive","_needPanelThreshold","_preventEventsBeforeInit","_deceleration","_duration","_easing","_inputType","_moveType","_threshold","_interruptable","_bounce","_iOSEdgeSwipeThreshold","_preventClickOnDrag","_disableOnInit","_renderOnlyVisible","_autoResize","_autoInit","_renderExternal","_viewport","Viewport","parent","targetEl","queryResult","querySelector","getElement","_renderer","_createRenderer","_camera","_createCamera","_control","_createControl","bind","addPreventClickHandler","originalTrigger","_moveToInitialPanel","disableInput","plugin","includePanelHTML","visiblePanelsOnly","status","panelInfo","html","outerHTML","getProgressInPanel","visibleOffset","batchRemove","batchInsert","newCameraPos","plugins","foundIndex","checker","findIndex","prevWidth","prevHeight","prevProgressInPanel","forceRenderAllPanels","updatePanelSize","updateAlignPos","updatePosition","sizeChanged","insert","moveTypes","moveTypeStr","moveTypeOptions","JSON","stringify","SnapControl","FreeControl","StrictControl","cameraOption","console","warn","CircularCamera","BoundCamera","LinearCamera","renderingStrategy","VisibleRenderingStrategy","rendererOptions","VanillaRenderer","initialPanel","Flicking","Component","diffResult","startIdx","endIdx","elIdx","prevList","getCameraAlign","getPanelAlign","flickingName","proto","getOwnPropertyNames","startsWith","getterDescriptor","descriptor","getOwnPropertyDescriptor","defineProperty","args","startIdx_1","prevIdx_1","startIdx_2","prevIdx_2","removedIdx","ordered","__read","prevIdx","newIdx","indexDiff","addedIdx","removedPanels","panel1","panel2","list","firstPanelSize","cameraAlign","camPosition","_externalComponent","externalComponent","Constants","CFC"],"mappings":"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"}